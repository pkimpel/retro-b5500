                                                                        00000000
% F O R T R A N  C O M P I L E R   XVI.0.00                10/01/74     00001000
  COMMENT: | TITLE: B5500/B5700 MARK XVI SYSTEM RELEASE            |    00001010        
           | FILE ID: SYMBOL/FORTRAN TAPE ID: SYMBOL1/FILE000      |    00001011
           | THIS MATERIAL IS PROPRIETARY TO BURROUGHS CORPORATION |    00001012
           | AND IS NOT TO BE REPRODUCED, USED, OR DISCLOSED       |    00001013
           | EXCEPT IN ACCORDANCE WITH PROGRAM LICENSE OR UPON     |    00001014
           | WRITTEN AUTHORIZATION OF THE PATENT DIVISION OF       |    00001015
           | BURROUGHS CORPORATION, DETROIT, MICHIGAN 48232        |    00001016
           |                                                       |    00001017
           | COPYRIGHT (C)  1971, 1972, 1974                       |    00001018
           |       BURROUGHS CORPORATION                           |    00001019
           |  AA320206   AA393180   AA332366                       |;   00001020 
% BEWARE ALL YE WHO SEEK HEREIN:                                   %997-00001100
% THIS COMPILER IS A MESS.  THE CONCEPTS OF CHARACTER CONVERSION FROM   00001105
% HOLLERITH (= EBCDIC), SCANNING, AND PARSING ARE NOT CLEARLY SEPARATED 00001110
% IN THE CODE,  FOR EXAMPLE, PROCEDURE "SCAN" TRIES TO DO ALL 3 AT ONCE.00001115
% DAN ROSS    UCSC    APRIL 12, 1977                               %997-00001120
COMMENT                                                                 00001900
                        FORTRAN ERROR MESSAGES                          00002000
000   SYNTAX ERROR                                                      00003000
001   MISSING OPERATOR OR PUNCTUATION                                   00004000
002   CONFLICTING COMMON AND/OR EQUIVALENCE ALLOCATION                  00005000
003   MISSING RIGHT PARENTHESIS                                         00006000
004   ENTRY STMT ILLEGAL IN MAIN PGM OR BLOCK DATA                      00007000
005   MISSING END STATEMENT                                             00008000
006   ARITHMETIC EXPRESSION REQUIRED                                    00009000
007   LOGICAL EXPRESSION REQUIRED                                       00010000
008   TOO MANY LEFT PARENTHESES                                         00011000
009   TOO MANY RIGHT PARENTHESES                                        00012000
010   FORMAL PARAMETER ILLEGAL IN COMMON                                00013000
011   FORMAL PARAMETER ILLEGAL IN EQUIVALENCE                           00014000
012   THIS STATEMENT ILLEGAL IN BLOCK DATA SUBPROGRAM                   00015000
013   INFO ARRAY OVERFLOW                                               00016000
014   IMPROPER DO NEST                                                  00017000
015   DO LABEL PREVIOUSLY DEFINED                                       00018000
016   UNRECOGNIZED STATEMENT TYPE                                       00019000
017   ILLEGAL DO STATEMENT                                              00020000
018   FORMAT STATEMENT MUST HAVE LABEL                                  00021000
019   UNDEFINED LABEL                                                   00022000
020   MULTIPLE DEFINITION                                               00023000
021   ILLEGAL IDENTIFIER CLASS IN THIS CONTEXT                          00024000
022   UNPAIRED QUOTES IN FORMAT                                         00025000
023   NOT ENOUGH SUBSCRIPTS                                             00026000
024   TOO MANY SUBSCRIPTS                                               00027000
025   FUNCTION OR SUBROUTINE PREVIOUSLY DEFINED                         00028000
026   FORMAL PARAMETER MULTIPLY DEFINED IN HEADING                      00029000
027   ILLEGAL USE OF NAMELIST                                           00030000
028   NUMBER OF PARAMETERS INCONSISTENT                                 00031000
029   CANNOT BRANCH TO FORMAT STATEMENT                                 00032000
030   SUBROUTINE OR FUNCTION NOT DEFINED IN PROGRAM                     00033000
031   IDENTIFIER ALREADY GIVEN TYPE                                     00034000
032   ILLEGAL FORMAT SYNTAX                                             00035000
033   INCORRECT USE OF FILE                                             00036000
034   INCONSISTENT USE OF IDENTIFIER                                    00037000
035   ARRAY IDENTIFIER EXPECTED                                         00038000
036   EXPRESSION VALUE REQUIRED                                         00039000
037   ILLEGAL FILE CARD SYNTAX                                          00040000
038   ILLEGAL CONTROL ELEMENT                                           00041000
039   DECLARATION MUST PRECEDE FIRST REFERENCE                          00042000
040   INCONSISTENT USE OF LABEL AS PARAMETER                            00043000
041   NO. OF PARAMS. DISAGREES WITH PREV. REFERENCE                     00044000
042   ILLEGAL USE OF FORMAL PARAMETER                                   00045000
043   ERROR IN HOLLERITH LITERAL CHARACTER COUNT                        00046000
044   ILLEGAL ACTUAL PARAMETER                                          00047000
045   TOO MANY SEGMENTS IN SOURCE PROGRAM                               00048000
046   TOO MANY PRT ASSIGNMENTS IN SOURCE PROGRAM                        00049000
047   LAST BLOCK DECLARATION HAD LESS THAN 1024 WORDS                   00050000
048   ILLEGAL I/O LIST ELEMENT                                          00051000
049   LEFT SIDE MUST BE SIMPLE OR SUBSCRIPTED VARIABLE                  00052000
050   VARIABLE EXPECTED                                                 00053000
051   ILLEGAL USE OF .OR.                                               00054000
052   ILLEGAL USE OF .AND.                                              00055000
053   ILLEGAL USE OF .NOT.                                              00056000
054   ILLEGAL USE OF RELATIONAL OPERATOR                                00057000
055   ILLEGAL MIXED TYPES                                               00058000
056   ILLEGAL EXPRESSION STRUCTURE                                      00059000
057   ILLEGAL PARAMETER                                                 00060000
058   RECORD BLOCK GREATER THAN 1023                                    00061000
059   TOO MANY OPTIONAL FILES                                           00062000
060   FILE CARDS MUST PRECEDE SOURCE DECK                               00063000
061   BINARY WRITE STATEMENT HAS NO LIST                                00064000
062   UNDEFINED FORMAT NUMBER                                           00065000
063   ILLEGAL EXPONENT IN CONSTANT                                      00066000
064   ILLEGAL CONSTANT IN DATA STATEMENT                                00067000
065   MAIN PROGRAM MISSING                                              00068000
066   PARAMETER MUST BE ARRAY IDENTIFIER                                00069000
067   PARAMETER MUST BE EXPRESSION                                      00070000
068   PARAMETER MUST BE LABEL                                           00071000
069   PARAMETER MUST BE FUNCTION IDENTIFIER                             00072000
070   PARAMETER MUST BE FUNCTION OR SUBROUTINE ID                       00073000
071   PARAMETER MUST BE SUBROUTINE IDENTIFIER                           00074000
072   PARAMETER MUST BE ARRAY IDENTIFIER OR EXPRESSION                  00075000
073   ARITHMETIC - LOGICAL CONFLICT ON STORE                            00076000
074   ARRAYID MUST BE SUBSCRIPTED IN THIS CONTEXT                       00077000
075   MORE THAN ONE MAIN PROGRAM                                        00078000
076   ONLY COMMON ELEMENTS PERMITTED                                    00079000
077   TOO MANY FILES                                                    00080000                       
078   FORMAT OR NAMELIST TOO LONG                                       00081000                       
079   FORMAL PARAMETER MUST BE ARRAY IDENTIFIER                         00082000                       
080   FORMAL PARAMETER MUST BE SIMPLE VARIABLE                          00083000                       
081   FORMAL PARAMETER MUST BE FUNCTION IDENTIFIER                      00084000                       
082   FORMAL PARAMETER MUST BE SUBROUTINE IDENTIFIER                    00085000                       
083   FORMAL PARAMETER MUST BE FUNCTION OR SUBROUTINE                   00086000                       
084   DO OR IMPLIED DO INDEX MUST BE INTEGER OR REAL                    00087000                       
085   ILLEGAL COMPLEX CONSTANT                                          00088000                       
086   ILLEGAL MIXED TYPE STORE                                          00089000                       
087   CONSTANT EXCEEDS HARDWARE LIMITS                                  00090000                       
088   PARAMETER TYPE CONFLICTS WITH PREVIOUS USE                        00091000                       
089   COMPLEX EXPRESSION ILLEGAL IN IF STATEMENT                        00092000                       
090   COMPLEX EXPRESSION ILLEGAL IN RELATION                            00093000                       
091   TOO MANY FORMATS REFERENCED BUT NOT YET FOUND                     00094000                       
092   VARIABLE ARRAY BOUND MUST BE FORMAL VARIABLE                      00095000                       
093   ARRAY BOUND MUST HAVE INTEGER OR REAL TYPE                        00096000                       
094   COMMA OR RIGHT PARENTHESIS EXPECTED                               00097000                       
095   ARRAY ALREADY GIVEN BOUNDS                                        00098000                       
096   ONLY FORMAL ARRAYS MAY BE GIVEN VARIABLE BOUNDS                   00099000                       
097   MISSING LEFT PARENTHESIS IN IMPLIED DO                            00100000                       
098   SUBSCRIPT MUST BE INTEGER OR REAL                                 00101000                       
099   ARRAY SIZE CANNOT EXCEED 32767 WORDS                              00102000                       
100   COMMON OR EQUIV BLOCK CANNOT EXCEED 32767 WORDS                   00103000                       
101   THIS STATEMENT ILLEGAL IN LOGICAL IF                              00104000                       
102   REAL OR INTEGER TYPE REQUIRED                                     00105000                       
103   ARRAY BOUND INFORMATION REQUIRED                                  00106000                       
104   REPLACEMENT OPERATOR EXPECTED                                     00107000                       
105   IDENTIFIER EXPECTED                                               00108000                       
106   LEFT PARENTHESIS EXPECTED                                         00109000                       
107   ILLEGAL FORMAL PARAMETER                                          00110000                       
108   RIGHT PARENTHESIS EXPECTED                                        00111000                       
109   STATEMENT NUMBER EXPECTED                                         00112000                       
110   SLASH EXPECTED                                                    00113000                       
111   ENTRY STATEMENT CANNOT START PROGRAM UNIT                         00114000                       
112   ARRAY MUST BE DIMENSIONED PRIOR TO EQUIV STMT                     00115000                       
113   INTEGER CONSTANT EXPECTED                                         00116000                       
114   COMMA EXPECTED                                                    00117000                       
115   SLASH OR END OF STATEMENT EXPECTED                                00118000                       
116   FORMAT, ARRAY OR NAMELIST EXPECTED                                00119000                       
117   END OF STATEMENT EXPECTED                                         00120000                       
118   IO STATEMENT WITH NAMELIST CANNOT HAVE IO LIST                    00121000                       
119   COMMA OR END OF STATEMENT EXPECTED                                00122000                       
120   STRING TOO LONG                                                   00123000                       
121   MISSING QUOTE AT END OF STRING                                    00124000                       
122   ILLEGAL ARRAY BOUND                                               00125000                       
123   TOO MANY HANGING BRANCHES                                         00126000                       
124   TOO MANY COMMON OR EQUIVALENCE ELEMENTS                           00127000                       
125   ASTERISK EXPECTED                                                 00128000                       
126   COMMA OR SLASH EXPECTED                                           00129000                       
127   DATA SET TOO LARGE                                                00130000                       
128   TOO MANY ENTRY STATEMENTS IN THIS SUBPROGRAM                      00131000                       
129   DECIMAL WIDTH EXCEEDS FIELD WIDTH                                 00132000                       
130   UNSPECIFIED FIELD WIDTH                                           00133000                       
131   UNSPECIFIED SCALE FACTOR                                          00134000                       
132   ILLEGAL FORMAT CHARACTER                                          00135000                       
133   UNSPECIFIED DECIMAL FIELD                                         00136000                       
134   DECIMAL FIELD ILLEGAL FOR THIS SPECIFIER                          00137000                       
135   ILLEGAL LABEL                                                     00138000                       
136   UNDEFINED NAMELIST                                                00139000                       
137   MULTIPLY DEFINED ACTION LABELS                                    00140000                       
138   TOO MANY NESTED DO STATEMENTS                                     00141000                       
139   STMT FUNCTION ID AND EXPRESSION DISAGREE IN TYPE                  00142000                       
140   ILLEGAL USE OF STATEMENT FUNCTION                                 00143000                       
141   UNRECOGNIZED CONSTRUCT                                            00143001                          
142   RETURN, STOP OR CALL EXIT REQUIRED IN SUBPROGRAM                  00143002                       
143   FORMAT NUMBER USED PREVIOUSLY AS LABEL                            00143003                       
144   LABEL USED PREVIOUSLY AS FORMAT NUMBER                            00143004                       
145   NON-STANDARD RETURN REQUIRES LABEL PARAMETERS                     00143005                       
146   DOUBLE OR COMPLEX REQUIRES EVEN OFFSET                            00143006                       
147   FORMAL PARAMETER ILLEGAL IN DATA STATEMENT                        00143007                       
148   TOO MANY LOCAL VARIABLES IN SOURCE PROGRAM                        00143008                       
149   A $FREEFORM SOURCE LINE MUST HAVE < 67 COLS                       00143009                       
150   A HOL/STRING UNDER $FREEFORM MUST BE ON ONE LINE                  00143010                       
151   THIS CONSTRUCT IS ILLEGAL IN TSS FORTRAN                          00143011                       
152   ILLEGAL FILE CARD PARAMETER VALUE                                 00143012                       
153   RETURN IN MAIN PROGRAM NOT ALLOWED                                00143013                       
154   NON-POSITIVE SUBSCRIPTS ARE ILLEGAL                               00143014                       
155   NON-IDENTIFIER USED FOR NAME OF LIBRARY ROUTINE                   00143015                       
156   HYPHEN EXPECTED                                                   00143016                       
157   SEQUENCE NUMBER EXPECTED                                          00143017                       
158   TOO MANY RECURSIVE CALLS ON LIBRARY ROUTINES                      00143018                       
159   ASTERISK NOT ALLOWED IN READ STATEMENT                            00143019                       
160   ASTERISK ONLY ALLOWED IN FREE FIELD OUTPUT                        00143020                       
161   TOO MANY *-ED LIST ELEMENTS IN OUTPUT                             00143021                       
162   HOL OR QUOTED STRING GREATER THAN 7 CHARACTERS IN EXPRESSION      00143022                       
164   PLUS NOT ALLOWED IN THIS FORMAT PHRASE                            00143023                       
165   K NOT ALLOWED IN THIS FORMAT PHRASE                               00143024                       
166   $ NOT ALLOWED IN THIS FORMAT PHRASE                               00143025                       
167   INTRINSICS-NAMED FUNCT MUST HAVE PREVIOUS EXTERNAL REFERENCE.     00143026                       
168   DATA STMT COMMON ELEM MUST BE IN BLK DATA SUBPRM                  00143027                       
169   VARIABLE CANNOT BE A FORMAL PARAMETER OR IN COMMON                00143028                       
170   CURRENT SUBPROGRAM ID EXPECTED                                    00143029                       
171   SUBPROGRAM, EXTERNAL, OR ARRAY ID EXPECTED                        00143030                       
172   REPEAT, WIDTH, AND DECIMAL PARTS MUST BE LESS THAN 4091           00143031                       
173   REPEAT PART MUST BE EMPTY OR >0 AND < 4091                        00143032                       
174   IN SUBPRGM:VARBL IS USED PRIOR TO USE IN DATSTMT                  00143033                       
175   SYNTATICAL TOKEN CONTAINS TOO MANY CHARACTERS                     00143034                       
176   INTEGER VALUE OF 8 EXPECTED                                       00143035                       
177   INTEGER VALUE OF 4 EXPECTED                                       00143036                       
178   INTEGER VALUE OF 4 OR 8 EXPECTED                                  00143037                       
179   AN ALPHABETIC LETTER (A,B,C,...,Z) IS REQUIRED                    00143038                       
180   SECOND RANGE LETTER MUST BE GREATER THAN FIRST                    00143039                       
181   IMPLICIT MUST BE FIRST STATEMENT IN PROGRAM UNIT                  00143040                       
182   REAL/INTEGER/LOGICAL/COMPLEX/DOUBLEPRECISION REQ                  00143041                       
183   ILLEGAL USE OF ASTERISK FOR RUN-TIME EDITING                 %111-00143042                       
184   NO PROGRAM UNIT FOR THIS END STATEMENT                       %112-00143043                       
;                                                                       00143999                      
BEGIN                                                                   00144000                       
INTEGER ERRORCT; COMMENT MUST BE FIRST DECLARED VARIABLE;               00145000                       
INTEGER SAVETIME; COMMENT MUST BE 2 ND DECLARED VARIABLE;               00146000                       
INTEGER CARDCOUNT,ESTIMATE,SEQERRCT ;                                   00147000                       
INTEGER SWARYCT;                                                        00147500                       
REAL TWODPRTX;                                                          00148000                       
REAL INITIALSEGNO;                                                      00149000                       
REAL NEXT, FNEXT, NAME, NUMTYPE;                                        00150000                       
REAL A, B, I, J, P, T, TS, Z;                                           00151000                       
REAL RTI;          % START COMPILE TIME                                 00152000                       
REAL EXPVALUE, EXPRESULT, EXPLINK;                                      00153000                       
REAL SPLINK, FUNVAR;                                                    00155000                       
      REAL DATAPRT,DATASTRT,DATALINK,DATASKP;                           00155100                       
BOOLEAN SCANENTER ; % TRUE IFF SCAN JUST DID AN ENTER ON AN ID.         00155110                       
DEFINE NUMINTM1=                                                        00155210                       
83                                                                      00155211                       
#;% NUMINTM1 IS THE NUMBER OF INTRINSICS MINUS 1; FOR EACH NEW INTRINSIC00155212                       
%   WHICH IS ADDED, ADD 1 TO THE VALUE ON SEQ# 00155211.                00155213                       
DEFINE MAXEL=15#;                                                       00156000                       
REAL ARRAY ENTRYLINK[0:MAXEL];                                          00157000                       
REAL ELX;                                                               00158000                       
ALPHA FNEW, NNEW;                                                       00159000                       
REAL LABELMOM;                                                          00160000                       
INTEGER LOCALS,PARMS,PRTS,FLAGROUTINECOUNTER ;                          00161000                       
REAL LIMIT, VOIDTSEQ;                                                   00161010                       
REAL IDINFO, TYPE, NSEG;                                                00162000                       
REAL FX1, FX2, FX3, NX1, NX2, NX3;                                      00163000                       
INTEGER LENGTH, LOWERBOUND, GROUPPRT;                                   00164000                       
ALPHA EQVID, INTID, REALID;                                             00165000                       
INTEGER ROOT, ADR;                                                      00166000                       
INTEGER LASTMODE ;  %%% = 1 FOR $CARD; = 2 FOR $TAPE.                   00166100                       
BOOLEAN ERRORTOG,%PREVIOUS LISTED RECORD.                               00167000                       
        EOSTOG,%END OF STMT TOGGLE.                                     00168000                       
        CODETOG,%LIST CODE GENERATED..                                  00168200                       
        TAPETOG,%MERGE TAPE INPUT.                                      00168400                       
        EODS,%END OF DECLRSTMTS, RESET BY ENDS.                         00168500                       
        FILETOG,%PROCESSING FILE CARDS.                                 00168600                       
        DEBUGTOG,%TO LIST OUT ENTRING AND EXITING PROCEDURES.           00169000                       
        DESCREQ,%DESCRIPTOR REQUIRED.                                   00169020                       
        XREF,%TO CREATE XREF OF PROGRAM.                                00169030                       
        SAVETOG;%VARIOUS BOOLEANS.                                      00169050                       
DEFINE  LIBTAPE      = SAVETOG.[47:1]#,%USE TO SAVE NEW WHILE INCLUDE.  00169053                       
        SAVEDEBUGTOG = SAVETOG.[46:1]#,%SAVE DEBUGTOG WHILE IN $INCLUDE.00169054                       
        SAVECODETOG  = SAVETOG.[45:1]#,%SAVE CODETOG WHILE IN $INCLUDE. 00169055                       
        SAVEPRTTOG   = SAVETOG.[44:1]#,%SAVE PRTOG WHILE IN $INCLUDE.   00169056                       
        SAVELISTOG   = SAVETOG.[43:1]#,%SAVE LISTOG WHILE IN $INCLUDE.  00169057                       
        VOIDTOG      = SAVETOG.[42:1]#,%TO VOID CARDS OR TAPE           00169058                       
        DATASTMTFLAG = SAVETOG.[41:1]#,%WHILE IN DATA STMTS,            00169059                       
        F2TOG        = SAVETOG.[40:1]#,%ADDR REL TO F+2,                00169060                       
        CHECKTOG     = SAVETOG.[39:1]#,%SEQ # CHECK,                    00169061                       
        LISTOG       = SAVETOG.[38:1]#,%TO LIST OUTPUT,                 00169062                       
        LISTLIBTOG   = SAVETOG.[37:1]#,%TO LIST LIBRARY OUTPUT,         00169063                       
        SEQTOG       = SAVETOG.[36:1]#,%TO RESEQ INPUTS,                00169064                       
        SEQERRORS    = SAVETOG.[35:1]#,%IF SEQUENCE ERRORS.             00169065                       
        TIMETOG      = SAVETOG.[34:1]#,%TO LIST WRAPUP INFO ONLY.       00169066                       
        PRTOG        = SAVETOG.[33:1]#,%TO LIST STORAGE MAP.            00169067                       
        NEWTPTOG     = SAVETOG.[32:1]#,%CREATE NEW SYMBOLIC TAPE.       00169068                       
        SINGLETOG    = SAVETOG.[31:1]#,%TO LIST OUTPUT SINGLE SPACED.   00169069                       
        SEGOVFLAG    = SAVETOG.[30:1]#,%SEGMENT OVERFLOW.               00169070                       
        FIRSTCALL    = SAVETOG.[29:1]#,%TO LIST COMPILER HEADING.       00169071                       
        RETURNFOUND  = SAVETOG.[28:1]#,%RETURN,CALL EXIT,STOP FOUND.    00169072                       
        ENDSEGTOG    = SAVETOG.[27:1]#,%END OF SEGMENT.                 00169073                       
        LOGIFTOG     = SAVETOG.[26:1]#,%PROCESSING LOGICAL IF STMT.     00169074                       
        NOTOPIO      = SAVETOG.[25:1]#,                                 00169075                       
        DATATOG      = SAVETOG.[24:1]#,%WHILE IN DATA STMTS.            00169076                       
        FREEFTOG     = SAVETOG.[23:1]#,%FREE FIELD INPUT.               00169077                       
        SEGPTOG      = SAVETOG.[22:1]#,%DONT PAGE AFTER SUBPRGM         00169078                       
        GLOBALNAME   = SAVETOG.[21:1]#,%TO WRITE ALL IDENTIFIERS.       00169079                       
        NAMEDESC     = SAVETOG.[20:1]#,%IF GLOBALNAME OR LOCALNAME TRUE 00169080                       
        LOCALNAME    = SAVETOG.[19:1]#,%TO WRITE AN IDENTIFIER.         00169081                       
        TSSEDITOG    = SAVETOG.[18:1]#,%TSSEDIT.                        00169082                       
        UNPRINTED    = SAVETOG.[17:1]#,%TO LIST CARD,FALSE IF LISTED.   00169083                       
        DCINPUT      = SAVETOG.[16:1]#,%IF USING TSS FORTRAN.           00169084                       
        SEGSW        = SAVETOG.[15:1]#,%TO MAINTAIN LINEDICT/LINESEG.   00169085                       
        TSSMESTOG    = SAVETOG.[14:1]#,%TSSMES(ERRMES).                 00169086                       
        WARNED       = SAVETOG.[13:1]#,%IS TSSEDIT WAS EVER EVOKED.     00169087                       
        SEGSWFIXED   = SAVETOG.[12:1]#,%IF SEGSW IS NOT TO BE ALTERED.  00169088                       
        REMFIXED     = SAVETOG.[11:1]#,%IF REMOTETOG ISNT TO BE ALTERED 00169089
        REMOTETOG    = SAVETOG.[10:1]#,%PRINT & READ STMTS = REMOTE     00169090
        RANDOMTOG    = SAVETOG.[10:1]#,%IF EXPR USED FOR RANDOM I/O.    00169091                       
        VOIDTTOG     = SAVETOG.[ 9:1]#,%TO VOID TAPE RECORDS ONLY.      00169092                       
        DOLIST       = SAVETOG.[ 8:1]#,%LIST DOLLAR CARDS.              00169093                       
        HOLTOG       = SAVETOG.[ 7:1]#,%INPUT IN HOLLERITH.             00169094                       
        LISTPTOG     = SAVETOG.[ 6:1]#,%LIST PATCHES ONLY.              00169095                       
        PXREF        = SAVETOG.[ 5:1]#,%TO LIST XREF OF PROGRAM.        00169096                       
        LASTLINE     = SAVETOG.[ 4:1]#,%TO DETR TO SKIP XREF.           00169097                       
        XGLOBALS     = SAVETOG.[ 3:1]#,%TO LET XREF KNOW OF DOING GLOBAL00169098                       
        NTAPTOG      = SAVETOG.[ 2:1]#,%TO CLOSE NEWTAPE IF EVER OPENED 00169099                       
        SEENADOUB    = SAVETOG.[40:1]#,%ARRAYDEC WONT BE USING THIS     00169100                       
                                       %WHILE WE FIX DP COMMON ARRAY SZ 00169102                       
ENDSAVTOGDEF=#;                                                         00169199                       
ARRAY SSNM[0:18] ; % THESE WORDS ARE USED FOR TEMP STORAGE AND STORING  00169200                       
                   % PERMANENT FLAGGED DATA.                            00169201                       
DEFINE LASTSEQ=SSNM[0]#, LASTERR=SSNM[1]#, LINKLIST=SSNM[2]# ;          00169210                       
DEFINE VOIDSEQ=SSNM[3] # ;                                              00169220                       
ALPHA ARRAY ERRORBUFF,PRINTBUFF[0:14] ;                                 00169300                       
ARRAY INLINEINT[0:35] ;                                                 00169310                       
DEFINE XRBUFF = 150#, XRBUFFDIV3=50 #;                                  00169320                       
ARRAY XRRY[0:XRBUFF-1] ;                                                00169330                       
INTEGER SEQBASE,SEQINCR;                                                00170000                       
INTEGER SCN,LABL,NEXTSCN,NEXTCARD;                                      00174000                       
INTEGER SAVECARD;   % TO SAVE NEXTCART WHILE IN $ INCLUDE               00174100                       
INTEGER RESULT,INSERTDEPTH;                                             00174200                       
REAL INCLUDE; % CONTAINS "INCLUDE"                                      00174300                       
REAL DEBUGADR ;                                                         00174310                       
ALPHA ACR0, CHR0, INITIALNCR;                                           00175000                       
ALPHA ACR, NCR ;                                                        00176000                       
SAVE ARRAY TIPE[0:63] ;                                                 00176500                       
REAL LASTNEXT ;                                                         00176502                       
ALPHA NEXTACC, NEXTACC2;                                                00177000                       
ALPHA BLANKS;                                                           00178000                       
ALPHA XTA;                                                              00179000                       
ALPHA ARRAY EDOC[0:7, 0:127];    COMMENT HOLDS CODE EMITTED;            00180000                       
ALPHA ARRAY HOLDID[0:2];                                                00181000                       
REAL NXAVIL,STRTSEG;                                                    00182000                       
ALPHA ARRAY WOP[0:139];   % HOLDS NAME AND CODE OF WORD MODE OPERATORS  00183000                       
SAVE ALPHA ARRAY DB,TB,CB[0:9],                                         00184000                       
                 CRD[0:14];                                             00185000                       
ALPHA ARRAY XR[0:32];  INTEGER XRI;                                     00185100                       
SAVE ARRAY ACCUM, EXACCUM[0:20] ;                                       00186000                       
REAL ACCUMSTOP, EXACCUMSTOP ;                                           00186100                       
REAL DBLOW;                                                             00187000                       
REAL MAX;                                                               00188000                       
ALPHA ACR1, CHR1;                                                       00189000                       
ALPHA ARRAY PERIODWORD[0:10];                                           00190000                       
REAL ARRAY MAP[0:7];                                                    00191000                       
REAL F1, F2;                                                            00192000                       
INTEGER C1, C2;                                                         00193000                       
DEFINE                                                                  00194000                       
        RSP=14 #, RSP1=15 #, RWP=29 #,                                  00194020                       
        RSH=41 #, RSH1=42 #, RWS=83 #;                                  00194040                       
ALPHA ARRAY RESERVEDWORDSLP[0:RWP], RESLENGTHLP,LPGLOBAL[0:RSP],        00195000                       
            RESERVEDWORDS  [0:RWS], RESLENGTH           [0:RSH] ;       00195010                       
SAVE REAL ARRAY PR, OPST [0:25];  % USED IN EXPR ONLY                   00196000                       
DEFINE PARMLINK = LSTT#;                                                00197000                       
ALPHA BUFF, BUFL, SYMBOL;                                               00198000                       
INTEGER  TV, % INDEX INTO INFO FOR PRT OF LIST NAMES                    00199100                       
         SAVESUBS, %  MAX NUMBER OF SUBSCRIPTS FOR NAMELIST IDENTIFIERS 00199120                       
         NAMEIND ; %  INDEX INTO NAMLIST IDENTIFIERS ARRAY              00199130                       
ARRAY    NAMLIST[0:256]; % ARRAY TO STOKE NAMELIST IDENTIFIERS          00199200                       
ALPHA    LISTID;                                                        00199300                       
REAL ARRAY BDPRT[0:20]; REAL BDX;                                       00200000                       
DEFINE MAXSTRING = 49#;                                                 00201000                       
ALPHA ARRAY STRINGARRAY[0:MAXSTRING];                                   00202000                       
REAL STRINGSIZE;                  % NUMBER OF WORDS IN STRING           00203000                       
DEFINE LSTMAX = 256#;                                                   00204000                       
REAL ARRAY LSTT, LSTP[0:LSTMAX];                                        00205000                       
INTEGER LSTI,LSTS,LSTA;                                                 00206000                       
DEFINE MAXOPFILES = 63#, BIGGESTFILENB = 99#;                           00207000                       
ARRAY FILEINFO[0:3,0:MAXOPFILES];                                       00208000                       
DEFINE   %    SOME FILE STUFF                                           00208100                       
         SLOWV     = 2#,                                                00208110                       
         FASTV     = 1#,                                                00208120                       
         SENSPDEUNF= [1:8]#,                                            00208130                       
              SENSE= [1:1]#,                                            00208135                       
              SPDF = [2:2]#,                                            00208140                       
              EUNF = [4:5]#,                                            00208150                       
         FPBVERSION= 1#,                                                00208160                       
         FPBVERSF  = [1:8]#,                                            00208170                       
         DKAREASZ  = [9:39]#,                                           00208180                       
ENDFILDEF=#;                                                            00208490                       
INTEGER MAXFILES;                                                       00209000                       
ARRAY TEN[0:137];                                                       00210000                       
DEFINE LBRANCH = 50#;                                                   00211000                       
REAL ARRAY BRANCHES[0:LBRANCH]; REAL LAX, BRANCHX;                      00212000                        
INTEGER INXFIL,FILEARRAYPRT;                                            00213000                       
DEFINE MAXCOM=15 # ;                                                    00214000                       
INTEGER SUPERMAXCOM; %%% SUPERMAXCOM = 128|(MAXCOM+1).                  00214100                       
ALPHA ARRAY COM[0:MAXCOM,0:127] ;                                       00215000                       
REAL NEXTCOM;                                                           00216000                       
ALPHA ARRAY INFO[0:31, 0:127];                                          00217000                       
REAL ARYSZ;                                                             00218000                       
ALPHA ARRAY EXTRAINFO[0:31, 0:127];                                     00219000                       
REAL EXPT1, EXPT2, EXPT3;                                               00220000                       
DEFINE IR = [36:5]#, IC = [41:7]#;                                      00221000                       
REAL INFA,INFB,INFC;                                                    00222000                       
INTEGER NEXTINFO, GLOBALNEXTINFO, NEXTEXTRA;                            00223000                       
INTEGER NEXTSS;                                                         00224000                       
DEFINE SHX=189#, GHX=61#;                                               00225000                       
REAL ARRAY STACKHEAD[0:SHX];                                            00226000                       
REAL ARRAY GLOBALSTACKHEAD[0:GHX];                                      00227000                       
REAL LA, DT, TEST;                                                      00228000                       
ALPHA LADR1,LADR2,LADR3,LADR4,LADR5,LINFA;   INTEGER LINDX,LADDR;       00229000                       
DEFINE MAXDOS=20#;                                                      00230000                       
ALPHA ARRAY DOTEST, DOLAB[0:MAXDOS];                                    00231000                       
ALPHA LISTART;                                                          00232000                       
ALPHA ARRAY INT[0:NUMINTM1+NUMINTM1+2];                                 00233000                       
ALPHA ARRAY TYPES[0:6], KLASS[0:14];                                    00234000                       
INTEGER OP, PREC, IP, IT;                                               00235000                       
DEFINE DUMPSIZE=127 #;                                                  00237000                       
ARRAY FNNHOLD[0:DUMPSIZE];                                              00238000                       
INTEGER FNNINDEX,FNNPRT;                                                00239000                       
DEFINE MAXNBHANG = 30#;                                                 00240000                       
ARRAY FNNHANG[0:MAXNBHANG];                                             00241000                       
DEFINE INTCLASS=[6:3]#, INTPARMCLASS=[9:3]#, INTINLINE=[12:6]#,         00241010                       
       INTPRT =[24:6]#, INTPARMS   =[30:6]#, INTNUM  =[36:12]#,         00241020                       
       INAM  =[12:36]#, INTX       =[2:10]#, INTSEEN   =[2:1]# ;        00241030                       
DEFINE                                                                  00241200                       
       INSERTMAX = 20 #,  % MAX NO OF RECURSIVE CALL ALLOW ON LIB ROUT  00241220                       
       INSERTCOP = INSERTINFO[INSERTDEPTH,4] #,                         00241240                       
       INSERTMID = INSERTINFO[INSERTDEPTH,0] #,                         00241260                       
       INSERTFID = INSERTINFO[INSERTDEPTH,1] #,                         00241280                       
       INSERTINX = INSERTINFO[INSERTDEPTH,2] #,                         00241300                       
       INSERTSEQ = INSERTINFO[INSERTDEPTH,3] #;                         00241320                       
ARRAY INSERTINFO[0:INSERTMAX,0:4];                                      00241360                       
DEFINE MSRW=11 #;                                                       00241900                       
ALPHA ARRAY MESSAGE[0:MSRW,0:96] ;                                      00242000                       
BOOLEAN ARRAY MSFL[0:MSRW];                                             00242050                       
ALPHA ARRAY LINEDICT[0:7,0:127];  % LINE DICTIONARY ARRAY               00242100                       
ALPHA ARRAY LINESEG [0:11,0:127];  % LINE SEGMENT ARRAY                 00242200                       
ARRAY TSSMESA[0:15] ; %%% BIT FLAGS PRNTD ERR MESSGS ({748).            00242220                      
INTEGER NOLIN;  % NUMBER OF ENTRIES IN LINE SEGMENT                     00242300                       
REAL LASTADDR; %%% STORES LAST ADR.                                     00242700                       
INTEGER WARNCOUNT; %%% COUNTS NUMBER OF TSS WARNINGS.                   00242750                       
DEFINE CE       = [2:1]#,        %INFA                             %996-00243000                       
       LASTC    = [3:12]#,       %INFA                             %996-00244000 
       SEGNO    = [3:9]#,        %INFA                             %996-00245000 
       CLASS    = [15:5]#,       %INFA                             %996-00246000 
       EQ       = [20:1]#,       %INFA                             %996-00246100 
       SUBCLASS = [21:3]#,       %INFA                             %996-00247000 
       CLASNSUB = [14:10]#,      %INFA                             %996-00248000 
       ADJ      = [14:1]#,       %INFA                             %996-00249000 
       TWOD     = [14:1]#,       %INFA                             %996-00250000 
       FORMAL   = [13:1]#,       %INFA                             %996-00251000 
       TYPEFIXED= [12:1]#,       %INFA                             %996-00252000 
       ADDR     = [24:12]#,      %INFA                             %996-00253000 
       LINK     = [36:12]#,      %INFC                             %996-00254000 
       BASE     = [18:15]#,      %INFC                             %996-00255000 
       SIZE     = [33:15]#,      %INFC                             %996-00256000 
       BASENSIZE= [18:30]#,      %INFC                             %996-00257000 
       NEXTRA   = [2:6]#,        %INFC                             %996-00258000 
       ADINFO   = [8:10]#,       %INFC                             %996-00259000 
       RELADD   = [21:15]#,      %INFA                             %996-00260000 
       TOCE     = 2:47:1#,       %INFA                             %996-00261000 
       TOSEGNO  = 3:39:9#,       %INFA                             %996-00262000 
       TOLASTC  = 3:36:12#,      %INFA                             %996-00262100 
       TOCLASS  = 15:43:5#,      %INFA                             %996-00263000 
       TOEQ     = 20:47:1#,      %INFA                             %996-00263100 
       TOSUBCL  = 21:45:3#,      %INFA                             %996-00264000 
       TOADJ    = 14:47:1#,      %INFA                             %996-00265000 
       TOFORMAL = 13:47:1#,      %INFA                             %996-00266000 
       TOTYPE   = 12:47:1#,      %INFA                             %996-00267000 
       TOADDR   = 24:36:12#,     %INFA                             %996-00268000 
       TOLINK   = 36:36:12#,     %INFC                             %996-00269000 
       TOBASE   = 18:33:15#,     %INFC                             %996-00270000 
       TOSIZE   = 33:33:15#,     %INFC                             %996-00271000 
       TONEXTRA = 2:42:6#,       %INFC                             %996-00272000 
       TOADINFO = 8:38:10#,      %INFC                             %996-00273000 
       TORELADD = 21:33:15#,     %INFA                             %996-00274000 
    %THE FOLLOWING CLASSES APPEAR IN THE 1ST WORD OF EACH 3-WORD ENTRY  00274998 
    %OF THE "INFO" ARRAY, AND MAY BE COPIED TO INFA.CLASS.         %996-00274999 
       UNKNOWN  = 0#,                                                   00275000 
       ARRAYID  = 1#,                                                   00276000 
       VARID    = 2#,                                                   00277000 
       STMTFUNID= 3#,                                                   00278000 
       NAMELIST = 4#,                                                   00279000 
       FORMATID = 5#,                                                   00280000 
       LABELID  = 6#,                                                   00281000 
       FUNID    = 7#,                                                   00282000 
       INTRFUNID= 8#,                                                   00283000 
       EXTID    = 9#,                                                   00284000 
       SUBRID   = 10#,                                                  00285000 
       BLOCKID  = 11#,                                                  00286000 
       FILEID   = 12#,                                                  00287000 
       SUBSVAR  = 13#,                                                  00288000 
       EXPCLASS = 14#,                                                  00289000 
       SBVEXP   = 15#,                                                  00290000 
       LISTSID  = 16#,                                                  00290050 
       JUNK     = 17#,            % NOT A GENUINE CLASS            %996-00290055 
       DUMMY    = 27#,                                                  00290100 
       NUMCLASS = 28#,                                                  00291000 
       RESERVED = 29#,                                                  00292000 
       HEADER   = 30#,                                                  00293000 
       ENDCOM   = 31#,                                                  00294000 
   %THE FOLLOWING SUBCLASSES APPEAR IN THE 1ST WORD OF SOME 3-WORKD%996-00294998 
   %ENTRIES OF THE "INFO" ARRAY, AND MAY BE COPIED TO INFA.SUBCLASS.    00294999 
       INTYPE   = 1#,                                                   00295000 
       STRINGTYPE=2#,                                                   00296000 
       REALTYPE = 3#,                                                   00297000 
       LOGTYPE  = 4#,                                                   00298000 
       DOUBTYPE = 5#,                                                   00299000 
       COMPTYPE = 6#;                                                   00300000 
DEFINE   EOF= 500#, ID= 501#, NUM= 502#, PLUS= 503#, MINUS= 504#,       00301000 
         STAR= 505#, SLASH= 506#, LPAREN= 507#, RPAREN= 508#,           00302000 
         EQUAL= 509#, COMMA= 510#, SEMI= 511#, DOLLAR=0#, UPARROW=0# ;  00303000 
DEFINE THRU = STEP 1 UNTIL #;                                      %996-00316000 
DEFINE                                                                  00317000 
          ADD = 16#, BBC = 22#, BBW = 534#, BFC = 38#, BFW = 550#       00318000 
         ,CDC =168#, CHS =134#, COC =  40#, KOM =130#, DEL =  10#       00319000 
         ,DUP =261#, EQUL=581#, GBC = 278#, GBW =790#, GEQL=  21#       00320000 
         ,GFC =294#, GFW =806#, GRTR=  37#, IDV =384#, INX =  24#       00321000 
         ,ISD =532#, ISN =548#, LEQL= 533#, LND = 67#, LNG =  19#       00322000 
         ,LOD =260#, LOR = 35#, LQV = 131#, LESS=549#, MDS = 515#       00323000 
         ,MKS = 72#, MUL = 64#, NEQL=  69#, NOP = 11#, PRL =  18#       00324000 
         ,XRT = 12#, RDV =896#, RTN = 39#,RTS =167#, SND = 132#         00325000 
         , SSN = 70#, SSP = 582#, STD = 68#, SUB = 48#, XCH = 133#      00326000 
         ,XIT = 71#, ZP1 =322#, DIU =128#, STN =132#                    00327000 
         ,DIA = 45#, DIB = 49#, TRB = 53#, ISO = 37#                    00328000 
         ,AD2 =17#, SB2 = 49#, ML2 = 65#, DV2 =129#, FTC = 197#         00329000 
         ,SSF =280#, FTF =453#, CTC =709#, CTF = 965#                   00330000 
         ,TOP=262#                                                      00330010 
         ;                                                              00331000 
FORMAT FD(X100,"NEXT = ",I3,X2,2A6) ;                                   00332000 
FORMAT SEGSTRT(X63, " START OF SEGMENT **********", I4),                00333000 
       FLAGROUTINEFORMAT(X41,A6,A2,X1,2A6," (",A1,I*,")"),              00333010 
       XHEDM(X40,"CROSS REFERENCE LISTING OF MAIN PROGRAM",X41,/,       00333050 
             X40,"----- --------- ------- -- ---- -------",X41),        00333055 
       XHEDS(X38, "CROSS REFERENCE LISTING OF SUBROUTINE ",A6,X38,/,    00333060 
             X38, "----- --------- ------- -- ---------- ",A6,X38),     00333065 
       XHEDF(X35,"CROSS REFERENCE LISTING OF ",A6,A1," FUNCTION ",A6,   00333070 
       X35,/,X35,"----- --------- ------- -- ",A6,A1," -------- ",A6,   00333075 
       X35),                                                            00333076 
       XHEDG(X43,"CROSS REFERENCE LISTING OF GLOBALS",X43,/,            00333080 
             X43,"----- --------- ------- -- -------",X43),             00333085 
       XHEDB(X34,"CROSS REFERENCE LISTING OF BLOCK DATA SUBPROGRAM",X35,00333090 
         /,X34,"----- --------- ------- -- ----- ---- ----------",X35), 00333095 
       SEGEND (X70," SEGMENT",I5," IS",I5," LONG");                     00334000 
ARRAY PDPRT [0:31,0:63];                                                00335000 
REAL PDINX;        % INDEX OF LAST ENTRY IN PDPRT                       00336000 
REAL TSEGSZ;       % RUNNING COUNT OF TOTAL SEGMENT SIZE;               00337000 
         COMMENT FORMAT OF PRT&SEGMENT ENTRIES, IN PDPRT;               00338000 
DEFINE        STYPF= [1:2]#,  %  0 = PROGRAM SEGMENT-SEGMENT ENTRY ONLY 00339000 
              STYPC= 1:46:2#, %  1 = MCP INTRINSIC                      00340000 
                              %  2 = DATA SEGMENT                       00341000 
              DTYPF= [4:2]#,  %  0 = THUNK - PRT ENTRY ONLY             00342000 
              DTYPC= 4:46:2 #,%  1 = WORD MODE PROGRAM DESCRIPTOR       00343000 
                              %  2 = LABEL DESCRIPTOR                   00344000 
                              %  3 = CHARACTER MODE PROGRAM DESCRIPTOR  00345000 
              PRTAF= [8:10]#, %  ACTUAL PRT ADDRESS - PRT ENTRY         00346000 
              PRTAC= 8:38:10#,                                          00347000 
              RELADF = [18:10]#, % ADDRESS WITHIN SEGMENT -PRT ONLY     00348000 
              RELADC= 18:38:10#,                                        00349000 
              SGNOF=  [28:10]#, % SEGMENT NUMBER - BOTH                 00350000 
              SGNOC= 28:38:10#,                                         00351000 
              DKAI = [13:15]#,  % RELATIVE DISK ADDRESS - SEGMENT ENTRY 00352000 
              DKAC = 13:33:15#,                                         00353000 
              SEGSZF =[38:10]#, % SEGMENT SIZE - SEGMENT ENTRY          00354000 
              SEGSZC =38:38:10#;% MUST BE 0 IF PRT ENTRY                00355000 
DEFINE %      SOME EXTERNAL CONSTANTS                                   00355100 
          BLKCNTRLINT   = 5#,                                           00355110 
          FPLUS2        = 1538#,                                        00355120 
ENDEXTCONDEF=#;                                                         00355990 
DEFINE    PDIR = PDINX.[37:5]#,                                         00356000 
          PDIC = PDINX.[42:6]#;                                         00357000 
DEFINE CIS = CRD[0]#,    % CARD                                         00358000 
       TIS = CRD[1]#,    % TAPE                                         00359000 
       TOS = CRD[2]#,    % NEW TAPE                                     00360000 
       LOS = CRD[3]#;    % PRINTER                                      00361000 
DEFINE PWROOT=ROOT.IR,ROOT.IC #,PWI=I.IR,I.IC # ;                       00362000 
DEFINE GLOBALNEXT=NEXT#;                                                00363000 
BEGIN    % SCAN FPB TO SEE IF VARIOUS FILES ARE DISK OR TAPE            00364000 
INTEGER STREAM PROCEDURE GETFPB(Q); VALUE Q;                            00365000 
    BEGIN                                                               00366000 
         SI ~ LOC GETFPB; SI ~ SI - 7; DI ~ LOC Q; DI ~ DI + 5;         00367000 
         SKIP 3 DB; 9(IF SB THEN DS ~ SET ELSE DS ~ RESET;              00368000 
                      SKIP SB);                                         00369000 
         DI ~ LOC Q; SI ~ Q; DS ~ WDS; SI ~ Q; GETFPB ~ SI;             00370000 
    END;                                                                00371000 
INTEGER STREAM PROCEDURE GNC(Q); VALUE Q;                               00372000 
    BEGIN SI ~ Q; SI ~ SI + 7; DI ~ LOC GNC; DI ~ DI +7; DS ~CHR END;   00373000 
INTEGER FPBBASE;                                                        00374000 
        FPBBASE ~ GETFPB(3);                                            00375000 
        TIS ~ TOS ~ 50; CIS ~ LOS ~ 0;                                  00376000 
        IF GNC(FPBBASE+3) =12 THEN CIS ~ 150;    % CARD                 00377000 
        IF GNC(FPBBASE+8) =12 THEN LOS ~ 150;    % PRINTER              00378000 
        IF GNC(FPBBASE+13) = 12 THEN TOS ~ 150;    % NEW TAPE;          00379000 
        IF GNC(FPBBASE+18) =12 THEN TIS ~ 150;   % TAPE                 00380000 
    END;                                                                00381000 
BEGIN  COMMENT  INNER BLOCK;                                            00382000 
% *** DO NOT DECLARE ANY FILES PRIOR TO THIS POINT, DO NOT ALTER        00383000 
%      SEQUENCE OF FOLLOWING FILE DECLARATIONS                          00384000 
FILE CARD (5,10,CIS);                                                   00385000 
DEFINE LINESIZE = 900 #;                                                00386000 
SAVE FILE LINE DISK SERIAL [20:LINESIZE] (2,15,LOS,SAVE 10);            00387000 
SAVE FILE NEWTAPE DISK SERIAL [20:LINESIZE] "FORSYM" (2,10,TOS,SAVE 10);00388000 
FILE TAPE "FORSYM" (2,10,TIS);                                          00389000 
FILE REMOTE 19(2,10) ;                                                  00389500 
DEFINE CHUNK = 180#;                                                    00390000 
DEFINE PTR=LINE#,RITE=LINE#,CR=CARD#,TP=TAPE#;                     %515-00391000 
FILE CODE DISK RANDOM [20:CHUNK]  (4,30,SAVE ABS(SAVETIME));            00392000 
FILE LIBRARYFIL DISK RANDOM (2,10,150);                                 00392400 
DEFINE LF = LIBRARYFIL#;                                                00392600 
FILE XREFF DISK SERIAL[20:1500](2,XRBUFF) ;                             00392700 
FILE XREFG DISK SERIAL[20:1500](2,3,XRBUFF);                            00392800 
REAL DALOC;        % DISK ADDRESS                                       00393000 
LABEL POSTWRAPUP;                                                       00393100 
PROCEDURE EMITNUM(N); VALUE N; REAL N; FORWARD;                         00394000 
REAL PROCEDURE LOOKFORINTRINSIC(L);  VALUE L;  REAL L;  FORWARD ;       00394500 
PROCEDURE SEGOVF; FORWARD;                                              00395000 
DEFINE BUMPADR= IF (ADR~ADR+1)=4089 THEN SEGOVF#;                       00396000 
DEFINE BUMPLOCALS = BEGIN IF LOCALS~LOCALS+1>255 THEN BEGIN FLAG(148);  00396500 
                           LOCALS~2 END END#;                           00396510 
DEFINE BUMPPRT=BEGIN IF PRTS~PRTS+1>1023 THEN BEGIN FLAG(46);           00396600 
                           PRTS~40 END END#;                            00396610 
DEFINE EDOCI = ADR.[36:3], ADR.[39:7]#;                                 00397000 
DEFINE TWODPRT=IF TWODPRTX=0 THEN(TWODPRTX~PRTS~PRTS+1)ELSE TWODPRTX#;  00398000 
REAL PROCEDURE SEARCH(E); VALUE E; REAL E; FORWARD;                     00399010 
PROCEDURE PRINTCARD; FORWARD;                                           00400000 
INTEGER PROCEDURE FEELD(X);  VALUE X;  INTEGER X;  FORWARD ;            00400010 
ALPHA PROCEDURE NEED(T, C); VALUE T, C; ALPHA T, C; FORWARD;            00401000 
ALPHA PROCEDURE GETSPACE(S); VALUE S; ALPHA S; FORWARD;                 00402000 
PROCEDURE EQUIV(R); VALUE R; REAL R; FORWARD;                           00403000 
PROCEDURE EXECUTABLE; FORWARD;                                          00403100 
ALPHA PROCEDURE B2D(B); VALUE B; REAL B; FORWARD;                       00404000 
PROCEDURE DEBUGWORD (N); VALUE N; REAL N;      FORWARD;                 00405000 
PROCEDURE EMITL(N); VALUE N; REAL N; FORWARD;                           00406000 
PROCEDURE ADJUST;FORWARD;                                               00407000 
PROCEDURE DATIME;  FORWARD;                                             00407500 
PROCEDURE EMITB(A,C); VALUE A,C; REAL A; BOOLEAN C; FORWARD;            00408000 
PROCEDURE FIXB(N); VALUE N; REAL N; FORWARD;                            00408100 
PROCEDURE EMITO(N); VALUE N; REAL N; FORWARD;                           00409000 
PROCEDURE EMITOPDCLIT(N); VALUE N; REAL N; FORWARD;                     00410000 
PROCEDURE EMITDESCLIT(N); VALUE N; REAL N; FORWARD;                     00411000 
PROCEDURE EMITPAIR(L,OP); VALUE L,OP; INTEGER L,OP; FORWARD;            00412000 
PROCEDURE EMITN(N); VALUE N; REAL N; FORWARD;                           00413000 
PROCEDURE ARRAYDEC(I); VALUE I; REAL I; FORWARD;                        00414000 
INTEGER PROCEDURE ENTER(W, E); VALUE W, E; ALPHA W, E; FORWARD;         00415000 
REAL PROCEDURE PRGDESCBLDR(A,B,C,D); VALUE A,B,C,D; REAL A,B,C,D;       00416000 
               FORWARD;                                                 00417000 
PROCEDURE WRITEDATA(A,B,C); VALUE A,B; REAL A,B;                        00418000 
                   ARRAY C[0];      FORWARD;                            00419000 
PROCEDURE SCAN;      FORWARD;                                           00420000 
PROCEDURE SEGMENT(A,B,C,D); VALUE A,B,C;                                00421000 
         REAL A,B; BOOLEAN C; ARRAY D[0,0];    FORWARD;                 00422000 
STREAM PROCEDURE MOVESEQ(OLD,NEW);  BEGIN DI~OLD; SI~NEW; DS~WDS END ;  00422010 
PROCEDURE WRITAROW(N,ROW); VALUE N; INTEGER N; REAL ARRAY ROW[0] ;      00422100 
IF SINGLETOG THEN WRITE(LINE,N,ROW[*]) ELSE WRITE(RITE,N,ROW[*]) ;      00422110 
PROCEDURE WRITALIST(FMT,N,L1,L2,L3,L4,L5,L6,L7,L8);                     00422120 
VALUE N,L1,L2,L3,L4,L5,L6,L7,L8; INTEGER N;                             00422130  
REAL L1,L2,L3,L4,L5,L6,L7,L8; FORMAT FMT;                               00422140  
   BEGIN                                                                00422150  
   PRINTBUFF[1]~L1;                                                     00422160  
   L1~1 ;                                                               00422170  
   FOR L2~L2,L3,L4,L5,L6,L7,L8 DO PRINTBUFF[L1~L1+1]~L2 ;               00422180
   IF SINGLETOG THEN WRITE(LINE,FMT,FOR L1~1 THRU N DO PRINTBUFF[L1])   00422190 
   ELSE WRITE(RITE,FMT,FOR L1~1 THRU N DO PRINTBUFF[L1]) ;              00422200 
   END WRITALIST ;                                                      00422210  
STREAM PROCEDURE BLANKIT(A,N,P);  VALUE N,P;                            00422220  
BEGIN DI~A;  N(DS~8 LIT"        ");  P(DS~8 LIT"99999999") END ;        00422230
BOOLEAN STREAM PROCEDURE TSSMES(A,B);  VALUE B;                         00422235  
BEGIN SI~A;  SKIP B SB;  IF SB THEN ELSE BEGIN TALLY~1;  TSSMES~TALLY ; 00422240
DI~A;  SKIP B DB;  DS~SET END END OF TSSMES ;                           00422250
STREAM PROCEDURE TSSEDIT(X,P1,P2,P3,P,N);  VALUE P1,P2,P3,N ;           00422255  
BEGIN DI~P;DS~16LIT"TSS WARNING:    ";SI~X;SI~SI+2; DS~6CHR; DS~4LIT" ";00422260
P1(DS~48LIT"A TSS HOL OR QUOTED STRING MUST BE ON 1 LINE    ") ;        00422262 
P2(DS~48LIT"THIS CONSTRUCT IS ILLEGAL IN TSS FORTRAN        ") ;        00422264 
P3(DS~48LIT"THIS CONSTRUCT IS UNRESERVED IN TSS FORTRAN     ") ;        00422266 
DS~26LIT" ";  DS~8LIT"*";  DS~LIT" ";  SI~LOC N;  DS~3DEC END TSSEDIT ; 00422268
PROCEDURE TSSED(X,N);  VALUE X,N;  ALPHA X;  INTEGER N ;                00422270  
BEGIN IF NOT (LISTOG OR SEQERRORS) THEN PRINTCARD ; UNPRINTED~FALSE ;   00422275 
TSSEDIT(X,N=1,N=2,N=3,PRINTBUFF,WARNCOUNT~WARNCOUNT+1) ;                00422280 
WRITAROW(14,PRINTBUFF) END OF TSSED;                                    00422285  
PROCEDURE ERRMESS(N);  VALUE N; INTEGER N;                              00423000   
BEGIN                                                                   00424000          
                                                                        00425000
STREAM PROCEDURE PLACE(D,N,X,S,E,L);   VALUE N,E ;                      00426000          
BEGIN DI ~ D;  DS ~ 6 LIT "ERROR ";                                     00427000        
      SI ~ LOC N;  DS ~ 3 DEC;  DS ~ 5 LIT ":    ";                     00428000       
      SI ~ X;  SI ~ SI + 2;  DS ~ 6 CHR;  DS ~ 4 LIT " ";               00429000      
      SI~S;  DS~6 WDS;  DS~6 LIT" ";  SI~L;  DS~8 CHR;  DS~14 LIT" " ;  00430000    
      DS ~ 8 LIT "X";  DS ~ LIT " ";                                    00431000        
      SI ~ LOC E;  DS ~ 3 DEC;                                          00432000        
END PLACE;                                                              00433000          
STREAM PROCEDURE DCPLACE(D,N,X,S,M,P);  VALUE N,P;                      00433100          
    BEGIN DI~D;  DS~4LIT"ERR#";  SI~LOC N;  DS~3 DEC;  DS~3LIT" @ ";    00433200     
    SI~S; DS~8CHR; DS~2LIT": "; SI~X;  SI~SI+2; DS~6CHR; DS~54LIT" " ;  00433300   
    END OF DCPLACE ;                                                    00433400          
ERRORCT~ERRORCT+1;                                                      00433500          
IF NOT MSFL[N DIV 16] THEN                                              00434000          
    BEGIN                                                               00434020          
    MSFL[N DIV 16]~TRUE ;                                               00434030         
    CASE(N DIV 16)OF                                                    00434040          
BEGIN                                                                   00435000          
         FILL MESSAGE[0,*] WITH                                         00436000
"SYNTAX E","RROR    ","        ","        ","        ","        ", %000 00437000
"MISSING ","OPERATOR"," OR PUNC","TUATION ","        ","        ", %001 00438000
"CONFLICT","ING COMM","ON AND/O","R EQUIVA","LENCE AL","LOCATION", %002 00439000
"MISSING ","RIGHT PA","RENTHESI","S       ","        ","        ", %003 00440000
"ENTRY ST","MT ILLEG","AL IN MA","IN PGM O","R BLOCK ","DATA    ", %004 00441000
"MISSING ","END STAT","EMENT   ","        ","        ","        ", %005 00442000
"ARITHMET","IC EXPRE","SSION RE","QUIRED  ","        ","        ", %006 00443000
"LOGICAL ","EXPRESSI","ON REQUI","RED     ","        ","        ", %007 00444000
"TOO MANY"," LEFT PA","RENTHESE","S       ","        ","        ", %008 00445000
"TOO MANY"," RIGHT P","ARENTHES","ES      ","        ","        ", %009 00446000
"FORMAL P","ARAMETER"," ILLEGAL"," IN COMM","ON      ","        ", %010 00447000
"FORMAL P","ARAMETER"," ILLEGAL"," IN EQUI","VALENCE ","        ", %011 00448000
"THIS STA","TEMENT I","LLEGAL I","N BLOCK ","DATA SUB","PROGRAM ", %012 00449000
"INFO ARR","AY OVERF","LOW     ","        ","        ","        ", %013 00450000
"IMPROPER"," DO NEST","        ","        ","        ","        ", %014 00451000
"DO LABEL"," PREVIOU","SLY DEFI","NED     ","        ","        ", %015 00452000
0;                                                                      00453000
         FILL MESSAGE[1,*] WITH                                         00454000
"UNRECOGN","IZED STA","TEMENT T","YPE     ","        ","        ", %016 00455000
"ILLEGAL ","DO STATE","MENT    ","        ","        ","        ", %017 00456000
"FORMAT S","TATEMENT"," MUST HA","VE LABEL","        ","        ", %018 00457000
"UNDEFINE","D LABEL ","        ","        ","        ","        ", %019 00458000
"MULTIPLE"," DEFINIT","ION     ","        ","        ","        ", %020 00459000
"ILLEGAL ","IDENTIFI","ER CLASS"," IN THIS"," CONTEXT","        ", %021 00460000
"UNPAIRED"," QUOTES ","IN FORMA","T       ","        ","        ", %022 00461000
"NOT ENOU","GH SUBSC","RIPTS   ","        ","        ","        ", %023 00462000
"TOO MANY"," SUBSCRI","PTS     ","        ","        ","        ", %024 00463000
"FUNCTION"," OR SUBR","OUTINE P","REVIOUSL","Y DEFINE","D       ", %025 00464000
"FORMAL P","ARAMETER"," MULTIPL","Y DEFINE","D IN HEA","DING    ", %026 00465000
"ILLEGAL ","USE OF N","AMELIST ","        ","        ","        ", %027 00466000
"NUMBER O","F PARAME","TERS INC","ONSISTEN","T       ","        ", %028 00467000
"CANNOT B","RANCH TO"," FORMAT ","STATEMEN","T       ","        ", %029 00468000
"SUBROUTI","NE OR FU","NCTION N","OT DEFIN","ED IN PR","OGRAM   ", %030 00469000
"IDENTIFI","ER ALREA","DY GIVEN"," TYPE   ","        ","        ", %031 00470000
0;                                                                      00471000                                                         00472000 479000          
         FILL MESSAGE[2,*] WITH                                         00472000
"ILLEGAL ","FORMAT S","YNTAX   ","        ","        ","        ", %032 00473000
"INCORREC","T USE OF"," FILE   ","        ","        ","        ", %033 00474000
"INCONSIS","TENT USE"," OF IDEN","TIFIER  ","        ","        ", %034 00475000
"ARRAY ID","ENTIFIER"," EXPECTE","D       ","        ","        ", %035 00476000
"EXPRESSI","ON VALUE"," REQUIRE","D       ","        ","        ", %036 00477000
"ILLEGAL ","FILE CAR","D SYNTAX","        ","        ","        ", %037 00478000
"ILLEGAL ","CONTROL ","ELEMENT ","        ","        ","        ", %038 00479000
"DECLARAT","ION MUST"," PRECEDE"," FIRST R","EFERENCE","        ", %039 00480000
"INCONSIS","TENT USE"," OF LABE","L AS PAR","AMETER  ","        ", %040 00481000
"NO. OF P","ARAMS. D","ISAGREES"," WITH PR","EV. REFE","RENCE   ", %041 00482000
"ILLEGAL ","USE OF F","ORMAL PA","RAMETER ","        ","        ", %042 00483000
"ERROR IN"," HOLLERI","TH LITER","AL CHARA","CTER COU","NT      ", %043 00484000
"ILLEGAL ","ACTUAL P","ARAMETER","        ","        ","        ", %044 00485000
"TOO MANY"," SEGMENT","S IN SOU","RCE PROG","RAM     ","        ", %045 00486000
"TOO MANY"," PRT ASS","IGNMENTS"," IN SOUR","CE PROGR","AM      ", %046 00487000
"LAST BLO","CK DECLA","RATION H","AD LESS ","THAN 102","4 WORDS ", %047 00488000
0;                                                                      00489000
         FILL MESSAGE[3,*] WITH                                         00490000
"ILLEGAL ","I/O LIST"," ELEMENT","        ","        ","        ", %048 00491000
"LEFT SID","E MUST B","E SIMPLE"," OR SUBS","CRIPTED ","VARIABLE", %049 00492000
"VARIABLE"," EXPECTE","D       ","        ","        ","        ", %050 00493000
"ILLEGAL ","USE OF .","OR.     ","        ","        ","        ", %051 00494000
"ILLEGAL ","USE OF .","AND.    ","        ","        ","        ", %052 00495000
"ILLEGAL ","USE OF .","NOT.    ","        ","        ","        ", %053 00496000
"ILLEGAL ","USE OF R","ELATIONA","L OPERAT","OR      ","        ", %054 00497000
"ILLEGAL ","MIXED TY","PES     ","        ","        ","        ", %055 00498000
"ILLEGAL ","EXPRESSI","ON STRUC","TURE    ","        ","        ", %056 00499000
"ILLEGAL ","PARAMETE","R       ","        ","        ","        ", %057 00500000
"RECORD B","LOCK GRE","ATER THA","N 1023  ","        ","        ", %058 00501000
"TOO MANY"," OPTIONA","L FILES ","        ","        ","        ", %059 00502000
"FILE CAR","DS MUST ","PRECEDE ","SOURCE D","ECK     ","        ", %060 00503000
"BINARY W","RITE STA","TEMENT H","AS NO LI","ST      ","        ", %061 00504000
"UNDEFINE","D FORMAT"," NUMBER ","        ","        ","        ", %062 00505000
"ILLEGAL ","EXPONENT"," IN CONS","TANT    ","        ","        ", %063 00506000
0;                                                                      00507000
         FILL MESSAGE[4,*] WITH                                         00508000
"ILLEGAL ","CONSTANT"," IN DATA"," STATEME","NT      ","        ", %064 00509000
"MAIN PRO","GRAM MIS","SING    ","        ","        ","        ", %065 00510000
"PARAMETE","R MUST B","E ARRAY ","IDENTIFI","ER      ","        ", %066 00511000
"PARAMETE","R MUST B","E EXPRES","SION    ","        ","        ", %067 00512000
"PARAMETE","R MUST B","E LABEL ","        ","        ","        ", %068 00513000
"PARAMETE","R MUST B","E FUNCTI","ON IDENT","IFIER   ","        ", %069 00514000
"PARAMETE","R MUST B","E FUNCTI","ON OR SU","BROUTINE"," ID     ", %070 00515000
"PARAMETE","R MUST B","E SUBROU","TINE IDE","NTIFIER ","        ", %071 00516000
"PARAMETE","R MUST B","E ARRAY ","IDENTIFI","ER OR EX","PRESSION", %072 00517000
"ARITHMET","IC - LOG","ICAL CON","FLICT ON"," STORE  ","        ", %073 00518000
"ARRAYID ","MUST BE ","SUBSCRIP","TED IN T","HIS CONT","EXT     ", %074 00519000
"MORE THA","N ONE MA","IN PROGR","AM      ","        ","        ", %075 00520000
"ONLY COM","MON ELEM","ENTS PER","MITTED  ","        ","        ", %076 00521000
"TOO MANY"," FILES  ","        ","        ","        ","        ", %077 00522000
"FORMAT O","R NAMELI","ST TOO L","ONG     ","        ","        ", %078 00523000
"FORMAL P","ARAMETER"," MUST BE"," ARRAY I","DENTIFIE","R       ", %079 00524000
0;                                                                      00525000
         FILL MESSAGE[5,*] WITH                                         00526000
"FORMAL P","ARAMETER"," MUST BE"," SIMPLE ","VARIABLE","        ", %080 00527000
"FORMAL P","ARAMETER"," MUST BE"," FUNCTIO","N IDENTI","FIER    ", %081 00528000
"FORMAL P","ARAMETER"," MUST BE"," SUBROUT","INE IDEN","TIFIER  ", %082 00529000
"FORMAL P","ARAMETER"," MUST BE"," FUNCTIO","N OR SUB","ROUTINE ", %083 00530000
"DO OR IM","PLIED DO"," INDEX M","UST BE I","NTEGER O","R REAL  ", %084 00531000
"ILLEGAL ","COMPLEX ","CONSTANT","        ","        ","        ", %085 00532000
"ILLEGAL ","MIXED TY","PE STORE","        ","        ","        ", %086 00533000
"CONSTANT"," EXCEEDS"," HARDWAR","E LIMITS","        ","        ", %087 00534000
"PARAMETE","R TYPE C","ONFLICTS"," WITH PR","EVIOUS U","SE      ", %088 00535000
"COMPLEX ","EXPRESSI","ON ILLEG","AL IN IF"," STATEME","NT      ", %089 00536000
"COMPLEX ","EXPRESSI","ON ILLEG","AL IN RE","LATION  ","        ", %090 00537000
"TOO MANY"," FORMATS"," REFEREN","CED BUT ","NOT YET ","FOUND   ", %091 00538000
"VARIABLE"," ARRAY B","OUND MUS","T BE FOR","MAL VARI","ABLE    ", %092 00539000
"ARRAY BO","UND MUST"," HAVE IN","TEGER OR"," REAL TY","PE      ", %093 00540000
"COMMA OR"," RIGHT P","ARENTHES","IS EXPEC","TED     ","        ", %094 00541000
"ARRAY AL","READY GI","VEN BOUN","DS      ","        ","        ", %095 00542000
0;                                                                      00543000
         FILL MESSAGE[6,*] WITH                                         00544000
"ONLY FOR","MAL ARRA","YS MAY B","E GIVEN ","VARIABLE"," BOUNDS ", %096 00545000
"MISSING ","LEFT PAR","ENTHESIS"," IN IMPL","IED DO  ","        ", %097 00546000
"SUBSCRIP","T MUST B","E INTEGE","R OR REA","L       ","        ", %098 00547000
"ARRAY SI","ZE CANNO","T EXCEED"," 32767 W","ORDS    ","        ", %099 00548000
"COMMON O","R EQUIV ","BLOCK CA","NNOT EXC","EED 3276","7 WORDS ", %100 00549000
"THIS STA","TEMENT I","LLEGAL I","N LOGICA","L IF    ","        ", %101 00550000
"REAL OR ","INTEGER ","TYPE REQ","UIRED   ","        ","        ", %102 00551000
"ARRAY BO","UND INFO","RMATION ","REQUIRED","        ","        ", %103 00552000
"REPLACEM","ENT OPER","ATOR EXP","ECTED   ","        ","        ", %104 00553000
"IDENTIFI","ER EXPEC","TED     ","        ","        ","        ", %105 00554000
"LEFT PAR","ENTHESIS"," EXPECTE","D       ","        ","        ", %106 00555000
"ILLEGAL ","FORMAL P","ARAMETER","        ","        ","        ", %107 00556000
"RIGHT PA","RENTHESI","S EXPECT","ED      ","        ","        ", %108 00557000
"STATEMEN","T NUMBER"," EXPECTE","D       ","        ","        ", %109 00558000
"SLASH EX","PECTED  ","        ","        ","        ","        ", %110 00559000
"ENTRY ST","ATEMENT ","CANNOT B","EGIN PRO","GRAM UNI","T       ", %111 00560000
0;                                                                      00561000
         FILL MESSAGE[7,*] WITH                                         00562000
"ARRAY MU","ST BE DI","MENSIONE","D PRIOR ","TO EQUIV"," STMT   ", %112 00563000
"INTEGER ","CONSTANT"," EXPECTE","D       ","        ","        ", %113 00564000
"COMMA EX","PECTED  ","        ","        ","        ","        ", %114 00565000
"SLASH OR"," END OF ","STATEMEN","T EXPECT","ED      ","        ", %115 00566000
"FORMAT, ","ARRAY OR"," NAMELIS","T EXPECT","ED      ","        ", %116 00567000
"END OF S","TATEMENT"," EXPECTE","D       ","        ","        ", %117 00568000
"IO STATE","MENT WIT","H NAMELI","ST CANNO","T HAVE I","O LIST  ", %118 00569000
"COMMA OR"," END OF ","STATEMEN","T EXPECT","ED      ","        ", %119 00570000
"STRING T","OO LONG ","        ","        ","        ","        ", %120 00571000
"MISSING ","QUOTE AT"," END OF ","STRING  ","        ","        ", %121 00572000
"ILLEGAL ","ARRAY BO","UND     ","        ","        ","        ", %122 00573000
"TOO MANY"," HANGING"," BRANCHE","S       ","        ","        ", %123 00574000
"TOO MANY"," COMMON ","OR EQUIV","ALENCE E","LEMENTS ","        ", %124 00575000
"ASTERISK"," EXPECTE","D       ","        ","        ","        ", %125 00576000
"COMMA OR"," SLASH E","XPECTED ","        ","        ","        ", %126 00577000
"DATA SET"," TOO LAR","GE      ","        ","        ","        ", %127 00578000
0;                                                                      00579000
         FILL MESSAGE[8,*] WITH                                         00580000
"TOO MANY"," ENTRY S","TATEMENT","S IN THI","S SUBPRO","GRAM    ", %128 00581000
"DECIMAL ","WIDTH EX","CEEDS FI","ELD WIDT","H       ","        ", %129 00582000
"UNSPECIF","IED FIEL","D WIDTH ","        ","        ","        ", %130 00583000
"UNSPECIF","IED SCAL","E FACTOR","        ","        ","        ", %131 00584000
"ILLEGAL ","FORMAT C","HARACTER","        ","        ","        ", %132 00585000
"UNSPECIF","IED DECI","MAL FIEL","D       ","        ","        ", %133 00586000
"DECIMAL ","FIELD IL","LEGAL FO","R THIS S","PECIFIER","        ", %134 00587000
"ILLEGAL ","LABEL   ","        ","        ","        ","        ", %135 00588000
"UNDEFINE","D NAMELI","ST      ","        ","        ","        ", %136 00589000
"MULTIPLY"," DEFINED"," ACTION ","LABELS  ","        ","        ", %137 00590000
"TOO MANY"," NESTED ","DO STATE","MENTS   ","        ","        ", %138 00591000
"STMT FUN","CTION ID"," AND EXP","RESSION ","DISAGREE"," IN TYPE", %139 00592000
"ILLEGAL ","USE OF S","TATEMENT"," FUNCTIO","N       ","        ", %140 00593000
"UNRECOGN","IZED CON","STRUCT  ","        ","        ","        ", %141 00593001
"RETURN, ","STOP OR ","CALL EXI","T REQUIR","ED IN SU","BPROGRAM", %142 00593002
"FORMAT N","UMBER US","ED PREVI","OUSLY AS"," LABEL  ","        ", %143 00593003
0;                                                                      00594000
         FILL MESSAGE[9,*] WITH                                         00595000
"LABEL US","ED PREVI","OUSLY AS"," FORMAT ","NUMBER  ","        ", %144 00595001
"NON-STAN","DARD RET","URN REQU","IRES LAB","EL PARAM","ETERS   ", %145 00595002
"DOUBLE O","R COMPLE","X REQUIR","ES EVEN ","OFFSET  ","        ", %146 00595003
"FORMAL P","ARAMETER"," ILLEGAL"," IN DATA"," STATEME","NT      ", %147 00595004
"TOO MANY"," LOCAL V","ARIABLES"," IN SOUR","CE PROGR","AM      ", %148 00596000
"A $FREEF","ORM SOUR","CE LINE ","MUST HAV","E < 67 C","OLS     ", %149 00596001
"A HOL/ST","RING UND","ER $FREE","FORM MUS","T BE ON ","ONE LINE", %150 00596002
"THIS CON","STRUCT I","S ILLEGA","L IN TSS","FORTRAN ","        ", %151 00596003
"ILLEGAL ","FILE CAR","D PARAME","TER VALU","E       ","        ", %152 00596004
"RETURN I","N MAIN P","ROGRAM N","OT ALLOW","ED      ","        ", %153 00596005
"NON-POSI","TIVE SUB","SCRIPTS ","ARE ILLE","GAL     ","        ", %154 00596006
"NON-IDEN","TIFIER U","SED FOR ","NAME OF ","LIBRARY ","ROUTINE ", %155 00596007
"HYPHEN E","XPECTED ","        ","        ","        ","        ", %156 00596008
"SEQUENCE"," NUMBER ","EXPECTED","        ","        ","        ", %157 00596009
"TOO MANY"," RECURSI","VE CALLS"," ON LIBR","ARY ROUT","INE     ", %158 00596010
"ASTERISK"," NOT ALL","OWED ID ","READ STA","TEMENT  ","        ", %159 00596011
0;                                                                      00596500
         FILL MESSAGE[10,*] WITH                                        00596501
"ASTERISK"," ONLY AL","LOWED IN"," FREE FI","ELD OUTP","UT      ", %160 00596510
"TOO MANY"," *-ED LI","ST ELEME","NTS IN O","UTPUT   ","        ", %161 00596511
"HOL OR Q","UOTED ST","RING > 7"," CHARACT","ERS IN E","XPRESSN ", %162 00596512
"DECIMAL ","FIELD GR","EATER TH","AN FIELD"," WIDTH-5","        ", %163 00596513
"PLUS NOT"," ALLOWED"," IN THIS"," FORMAT ","PHRASE  ","        ", %164 00596514
"K NOT AL","LOWED IN"," THIS FO","RMAT PHR","ASE     ","        ", %165 00596515
"$ NOT AL","LOWED IN"," THIS FO","RMAT PHR","ASE     ","        ", %166 00596516
"INTRNSCS","-NAMD FU","NCT MUST"," HAV PRE","V EXTRNL"," REFERNC", %167 00596517
"DATA STM","T COMMON"," ELEM MU","ST BE IN"," BLK DAT","A SUBPRG", %168 00596518
"VARIABLE"," CANNOT ","BE A FOR","MAL PARA","METER OR"," IN CMMN", %169 00596519
"CURRENT ","SUBPROGR","AM ID EX","PECTED  ","        ","        ", %170 00596520
"SUBPROGR","AM, EXTE","RNAL, OR"," ARRAY I","D EXPECT","ED      ", %171 00596521
"REPEAT, ","WIDTH, A","ND DECIM","AL PARTS"," MUST BE"," < 4091 ", %172 00596522
"REPEAT P","ART MUST"," BE EMPT","Y OR > 0"," AND < 4","091     ", %173 00596523
"IN SUBPR","GM:VARBL"," IS USED"," PRIOR T","O USE IN"," DATSTMT", %174 00596524
"SYNTATIC","AL TOKEN"," CONTAIN","S TOO MA","NY CHARA","CTERS.  ", %175 00596525
0;                                                                      00596526
         FILL MESSAGE[11,*] WITH                                        00596527
"INTEGER ","VALUE OF"," 8 EXPEC","TED     ","        ","        ", %176 00596528
"INTEGER ","VALUE OF"," 4 EXPEC","TED     ","        ","        ", %177 00596529
"INTEGER ","VALUE OF"," 4 OR 8 ","EXPECTED","        ","        ", %178 00596530
"AN ALPHA","BETIC LE","TTER (A,","B,C,...,","Z) IS RE","QUIRED  ", %179 00596531
"SECOND R","ANGE LET","TER MUST"," BE GREA","TER THAN"," FIRST  ", %180 00596532
"IMPLICIT"," MUST BE"," FIRST S","TATEMENT"," IN PROG","RAM UNIT", %181 00596533
"REAL/INT","EGER/LOG","ICAL/COM","PLEX/DOU","BLEPRECI","SION REQ", %182 00596534
 "ILLEGAL ","USE OF A","STERISK ","FOR RUN-","TIME EDI","TING    ",%111-00596535
 "NO PROGR","AM UNIT ","FOR THIS"," END STA","TEMENT  ","        ",%112-00596536
0;                                                                      00596599                                                                        00596538
END FILL STATEMENTS;                                                    00597000
    END ;                                                               00597950
IF DCINPUT THEN                                                         00598000
    BEGIN                                                               00598020
    DCPLACE(ERRORBUFF,N,XTA,LASTSEQ,MESSAGE[N DIV 16,6|(N MOD 16)],     00598040
            IF TSSMESTOG THEN TSSMES(TSSMESA[(N-1)DIV 48],              00598050
            ENTIER((N-1) MOD 48)) ELSE FALSE) ;                         00598060
    WRITE(REMOTE,9,ERRORBUFF[*]) ;                                      00598080
    END ;                                                               00598100
IF LISTOG OR NOT DCINPUT THEN                                           00598120
    BEGIN                                                               00598140
    PLACE(ERRORBUFF,N,XTA,MESSAGE[N DIV 16,6|(N MOD 16)],ERRORCT,       00598160
          LASTERR) ;                                                    00598180
    WRITAROW(14,ERRORBUFF) ;                                            00598200
    END;                                                                00599000
MOVESEQ(LASTERR,LINKLIST) ;                                             00599500
END ERRMESS;                                                            00600000
PROCEDURE FLAGROUTINE(NAME1,NAME2,ENTERING) ;                           00600010
VALUE NAME1,NAME2,ENTERING ;                                            00600020
ALPHA NAME1,NAME2;                                                      00600030
BOOLEAN ENTERING;                                                       00600040
IF ENTERING THEN WRITALIST(FLAGROUTINEFORMAT,7,"ENTERI","NG",NAME1,     00600050
NAME2,"+",FEELD(FLAGROUTINECOUNTER~FLAGROUTINECOUNTER+1),               00600060
FLAGROUTINECOUNTER,0) ELSE                                              00600065
   BEGIN                                                                00600070
   WRITALIST(FLAGROUTINEFORMAT,7,"LEAVIN","G ",NAME1,NAME2,"-",         00600080
   FEELD(FLAGROUTINECOUNTER),FLAGROUTINECOUNTER,0) ;                    00600090
   FLAGROUTINECOUNTER~FLAGROUTINECOUNTER-1 ;                            00600100
   END ;                                                                00600110
%END OF FLAGROUTINE                                                     00600120
PROCEDURE FLAG(N); VALUE N; INTEGER N;                                  00601000
IF NOT ERRORTOG OR DEBUGTOG THEN                                        00602000
BEGIN                                                                   00603000
   IF NOT (LISTOG OR SEQERRORS OR DCINPUT) THEN PRINTCARD ;             00604000
   ERRMESS(N);                                                          00606000
   IF ERRORCT } LIMIT THEN GO TO POSTWRAPUP;                            00606500
END;                                                                    00607000
PROCEDURE FLOG(N); VALUE N; INTEGER N;                                  00608000
IF NOT ERRORTOG OR DEBUGTOG THEN                                        00609000
   BEGIN ERRORTOG ~ TRUE;                                               00610000
   IF NOT (LISTOG OR SEQERRORS OR DCINPUT) THEN PRINTCARD;              00611000
   ERRMESS(N);                                                          00613000
   IF ERRORCT } LIMIT THEN GO TO POSTWRAPUP;                            00613500
   END;                                                                 00614000
PROCEDURE FATAL(N); VALUE N; INTEGER N;                                 00615000
BEGIN                                                                   00616000
         FORMAT FATALERR("XXXXXXXX", X18,                               00617000
         "PREVIOUS ERROR IS FATAL - REMAINDER OF SUBPROGRAM IGNORED",   00618000
         X17, "XXXXXXXX");                                              00619000
         ERRORTOG ~ FALSE;                                              00620000
         FLAG(N);                                                       00621000
         WRITALIST(FATALERR,0,0,0,0,0,0,0,0,0) ;                        00622000
         WHILE NEXT ! 11 DO           % LOOK FOR END STMT               00623000
    BEGIN                                                               00624000
         WHILE NEXT ! SEMI DO SCAN;                                     00625000
         EOSTOG ~ TRUE;                                                 00626000
         SCAN;                                                          00627000
    END;                                                                00628000
         SEGMENT((ADR+4) DIV 4, NSEG, FALSE, EDOC);                     00629000
         SCAN;                                                          00630000
END FATAL;                                                              00631000
REAL STREAM PROCEDURE D2B(BCL); BEGIN SI~BCL;  DI~LOC D2B;  DS~8OCT END;00631100
REAL PROCEDURE GET(I);  VALUE I;  INTEGER I ;                           00632000
    BEGIN                                                               00633000
         GET ~ INFO[(I~I).IR,I.IC];                                     00634000
    END GET;                                                            00635000
PROCEDURE PUT(I,VLU); VALUE I,VLU; INTEGER I; REAL VLU;                 00636000
    BEGIN                                                               00637000
         INFO[(I~I).IR,I.IC] ~ VLU;                                     00638000
    END PUT;                                                            00639000
PROCEDURE GETALL(I,INFA,INFB,INFC);                                     00640000
VALUE I;  INTEGER I;  REAL INFA,INFB,INFC;                              00641000
    BEGIN                                                               00642000
         INFA ~ INFO[(I~I).IR,I.IC] ;                                   00643000
         INFB ~ INFO[(I~I+1).IR,I.IC];                                  00644000
         INFC ~ INFO[(I~I+1).IR,I.IC];                                  00645000
    END;                                                                00646000
PROCEDURE PUTC(I,V); VALUE I,V; INTEGER I; REAL V;                      00646100
IF I~I>SUPERMAXCOM THEN FATAL(124) ELSE COM[I.IR,I.IC]~V;               00646200
REAL PROCEDURE GETC(I);  VALUE I;  INTEGER I ;                          00646300
GETC~COM[(I~I).IR,I.IC];                                                00646400
PROCEDURE BAPC(V);  VALUE V;  REAL V;                                   00646500
IF NEXTCOM~NEXTCOM+1 > SUPERMAXCOM THEN FATAL(124)                      00646600
ELSE COM[NEXTCOM.IR,NEXTCOM.IC]~V ;                                     00646700
STREAM PROCEDURE MOVEW(F,T,D,M); VALUE D,M;                             00647000
    BEGIN SI ~ F; DI ~ T; D(DS ~32 WDS; DS ~ 32 WDS); DS ~ M WDS; END;  00648000
PROCEDURE CALLEQUIV(I,B,G); VALUE I,B,G; INTEGER I; REAL G; BOOLEAN B ; 00649000
BEGIN REAL A,T,R,INFA,INFC;                                             00650000
      REAL LAST,D; LABEL L;                                             00650100
PROCEDURE CORRECTINFO(R,A); VALUE R,A; INTEGER R,A;                     00651000
COMMENT  THIS PROCEDURE CORRECTS THE INFO TABLE FOR COMMON AND          00651010
           EQUIVALENCE ELEMENTS.                                        00651020
         IF ITEMS ARE IN COMMON THE INFA[EQ] BIT IS SET                 00651030
           THIS BIT IS USED TO TELL DATA STATEMENTS THAT THIS IS A      00651040
           COMMON ELEMENT AND IF NOT IN BLOCK DATA SUBPROGRAM EMIT      00651050
           SYNTAX ERROR 168.                                            00651060
         THE INFA[CE] BIT IS SET TO TELL THAT IF THE CLASS IS VARID     00651070
           EMIT CODE AS IF THIS ITEM WERE ARRAYID BUT DO NOT            00651080
           ALLOW SUBSCRIPTING;                                          00651090
BEGIN                                                                   00652000
   REAL T,I,LAST,L,REL,TWODBIT,INFA,INFB,INFC;                          00653000
   REAL CEBIT;                                                          00654000
   DEFINE LB = LOWERBOUND#;                                             00655000
   TWODBIT ~ REAL(LENGTH > 1023);                                       00656000
   CEBIT ~ REAL(LENGTH > 1);                                            00657000
   T ~ R;                                                               00658000
   DO                                                                   00659000
   BEGIN                                                                00660000
      LAST~GETC(T).LASTC-1 ;                                            00661000
      FOR I ~ T+2 STEP 1 UNTIL LAST DO                                  00662000
      BEGIN                                                             00663000
         IF GETC(I).CLASS = ENDCOM THEN I~GETC(I).LINK ;                00664000
         INFA~GET(L~GETC(I).LINK);  INFC~GET(L+2) ;                     00665000
         IF INFC    > 0 AND LB ! 0 THEN                                 00666000
         BEGIN                                                          00667000
            IF BOOLEAN(INFA.ADJ) THEN                                   00668000
               REL ~ -INFC.BASE ELSE REL~INFC.BASE;                     00669000
            PUT(L+2,-(INFC&(REL-LB)[TOBASE]));                          00670000
         END;                                                           00671000
         PUT(L,INFA&TWODBIT[TOADJ]&CEBIT[TOCE]&A[TOEQ]);                00672000
      END;                                                              00673000
   END UNTIL T~GETC(T).ADDR=R ;                                         00674000
END CORRECTINFO;                                                        00675000
   LABEL XIT;                                                           00676000
IF DEBUGTOG THEN FLAGROUTINE(" CALLE","QUIV  ",TRUE );                  00676010
COMMENT  THIS PROCEDURE MAKES THE DETERMINATION IF THIS GROUP           00676100
           IS EQUIVALENCE OR COMMON IF BOTH TREATED AS COMMON;          00676110
   T ~ I;                                                               00677000
      GROUPPRT ~ LENGTH ~ A ~ 0;                                        00678000
      LOWERBOUND ~ 32000;                                               00679000
      DO BEGIN IF GETC(T).CE=1 THEN                                     00680000
      BEGIN IF GROUPPRT ! 0 THEN                                        00681000
         BEGIN XTA~G;                                                   00682000
            FLAG(2);                                                    00683000
         END;                                                           00684000
         GROUPPRT~GET(A~GETC(T+1)).ADDR;                                00685000
      END;                                                              00686000
      IF T > R THEN  R ~ T;                                             00687000
      END UNTIL T~GETC(T).ADDR=I ;                                      00688000
      IF GROUPPRT = 0 THEN                                              00689000
         IF B THEN BEGIN BUMPPRT;GROUPPRT~PRTS END ELSE  %OWN           00689100
         BEGIN BUMPLOCALS; GROUPPRT~LOCALS + 1536 END;                  00690000
    T ~ R;                                                              00691000
    SWARYCT ~0;                                                         00691500
    SSNM[6]~LOCALS  ;   SSNM[7]~PARMS    ;   SSNM[8]~PRTS    ;          00691510
    SSNM[9]~LSTS    ;  SSNM[10]~LSTA     ;  SSNM[11]~TV      ;          00691520
   SSNM[12]~SAVESUBS;  SSNM[13]~NAMEIND  ;  SSNM[14]~LSTI    ;          00691530
   SSNM[15]~FX1     ;  SSNM[16]~FX2      ;  SSNM[17]~FX3     ;          00691540
   SSNM[18]~NX1     ;                                                   00691550
    SEENADOUB~FALSE;%                                                   00691800
    DO IF GETC(T+1) ! 0 THEN BEGIN EQUIV(T); T~R; END                   00691900
        ELSE T~GETC(T).ADDR UNTIL T = R;                                00691950
    IF GETC(T) > 0 THEN EQUIV(T);                                       00692000
    LOCALS~SSNM[6];  PARMS~SSNM[7];  PRTS~SSNM[8];  LSTS~SSNM[9] ;      00692010
    LSTA~SSNM[10];  TV~SSNM[11];  SAVESUBS~SSNM[12];  NAMEIND~SSNM[13] ;00692020
    LSTI~SSNM[14];  FX1~SSNM[15];  FX2~SSNM[16];  FX3~SSNM[17];         00692030
    NX1~SSNM[18] ;                                                      00692040
    LENGTH ~ LENGTH - LOWERBOUND;                                       00693000
    IF SEENADOUB THEN     LENGTH~LENGTH+LENGTH.[47:1];% EVEN UP LENGTH  00693500
    SEENADOUB~FALSE;                                                    00693600
    IF A = 0 THEN                                                       00694000
    BEGIN COMMENT THIS IS AN EQUIVALENCE GROUP;                         00694100
    IF SWARYCT } 1 AND LENGTH = 1 THEN LENGTH ~ 2;                      00694150
       IF LENGTH > 1 THEN                                               00694200
       BEGIN                                                            00694300
          A ~ ENTER(-0 & ARRAYID[TOCLASS] & GROUPPRT[TOADDR],           00695000
             EQVID ~ EQVID+1);                                          00696000
          PUT(A+2,0 & LENGTH[TOSIZE]);                                  00696100
       END;                                                             00696200
       CORRECTINFO(R,0);                                                00697100
       GO TO XIT;                                                       00697200
    END;                                                                00697300
    COMMENT THIS IS A COMMON BLOCK;                                     00697400
    IF T ~ (INFC ~ GET(A+2)).SIZE ! 0 THEN                              00700000
    IF T { 1023 AND LENGTH > 1023 THEN                                  00701000
       BEGIN XTA ~ GET(A+1); FLAG(47) END;                              00702000
    IF T < LENGTH THEN PUT(A+2, INFC&LENGTH[TOSIZE]) ELSE LENGTH ~ T;   00702100
    IF LENGTH = 1 THEN LENGTH ~ 2;                                      00703000
    CORRECTINFO(R,1);                                                   00704000
    XIT:                                                                00705000
    IF LENGTH > 32767 THEN BEGIN XTA ~ GET(A+1); FLAG(100) END;         00705100
IF DEBUGTOG THEN FLAGROUTINE(" CALLE","QUIV  ",FALSE) ;                 00705110
END CALLEQUIV;                                                          00706000
STREAM PROCEDURE STOSEQ(XR,SEQ,ID);  VALUE ID;                          00706010
BEGIN LOCAL T;  LABEL L1,L2 ;                                           00706015
      SI ~ LOC ID; DI ~ XR; DS ~ 7LIT"0"; DS ~ CHR; SI ~ SI+1;          00706020
      IF SC } "0" THEN                                                  00706025
      BEGIN SI~SI+4; DI~DI-2;                                           00706030
            5(IF SC= " " THEN SI~SI-1                                   00706035
              ELSE BEGIN DS~CHR; SI~SI-2; DI~DI-2; END);                00706040
      END ELSE                                                          00706045
      BEGIN DI~DI-6;                                                    00706050
            6(IF SC=" " THEN BEGIN TALLY~TALLY+1; SI~SI+1 END           00706055
              ELSE DS~CHR);                                             00706060
            T~TALLY;                                                    00706065
      END;                                                              00706070
      DI~XR; DI~DI+8; SI~SEQ;                                           00706075
      8(IF SC=" " THEN SI~SI+1 ELSE JUMP OUT TO L1);  DS~8LIT"BLANKSEQ";00706080
      GO L2;  L1:   SI~SEQ;  DS~WDS;  L2:                               00706085
      DI~DI+4; SI~LOC T; SI~SI+7; DS~CHR;                               00706090
END;                                                                    00706095
PROCEDURE ENTERX(IDENT,ADINFO); VALUE IDENT, ADINFO;                    00706120
REAL IDENT,ADINFO;                                                      00706150
BEGIN REAL R,S;                                                         00706200
      IF ADINFO.CLASS>LABELID THEN                                      00706220
         BEGIN                                                          00706240
         XR[2]~ADINFO;  STOSEQ(XR,LINKLIST,IDENT);                      00706260
         IF ADINFO.CLASS=FUNID THEN XR[2].[26:1]~S~1 ;                  00706280
         WRITE(XREFG,3,XR[*]);  XGLOBALS~TRUE;                          00706300
         END ;                                                          00706320
      IF R~XRI MOD XRBUFFDIV3=0 THEN                                    00706340
         IF XRI!0 THEN WRITE(XREFF,XRBUFF,XRRY[*]) ;                    00706350
      XRRY[(R~R+R+R)+2]~ADINFO&S[26:47:1] ;                             00706360
      STOSEQ(XRRY[R],LINKLIST,IDENT) ;                                  00706380
      IF XRI~XRI+1=1 THEN BEGIN XR[3]~IDENT;  XR[4]~XRRY[2] END;        00706450
END ENTERX;                                                             00706500
    STREAM PROCEDURE TRANSFER(W2,B,K);  VALUE K;                        00706525
         BEGIN DI~W2; SI~B; SI~SI+8; K(DS~WDS; SI~SI+16) END ;          00706530
BOOLEAN STREAM PROCEDURE CMPA(F,S);                                     00706560
BEGIN SI~F; DI ~ S; IF 8 SC { DC THEN TALLY ~ 1; CMPA~TALLY; END;       00706570
BOOLEAN PROCEDURE CMP(A,B);  ARRAY A,B[0];                              00706600
BEGIN                                                                   00706610
CMP ~ IF A[0] < B[0] THEN TRUE ELSE IF A[0] = B[0] THEN                 00706640
      IF A[2].[26:4] < B[2].[26:4] THEN TRUE ELSE                       00706650
      IF A[2].[26:4] = B[2].[26:4] THEN CMPA(A[1],B[1]) ELSE FALSE      00706660
      ELSE FALSE;                                                       00706670
END;                                                                    00706680
PROCEDURE HV(V); ARRAY V[0];                                            00706700
FILL V[*] WITH OCT777777777777777,OCT777777777777777,OCT777777777777777;00706720
BOOLEAN PROCEDURE INP(XR);  ARRAY XR[0];                                00706730
BEGIN LABEL EOF;  REAL R ;                                              00706733
IF EODS THEN READ(XREFG,3,XR[*])[EOF] ELSE                              00706735
IF IT ~ IT+1 > XRI THEN                                                 00706750
     BEGIN EOF: INP~TRUE; IT~XRI~0; END                                 00706760
ELSE BEGIN                                                              00706770
    IF R~(IT-1) MOD XRBUFFDIV3=0 THEN READ(XREFF,XRBUFF,XRRY[*]) ;      00706780
    XR[0]~XRRY[R~R+R+R];  XR[2]~XRRY[R+2];  TRANSFER(XR[1],XRRY[R],1) ; 00706800
    END ;                                                               00706810
END OF INP ;                                                            00706820
PROCEDURE VARIABLEDIMS(A,C); VALUE A, C; REAL A, C;                     00707000
BEGIN                                                                   00708000
   REAL NSUBS, BDLINK, BOUND, I;                                        00709000
   LABEL XIT;                                                           00710000
IF DEBUGTOG THEN FLAGROUTINE("VARIAB","LEDIMS",TRUE);                   00710010
   IF NSUBS ~ C.NEXTRA = 1 AND A.SUBCLASS < DOUBTYPE THEN GO TO XIT;    00711000
   BDLINK ~ C.ADINFO;                                                   00712000
   FOR I ~ 1 STEP 1 UNTIL NSUBS DO                                      00713000
   BEGIN                                                                00714000
      IF BOUND ~ EXTRAINFO[BDLINK.IR,BDLINK.IC] < 0 THEN                00715000
         EMITOPDCLIT(BOUND) ELSE EMITNUM(BOUND);                        00716000
      BDLINK ~ BDLINK -1;                                               00717000
      IF I > 1 THEN EMITO(MUL);                                         00718000
   END;                                                                 00719000
   IF A.SUBCLASS } DOUBTYPE THEN EMITPAIR(2, MUL);                      00720000
   EMITPAIR(   C.SIZE,STD);                                             00721000
   XIT:                                                                 00722000
IF DEBUGTOG THEN FLAGROUTINE("VARIAB","LEDIMS",FALSE);                  00722010
END VARIABLEDIMS;                                                       00723000
PROCEDURE EMITD(R,OP); VALUE R,OP; REAL R,OP; FORWARD;                  00723100
STREAM PROCEDURE SETPNT(W1,W2,PNT,CL,SUBC,STAR,POS,F,S,Q) ;             00723140
VALUE CL,SUBC,STAR,POS,F,S,Q ;                                          00723150
BEGIN F(SI~W1; SI~SI+2; DI~PNT ;                                        00723160
      IF SC}"0" THEN                                                    00723170
      BEGIN DS~5CHR; DS~LIT" "; DI~DI-6; DS~5FILL ;                     00723180
      END ELSE BEGIN DS~6LIT" "; DI~PNT; DS~Q CHR END);                 00723200
     S(DI~PNT; DI~DI+6; DS~LIT" ";                                      00723210
    SI ~ LOC SUBC; SI ~ SI+2; DS ~ 6 CHR; DS ~ LIT " ";                 00723230
      SI~LOC CL; SI~SI+2; DS~6CHR; DS~LIT" ");                          00723240
     DI~PNT; DI~DI+21;                                                  00723250
      POS(DI~DI+11);                                                    00723255
    SI ~ LOC STAR; SI ~ SI+7; DS ~ CHR;                                 00723265
    SI ~ W2;  DS~8CHR ;                                                 00723280
    SI ~ LOC STAR; SI ~ SI+7; DS ~ CHR;                                 00723295
END OF SETPNT;                                                          00723325
PROCEDURE PT(EOF,REC); VALUE EOF; BOOLEAN EOF; ARRAY REC[0];            00723450
BEGIN LABEL L6;  REAL L;                                                00723470
   IF EOF THEN WRITE(LINE,15,PRINTBUFF[*])                              00723520
   ELSE                                                                 00723595
    IF BOOLEAN(L~REAL(REC[0]~REC[0]&REC[2] [1:26:1]=XTA)) THEN          00723610
         BEGIN                                                          00723620
         IF IT~IT+1=9 THEN                                              00723630
              BEGIN LASTLINE~FALSE; WRITE(LINE,15,PRINTBUFF[*]) ;       00723640
L6:           BLANKIT(PRINTBUFF,15,IT~0) ;                              00723650
              END;                                                      00723660
         SETPNT(REC[0],REC[1],PRINTBUFF,KLASS[REC[2].CLASS],TYPES[REC[2]00723670
                .SUBCLASS],IF BOOLEAN(REC[2]) THEN "*" ELSE " ",IT,L-1, 00723680
                LASTLINE,6-REC[2].[27:3]) ;                             00723690
              END                                                       00723700
         ELSE BEGIN                                                     00723710
              LASTLINE~TRUE;  WRITE(RITE,15,PRINTBUFF[*]);  XTA~REC[0] ;00723720
              GO L6 ;                                                   00723730
              END ;                                                     00723740
END OF PT ;                                                             00723800                                                                        01868000
PROCEDURE CHECKINFO;                                                    00724000
BEGIN REAL I, T, A;                                                     00725000
   REAL LASTF;                                                          00725100
   REAL INFB,INFC;                                                      00726000
   LABEL NXT; ALPHA N;                                                  00727000
   FORMAT INFOF( 3(A6, X2),                                             00728000
         " ADDRESS = ", A2, A4,                                         00729000
         ", LENGTH = ", I5,                                             00730000
         ", OFFSET = ", I5),                                            00731000
      INFOT( / "LOCAL IDENTIFIERS:"),                                   00732000
      LABF(A6,X10,"LABEL    REL-ADR = ",I6,", SEGMNT = ",I5);           00733000
   IF PRTOG THEN                                                        00734000
   WRITALIST(INFOT,0,0,0,0,0,0,0,0,0) ;                                 00735000
   IF I ~ SEARCH("ERR   ") ! 0 THEN                                     00736000
      IF GET(I).CLASS = UNKNOWN THEN PUT(I+1, "......");                00737000
   IF I ~ SEARCH("END   ") ! 0 THEN                                     00738000
      IF GET(I).CLASS = UNKNOWN THEN PUT(I+1, "......");                00739000
   IF NOT DCINPUT THEN IF I~SEARCH("ZIP   ") ! 0 THEN                   00739100
      IF GET(I).CLASS=UNKNOWN THEN PUT(I+1,"......") ;                  00739200
   FOR I ~ 0 STEP 1 UNTIL NEXTCOM DO                                    00740000
   IF GETC(I).CLASS=HEADER THEN                                         00741000
                                                                        00742000
   IF GETC(I).CE=1 THEN                                                 00743000
   PUT((T~GETC(I+1).LINK+2),GET(T)&0[TOADINFO]) ;                       00744000
                                                                        00745000
   T ~ 2; WHILE T < NEXTINFO DO                                         00746000
   BEGIN                                                                00747000
      GETALL(T,A,INFB,INFC);                                            00748000
      IF I ~ A.CLASS > FILEID THEN GO TO NXT;                           00749000
      IF N ~ INFB    = "......" THEN GO TO NXT;                         00750000
      XTA ~ N;                                                          00751000
      IF I = LABELID THEN                                               00752000
      BEGIN                                                             00753000
         IF A > 0 THEN FLAG(19) ELSE                                    00754000
         IF PRTOG THEN WRITALIST(LABF,3,N,A.ADDR DIV 4,A.SEGNO,0,0,0,0, 00755000
         0) ;                                                           00755010
         GO TO NXT;                                                     00756000
      END;                                                              00757000
      IF I = FORMATID THEN                                              00758000
         IF A > 0 THEN BEGIN FLAG(62); GO TO NXT END ;                  00759000
      IF I = NAMELIST THEN                                              00760000
      IF A > 0 THEN BEGIN FLAG(136); GO TO NXT END;                     00761000
      IF I = ARRAYID THEN                                               00762000
         IF BOOLEAN(A.CE) THEN BEGIN IF A>0 THEN T~GETSPACE(T) END      00763000
         ELSE IF A<0 THEN                                               00764000
         IF BOOLEAN(A.FORMAL) THEN                                      00764020
         BEGIN IF SPLINK > 1 AND ELX > 1 THEN                           00764040
            BEGIN % THIS IS A FORMAL PARAMETER FOR A SUBROUTINE OR A    00764060
                  % FUNCTION THAT HAS ONE OR MORE ENTRY STATEMENT. THIS 00764070
                  % PARAMETER WILL BE INITIALIZED TO AN ARRAY DESCRIPTOR00764080
                  % TO 0 SO THAT IF THE PARAMETERS ARE NOT SET UP BY THE00764090
                  % CALL ANY REFERENCE TO THEM WILL CAUSE AN INVALID    00764100
                  % ADDRESS                                             00764110
              IF LASTF = 0 THEN % FIRST TIME THRU                       00764150
              BEGIN LASTF ~ A.ADDR;                                     00764200
                    EMITDESCLIT(2); EMITL(1);                           00764220
                    EMITD(50,DIA); EMITD(10,DIB); EMITD(10,TRB);        00764240
              END ELSE EMITPAIR(LASTF,LOD);                             00764260
              EMITPAIR(A.ADDR,SND);                                     00764280
            END                                                         00764300
        END                                                             00764320
        ELSE ARRAYDEC(T);                                               00765000
     IF PRTOG THEN                                                      00766000
        WRITALIST(INFOF,7,INFB,                                         00767000
        IF BOOLEAN(A.TYPEFIXED) THEN TYPES[A.SUBCLASS] ELSE "      ",   00768000
        KLASS[A.CLASS],                                                 00769000
        IF A.ADDR < 1024 AND A < 0 THEN "R+" ELSE "  ",                 00770000
        IF A < 0 THEN B2D(A.[26:10]) ELSE "NULL",                       00771000
        INFC.SIZE,                                                      00772000
        INFC.BASE,0);                                                   00773000
     IF BOOLEAN(A.CE) THEN IF A.SUBCLASS } DOUBTYPE THEN                00773100
        IF BOOLEAN(INFC.BASE) THEN FLAG(146);                           00773200
     NXT:                                                               00774000
        T ~ T+3;                                                        00775000
  END;                                                                  00776000
END CHECKINFO;                                                          00777000
PROCEDURE SEGMENTSTART;                                                 00778000
BEGIN                                                                   00779000
   NSEG ~ NXAVIL ~ NXAVIL + 1;                                          00780000
   IF LISTOG THEN WRITALIST(SEGSTRT,1,NSEG,0,0,0,0,0,0,0) ;             00781000
   DEBUGADR~ADR~-1;                                                     00782000
   IF NOT SEGOVFLAG THEN                                                00783000
   BEGIN                                                                00784000
      DATAPRT~DATASTRT~DATALINK~DATASKP~                                00784100
      LABELMOM ~ BRANCHX ~ FUNVAR ~                                     00785000
      DT ~ SPLINK ~ NEXTCOM ~ ELX ~ 0;                                  00786000
      NEXTSS ~ 1022;                                                    00787000
      INITIALSEGNO ~ NSEG;                                              00788000
      FOR I ~ 0 STEP 1 UNTIL LBRANCH DO BRANCHES[I] ~ I+1;              00789000
   FOR I~0 STEP 1 UNTIL SHX DO STACKHEAD[I] ~ 0;                        00790000
      NEXTINFO ~ LOCALS ~ 2;                                            00791000
      F2TOG ~ FALSE; RETURNFOUND ~ FALSE;                               00792000
   END;                                                                 00793000
   ENDSEGTOG ~ FALSE;                                                   00794000
   IF SEGSW THEN LINESEG[NOLIN~0,0]~0 & D2B(LASTSEQ)[10:20:28] ;        00794400
END SEGMENTSTART;                                                       00795000
PROCEDURE FIXPARAMS(I); VALUE I; INTEGER I;                             00796000
BEGIN                                                                   00797000
   REAL FMINUS, NPARMS, ELINK, LABX;                                    00798000
   REAL PLINKX, PLINK;                                                  00799000
   REAL PTYPEX, PTYPE;                                                  00800000
   REAL CL, INF;                                                        00801000
   LABEL ARRY, LOAD, INDX;                                              00802000
   REAL EWORD;                                                          00803000
IF DEBUGTOG THEN FLAGROUTINE("  FIXP","ARMS  ",TRUE);                   00803010
   EWORD ~ ENTRYLINK[I];                                                00804000
   ELINK ~ EWORD.LINK;                                                  00805000
   IF LABX ~ EWORD.CLASS > 0 THEN                                       00806000
         BEGIN                                                          00807000
         EMITO(MKS);                                                    00808000
         EMITDESCLIT(LABELMOM);                                         00809000
         EMITL(LABX);                                                   00810000
         EMITL(1); EMITL(1); EMITL(0);                                  00811000
         EMITOPDCLIT(BLKCNTRLINT);                                      00812000
         EMITL(1); EMITPAIR(FPLUS2,STD);%   F+2~TRUE FOR BLKXIT CALL    00812400
         END;                                                      %106-00813000
    FMINUS ~ 1920;                                                      00814000
    NPARMS ~ (J~GET(ELINK+2)).NEXTRA;                                   00815000
     IF NPARMS > 0 THEN                                            %106-00816000
    BEGIN                                                               00817000
       PLINKX ~ EWORD.ADDR-NPARMS+1;                                    00818000
       PTYPEX ~ J.ADINFO + NPARMS-1;                                    00819000
       FOR J ~ 1 STEP 1 UNTIL NPARMS DO                                 00820000
       BEGIN                                                            00821000
          PLINK ~ EXTRAINFO[PLINKX.IR,PLINKX.IC];                       00822000
          PTYPE ~ EXTRAINFO[PTYPEX.IR,PTYPEX.IC].CLASS;                 00823000
          FMINUS ~ FMINUS+1;                                            00824000
          IF PLINK = 0 THEN                                             00825000
          BEGIN                                                         00826000
             EMITOPDCLIT(FMINUS);                                       00827000
             EMITL(LABX ~ LABX-1);                                      00828000
             EMITDESCLIT(LABELMOM);                                     00829000
             EMITO(STD);                                                00830000
          END ELSE                                                      00831000
          BEGIN                                                         00832000
          IF CL ~ (INF ~ GET(PLINK)).CLASS = UNKNOWN THEN CL ~ VARID;   00833000
          XTA ~ GET(PLINK+1);                                           00834000
          IF PTYPE = 0 THEN EXTRAINFO[PTYPEX.IR,PTYPEX.IC].CLASS        00835000
          ~ PTYPE ~ CL;                                                 00836000
          CASE PTYPE OF                                                 00837000
          BEGIN ;                                                       00838000
          IF CL ! ARRAYID THEN FLAG(79) ELSE                            00839000
          ARRY:                                                         00840000
          BEGIN                                                         00841000
             FMINUS ~ FMINUS+1;                                         00842000
             IF INF < 0 THEN                                            00843000
             BEGIN                                                      00844000
                EMITPAIR(FMINUS, LOD);                                  00845000
                EMITPAIR(T~INF.ADDR, STD);                              00846000
                EMITOPDCLIT(FMINUS-1);                                  00847000
                EMITPAIR(T-1, STD);                                     00848000
             END;                                                       00849000
          END;                                                          00850000
          IF CL ! VARID THEN FLAG(80) ELSE                              00851000
          LOAD:                                                         00852000
          BEGIN                                                         00854000
          IF INF.SUBCLASS}DOUBTYPE AND CL=VARID THEN FMINUS~FMINUS+1;   00854100
          IF INF<0 THEN                                                 00854200
          BEGIN                                                         00854300
             EMITPAIR(FMINUS, LOD);                                     00855000
             EMITPAIR(T~INF.ADDR,STD);                                  00856000
          IF INF.SUBCLASS}DOUBTYPE AND CL=VARID THEN               %105-10856100
                BEGIN EMITOPDCLIT(FMINUS-1);                            00856200
                      EMITPAIR(T+1,STD);                                00856300
                END;                                                    00856400
          END ;                                                         00856500
          END;                                                          00857000
          ; ; ; ;                                                       00858000
          IF CL = FUNID THEN GO TO LOAD ELSE FLAG(81);                  00859000
                                                                        00859100
                                                                        00859200
                                                                        00859300
                                                                        00859400
                                                                        00859500
          ;                                                             00860000
          IF CL = FUNID OR CL = SUBRID OR CL = EXTID THEN GO TO LOAD    00861000
                ELSE FLAG(83);                                          00861100
          IF CL = SUBRID THEN GO TO LOAD ELSE FLAG(82);                 00862000
          ; ;                                                           00863000
          BEGIN                                                         00864000
             IF CL = ARRAYID THEN                                       00865000
             BEGIN                                                      00866000
                EXTRAINFO[PTYPEX.IR,PTYPEX.IC].CLASS ~ CL;              00867000
                GO TO ARRY;                                             00868000
             END;                                                       00869000
             INDX:                                                      00870000
             IF CL ! VARID THEN FLAG(80);                               00871000
             FMINUS ~ FMINUS+1;                                         00872000
             IF INF < 0 THEN                                            00873000
             BEGIN                                                      00874000
                EMITOPDCLIT(FMINUS-1);                                  00875000
                EMITDESCLIT(FMINUS);                                    00876000
                EMITPAIR(INF.ADDR, STD);                                00877000
             END;                                                       00878000
          END;                                                          00879000
          IF CL = VARID THEN GO TO LOAD ELSE FLAG(80);                  00880000
          GO TO INDX;                                                   00892000
          END CASE STATEMENT;                                           00893000
          A ~ INF.SUBCLASS;                                             00894000
          IF T ~ EXTRAINFO[PTYPEX.IR,PTYPEX.IC].SUBCLASS = 0 OR         00895000
             T = INTYPE AND A = REALTYPE THEN                           00896000
             EXTRAINFO[PTYPEX.IR,PTYPEX.IC].SUBCLASS ~ A ELSE           00897000
             IF T ! A THEN                                              00898000
             BEGIN XTA ~ GET(PLINK+1); FLAG(88) END;                    00899000
          END;                                                          00900000
          PLINKX ~ PLINKX+1;                                            00901000
          PTYPEX ~ PTYPEX-1;                                            00902000
       END;                                                             00903000
       PLINKX ~ PLINKX-NPARMS;                                          00904000
       FOR J ~ 1 STEP 1 UNTIL NPARMS DO                                 00905000
       BEGIN                                                            00906000
          PLINK ~ EXTRAINFO[PLINKX.IR,PLINKX.IC];                       00907000
          IF PLINK ! 0 THEN                                             00908000
          IF (A~GET(PLINK)).CLASS = ARRAYID THEN                        00909000
          IF T~GET(PLINK+2) <0 THEN VARIABLEDIMS(A, T);                 00910000
          PLINKX ~ PLINKX+1;                                            00911000
       END;                                                             00912000
    END;                                                                00913000
    EMITB(GET(ELINK+2).BASE & (GET(ELINK).SEGNO)[TOSEGNO], FALSE);      00914000
IF DEBUGTOG THEN FLAGROUTINE("  FIXP","ARMS  ",FALSE) ;                 00914010
END FIXPARAMS;                                                          00915000
PROCEDURE XREFCORESORT ;                                                00915100
    BEGIN                                                               00915120
    REAL F,G,H,J,K,L,T,TT,IJ,M,TN ;                                     00915140
    SAVE ARRAY A[0:XRI-1], IL,IU[0:8];                                  00915160
    ARRAY W2,W3[0:XRI-1] ;                                              00915180
    LABEL L1,L2,L3,L4,L5,L6,L11,L12,L13,L14 ;                           00915200
    DEFINE CMPARGT(A) = A.NAME=TN THEN IF (IF G~W3[H~A.[2:10]].[26:4]   00915220
                        =TT~W3[F~T.[2:10]].[26:4] THEN NOT CMPA(W2[H],  00915240
                        W2[F]) ELSE G>TT) #,                            00915260
           CMPARLS(A) = A.NAME=TN THEN IF (IF G~W3[H~T.[2:10]].[26:4]   00915280
                        =TT~W3[F~A.[2:10]].[26:4] THEN NOT CMPA(W2[H],  00915300
                        W2[F]) ELSE G>TT) #,                            00915320
           NAME = [12:36] # ;                                           00915340
    J~XRI-1;  G~XRI DIV K~XRBUFFDIV3;  H~XRBUFF ;                       00915360
    FOR L~1 STEP 1 UNTIL G DO                                           00915380
         BEGIN                                                          00915400
L11:     READ(XREFF,H,XRRY[*]);  TRANSFER(W2[T~(L-1)|50],XRRY,K) ;      00915420
         IJ~T+K-1;  TN~-3;                                              00915440
         FOR F~T STEP 1 UNTIL IJ DO                                     00915460
              BEGIN A[F]~XRRY[TN~TN+3]&F[2:38:10]; W3[F]~XRRY[TN+2] END;00915480
         END;                                                           00915500
    IF H=XRBUFF THEN IF K~XRI MOD K DIV 1!0 THEN BEGIN H~3|K;GO L11 END;00915520
    GO L4 ;                                                             00915540
L1: IF A[K~I].NAME>TN~(T~A[IJ~((L~J)+I+1).[37:10]]).NAME THEN           00915560
L12:     BEGIN A[IJ]~A[I];  A[I]~T;  TN~(T~A[IJ]).NAME END              00915580
    ELSE IF CMPARGT(A[I]) THEN GO L12 ;                                 00915600
    IF A[J].NAME<TN THEN                                                00915620
         BEGIN                                                          00915640
L14:     A[IJ]~A[J];  A[J]~T ;                                          00915660
         IF TN~(T~A[IJ]).NAME<A[I].NAME THEN                            00915680
L13:          BEGIN A[IJ]~A[I]; A[I]~T; TN~(T~A[IJ]).NAME END           00915700
         ELSE IF CMPARGT(A[I]) THEN GO L13 ;                            00915720
         END                                                            00915740
    ELSE IF CMPARLS(A[J]) THEN GO L14 ;                                 00915760
L2: IF A[L~L-1].NAME>TN THEN GO L2;  IF CMPARGT(A[L]) THEN GO L2;       00915780
L3: IF A[K~K+1].NAME<TN THEN GO L3;  IF CMPARLS(A[K]) THEN GO L3;       00915800
    IF K LEQ L THEN BEGIN DOUBLE(A[K],A[L],~,A[L],A[K]); GO L2 END ;    00915820
    IF L+K>J+I THEN BEGIN IL[M]~I; IU[M]~L; I~K END                     00915840
    ELSE BEGIN IL[M]~K; IU[M]~J; J~L END ;                              00915860
    M~M+1 ;                                                             00915880
L4: IF I+10<J THEN GO L1;                                               00915900
    IF I=0 THEN IF I<J THEN GO L1;                                      00915920
    FOR I~I+1 STEP 1 UNTIL J DO                                         00915940
         IF A[K~I-1].NAME>TN~(T~A[I]).NAME THEN                         00915960
              BEGIN                                                     00915980
L5:           A[K+1]~A[K];  IF A[K~K-1].NAME>TN THEN GO L5 ;            00916000
              IF CMPARGT(A[K]) THEN GO L5 ;                             00916020
              A[K+1]~T ;                                                00916040
              END                                                       00916060
         ELSE IF CMPARGT(A[K]) THEN GO L5 ;                             00916080
    IF (M~M-1) GEQ 0 THEN BEGIN I~IL[M]; J~IU[M]; GO L4 END ;           00916100
    G~XRI-1 ;                                                           00916120
    FOR I~ 0 STEP 1 UNTIL G DO                                          00916140
         IF BOOLEAN(L~REAL(A[I]~A[I].NAME&(TN~W3[J~A[I].[2:10]])[1:26:1]00916160
                    =XTA)) THEN                                         00916180
              BEGIN                                                     00916200
              IF IT~IT+1=9 THEN                                         00916220
                   BEGIN LASTLINE~FALSE;  WRITE(LINE,15,PRINTBUFF[*]) ; 00916240
L6:                BLANKIT(PRINTBUFF,15,IT~0) ;                         00916260
                   END ;                                                00916280
              SETPNT(A[I],W2[J],PRINTBUFF,KLASS[TN.CLASS],TYPES[TN.     00916300
                     SUBCLASS],IF BOOLEAN(TN) THEN "*" ELSE " ",IT,L-1, 00916320
                     LASTLINE,6-TN.[27:3]) ;                            00916340
              END                                                       00916360
          ELSE BEGIN                                                    00916380
              LASTLINE~TRUE;  WRITE(RITE,15,PRINTBUFF[*]);  XTA~A[I];   00916400
              GO L6;                                                    00916420
              END ;                                                     00916440
    WRITE(LINE,15,PRINTBUFF[*]);  XRI~0;                                00916460
    END OF XREFCORESORT ;                                               00916480
PROCEDURE SETUPSTACK ;                                                  00916900
BEGIN                                                                   00917000
   REAL I;                                                              00918000
   EMITOPDCLIT(16);                                                     00919000
   EMITL(1);                                                            00920000
   EMITO(ADD);                                                          00921000
   EMITL(16);                                                           00922000
   EMITO(SND);                                                          00923000
   FOR I ~ 1 STEP 1 UNTIL LOCALS DO EMITL(0);                           00924000
   CHECKINFO;                                                           00925000
   IF DATAPRT ! 0 THEN                                                  00925010
         BEGIN ADJUST; EMITOPDCLIT(DATAPRT); EMITO(LNG); EMITB(-1,TRUE);00925020
               DATASKP~LAX; EMITB(DATASTRT,FALSE); FIXB(DATALINK);      00925030
               EMITL(1); EMITPAIR(DATAPRT,STD); FIXB(DATASKP);          00925040
         END;                                                           00925050
   ADJUST;                                                              00925060
END SETUPSTACK;                                                         00926000
PROCEDURE BRANCHLIT(X,Y); VALUE X,Y; REAL X; BOOLEAN Y;                 00927000
BEGIN                                                                   00928000
    IF ADR } 4075 THEN                                                  00929000
      BEGIN ADR ~ ADR+1; SEGOVF END;                                    00930000
   ADJUST;                                                              00931000
   IF X.SEGNO!NSEG THEN BEGIN                                           00932000
      IF(PRTS+1).[37:2]=1 AND Y THEN                                    00932300
      EMITOPDCLIT(PRGDESCBLDR(2,0,(ADR+5) DIV 4+1,NSEG))                00932700
      ELSE EMITOPDCLIT(PRGDESCBLDR(2,0,(ADR+5) DIV 4,NSEG)) END         00933000
   ELSE                                                                 00934000
   EMITL((ADR+5) DIV 4 - X.LINK DIV 4) ;                                00935000
END BRANCHLIT;                                                          00936000
PROCEDURE SEGMENT(SZ,CURSEG,SEGTYP,EDOC); % WRITES OUT EDOC AS SEGMENT  00937000
    VALUE SZ,CURSEG,SEGTYP;            % UPDATES PDPRT WITH PSUEDO      00938000
    REAL SZ,CURSEG;                    % UPDATES PDPRT WITH PSUEDO      00939000
    BOOLEAN SEGTYP;     % TRUE TO WRAP UP A SUBROUTINE BLOCK            00940000
                        % FALSE TO WRAP UP A SPLIT BLOCK                00941000
    ARRAY EDOC[0,0];                   % CONTAINS DATA TO WRITE;        00942000
    BEGIN                                                               00943000
         STREAM PROCEDURE M1(F,T); BEGIN DI ~ T; SI ~ F; DS ~ 2 WDS END;00944000
         REAL T;                                                        00945000
         REAL BEGINSUB, ENDSUB, HERE;                                   00946000
         LABEL WRITEPGM;                                                00947000
         INTEGER I, CNTR;                                               00948000
IF DEBUGTOG THEN FLAGROUTINE("  SEGM","ENT   ",TRUE );                  00948010
         IF NOT SEGTYP  THEN GO TO WRITEPGM;                            00949000
         IF SPLINK > 1 AND NOT RETURNFOUND THEN                         00949100
         BEGIN XTA ~ BLANKS; FLAG(142) END;                             00949200
         IF SPLINK < 0 THEN                                             00950000
    BEGIN                                                               00951000
         ADJUST;                                                        00952000
         BDPRT[BDX~BDX+1] ~ PRGDESCBLDR(1, 0, (ADR+1) DIV 4, NSEG);     00953000
         FOR I ~ 1 STEP 1 UNTIL LOCALS DO EMITL(0);                     00954000
         CHECKINFO;                                                     00955000
                                                                        00955500
         EMITB(0&INITIALSEGNO[TOSEGNO], FALSE);                         00956000
    END                                                                 00957000
         ELSE                                                           00958000
         IF SPLINK = 1 THEN            % MAIN PROGRAM                   00959000
    BEGIN                                                               00960000
         ADJUST;                                                        00961000
         IF STRTSEG ! 0 THEN FLAG(75);                                  00962000
         STRTSEG ~ NSEG &                                               00963000
            PRGDESCBLDR(1, 0, (ADR+1) DIV 4, NSEG)[18:33:15];           00964000
         SETUPSTACK;                                                    00965000
                                                                        00965500
         EMITB(0&INITIALSEGNO[TOSEGNO], FALSE);                         00966000
    END                                                                 00967000
         ELSE                                                           00968000
         IF ELX { 1 THEN                                                00969000
    BEGIN                                                               00970000
         ADJUST;                                                        00971000
         T ~ PRGDESCBLDR(1, GET(SPLINK).ADDR, (ADR+1) DIV 4, NSEG);     00972000
         SETUPSTACK;                                                    00973000
         FIXPARAMS(0);                                                  00974000
         INFO[SPLINK.IR, SPLINK.IC].SEGNO ~ NSEG;                       00975000
    END                                                                 00976000
         ELSE                                                           00977000
    BEGIN                                                               00978000
         ADJUST;                                                        00979000
         BEGINSUB ~ (ADR+1) & NSEG[TOSEGNO];                            00980000
         EMITL(17); EMITO(STD);                                         00981000
         SETUPSTACK;                                                    00982000
         EMITOPDCLIT(17); EMITO(GFW);                                   00982100
         ENDSUB ~ ADR & NSEG[TOSEGNO];                                  00983000
         FOR I ~ 0 STEP 1 UNTIL ELX-1 DO                                00984000
    BEGIN                                                               00985000
         ADJUST;                                                        00986000
         HERE ~ (ADR+1) DIV 4;                                          00988000
         T ~ ENTRYLINK[I].LINK;                                         00989000
%VOID                                                                   00990000
         T ~ PRGDESCBLDR(1, GET(T).ADDR, HERE, NSEG);                   00991000
         BRANCHLIT(ENDSUB,FALSE);                                       00992000
         EMITB(BEGINSUB, FALSE);                                        00993000
      ADJUST;                                                           00994000
         FIXPARAMS(I);                                                  00995000
         INFO[(ENTRYLINK[I].LINK).IR,(ENTRYLINK[I].LINK).IC].SEGNO~NSEG;00995500
    END;                                                                00996000
    END;                                                                00997000
         SZ ~ (ADR+4) DIV 4;                                            00998000
         CNTR ~ 0;                                                      00999000
         CURSEG ~ NSEG;                                                 00999100
         WRITEPGM:                                                      01000000
         NSEG ~ ((T ~ SZ) + 29) DIV 30;                                 01001000
         IF DALOC DIV CHUNK < I ~ (DALOC+NSEG) DIV CHUNK                01002000
           THEN DALOC ~ CHUNK | I;  % INSURE SEGMENT DONT BREAK         01003000
                                     % ACROSS ROW                       01004000
         IF LISTOG THEN WRITALIST(SEGEND,2,CURSEG,T,0,0,0,0,0,0) ;      01005000
         PDPRT[PDIR,PDIC] ~           % PDPRT ENTRY FOR SEGMENT         01006000
            SZ&DALOC[DKAC]                                              01007000
              & GET(SPLINK)[12:41:1]                                    01007100
              &CURSEG[SGNOC];                                           01008000
         IF ERRORCT = 0 THEN                                            01009000
         DO BEGIN                                                       01010000
         FOR I~0 STEP 2 WHILE I < 30 AND CNTR < SZ DO                   01011000
         BEGIN M1(EDOC[CNTR.[38:3],CNTR.[41:7]],CODE(I));               01012000
               CNTR ~ CNTR + 2;                                         01013000
         END;                                                           01014000
         WRITE(CODE[DALOC]);                                            01015000
         DALOC ~ DALOC +1;                                              01016000
         END UNTIL CNTR } SZ;                                           01017000
         PDINX ~ PDINX +1;                                              01018000
         IF NOT SEGOVFLAG THEN                                          01018025
         IF PXREF THEN                                                  01018100
         IF(EODS~(NEXT=EOF))AND NOT XGLOBALS THEN ELSE                  01018110
         BEGIN KLASS[6]~ "LABEL ";                                      01018120
               WRITE(XREFF,XRBUFF,XRRY[*]) ;                            01018125
               IF FIRSTCALL THEN DATIME ELSE WRITE(PTR[PAGE]);          01018130
                IF SPLINK<0 THEN                                        01018135
                   BEGIN WRITE(PTR,XHEDB);REWIND(XREFF);END             01018140
                ELSE                                                    01018145
               IF EODS THEN BEGIN WRITE(PTR,XHEDG); REWIND(XREFG) END   01018150
               ELSE BEGIN REWIND(XREFF); C2~(XR[4].SUBCLASS|2+5);       01018160
                          IF IT~XR[4].CLASS=FUNID THEN WRITE(PTR,XHEDF, 01018170
                                 XR[C2],XR[C2+1],XR[3],XR[C2+12],       01018180
                                 XR[C2+13],"------")                    01018190
                          ELSE IF IT=SUBRID THEN WRITE(PTR,XHEDS,XR[3], 01018200
                                  "------") ELSE WRITE(PTR,XHEDM);      01018210
                    END;                                                01018220
               IT~XTA~0;                                                01018260
               LASTLINE ~ FALSE;                                        01018280
               BLANKIT(PRINTBUFF,15,0);                                 01018320
               IF XRI>1023 OR EODS THEN SORT(PT,INP,0,HV,CMP,3,4000)    01018330
               ELSE XREFCORESORT ;                                      01018340
               REWIND(XREFF);                                           01018350
               PXREF~IF XREF THEN TRUE ELSE FALSE;                      01018355
               KLASS[6] ~ "ERROR ";                                     01018360
               IF (NOT SEGTYP  AND EODS) OR (SEGTYP  AND LISTOG AND     01018370
                   NOT SEGPTOG) THEN WRITE (PTR[PAGE]);                 01018375
         END;                                                           01018380
         IF LISTOG AND SEGTYP AND SEGPTOG THEN WRITE(PTR[PAGE]);        01019000
         IF SEGTYP THEN                                                 01019100
              BEGIN                                                     01019110
              FOR I~12,17 STEP 1 UNTIL 24,39 STEP 1 UNTIL 41,           01019150
              50 STEP 1 UNTIL 57 DO TIPE[I]~REALID ;                    01019160
              FOR I~25,33 STEP 1 UNTIL 37 DO TIPE[I]~INTID ;            01019170
              LASTNEXT ~ 1000;                                          01019190
              END;                                                      01019200
         ENDSEGTOG ~ TRUE;                                              01020000
         TSEGSZ ~ TSEGSZ + SZ;                                          01021000
         COMMENT IF SEGSW THEN LETS ALSO WRITE OUT THE LINE SEGMENTS    01021010
                 THAT WE VE GONE TO SUCH TROUBLE BUILDING. LINESEG      01021150
                 CONTAINS A CARD SEQUENCE NUMBER(BINARY) IN [10:28]     01021200
                 AND THE WORD BOUNDARY ADDRESS OF THE FIRST CODE        01021250
                 SYLLABLE IN [38:10];                                   01021300
         IF SEGSW THEN                                                  01021350
         IF NOLIN > 0 THEN                                              01021360
         BEGIN                                                          01021400
            LINEDICT[CURSEG.IR,CURSEG.IC] ~ % UPDATE LINE DICTIONARY    01021450
             0 & NOLIN[18:33:15] & DALOC[33:33:15];%FOR THIS SEGMENT    01021500
            CNTR ~ 0; DO BEGIN                                          01021550
            FOR I ~ 0 STEP 2 WHILE I<30 AND CNTR<NOLIN DO               01021600
            BEGIN                                                       01021650
               M1(LINESEG[CNTR.[38:3],CNTR.[41:7]],CODE(I));            01021700
               CNTR~CNTR+2                                              01021750
            END;                                                        01021800
            WRITE(CODE[DALOC]);                                         01021850
            DALOC~DALOC+1;                                              01021900
            END UNTIL CNTR } NOLIN;                                     01021950
         END ;                                                          01021955
        IF NOT SEGOVFLAG THEN XRI ~ 0;                                  01021957
         IF DEBUGTOG THEN FLAGROUTINE("  SEGM","ENT   ",FALSE) ;        01021959
    END SEGMENT;                                                        01022000
PROCEDURE WRITEDATA(SZ,SEG,ARY);  % WRITES OUT TYPE 2 SEGMENTS          01023000
    VALUE SZ,SEG;                                                       01024000
    REAL SZ,SEG;                                                        01025000
    ARRAY ARY[0];                                                       01026000
    BEGIN                                                               01027000
         INTEGER T,NSEG,I,CNTR;                                         01028000
         INTEGER TYPE;                                                  01029000
         STREAM PROCEDURE M30(F,T,SZ); VALUE SZ;                        01030000
         BEGIN                                                          01031000
              SI~F; DI~T; DS~SZ WDS;                                    01032000
         END M30;                                                       01033000
         IF SZ } 0 THEN TYPE ~ 2 ELSE SZ ~ -SZ;                         01034000
         NSEG ~ (( T~SZ) +29) DIV 30;                                   01035000
         IF DALOC DIV CHUNK < I ~ (DALOC+NSEG) DIV CHUNK                01036000
           THEN DALOC ~ CHUNK | I;                                      01037000
         PDPRT[PDIR,PDIC] ~                                             01038000
           SZ&DALOC[DKAC]                                               01039000
             &TYPE[STYPC]                                               01040000
             &SEG[SGNOC];                                               01041000
         PDINX ~ PDINX +1;                                              01042000
         IF ERRORCT = 0 THEN                                            01043000
         FOR I ~ 0 STEP 30 WHILE I < SZ DO                              01044000
    BEGIN                                                               01045000
         M30(ARY[I],CODE(0),IF (SZ-I) > 30 THEN 30 ELSE (SZ-I));        01046000
         WRITE(CODE[DALOC]);                                            01047000
         DALOC ~ DALOC +1;                                              01048000
    END;                                                                01049000
         IF LISTOG THEN WRITALIST(SEGEND,2,SEG,T,0,0,0,0,0,0) ;         01050000
         TSEGSZ ~ TSEGSZ + SZ;                                          01051000
    END WRITEDATA;                                                      01052000
REAL PROCEDURE PRGDESCBLDR(DT,PRT,RELADR,SGNO);                         01053000
    VALUE DT,PRT,RELADR,SGNO;                                           01054000
    REAL  DT,PRT,RELADR,SGNO;                                           01055000
    BEGIN                                                               01056000
    FORMAT FMT("PRT=",A4,", REL-ADR=",A4,", SEG=",I4,", TYPE=",A2);     01057000
         IF PRT=0 THEN BEGIN BUMPPRT; PRT~PRTS END;                     01058000
         PDPRT[PDIR,PDIC] ~                                             01059000
            0&DT[DTYPC]                                                 01060000
             &PRT[PRTAC]                                                01061000
             &RELADR[RELADC]                                            01062000
             &SGNO[SGNOC];                                              01063000
         PDINX ~ PDINX +1;                                              01064000
         IF CODETOG THEN WRITALIST(FMT,4,B2D(PRT),B2D(RELADR),SGNO,     01065000
         IF DT=0 THEN "AE" ELSE IF DT=1 THEN "PD" ELSE "LD",0,0,0,0) ;  01066000
         PRGDESCBLDR ~ PRT;                                             01067000
    END PRGDESCBLDR;                                                    01068000
PROCEDURE EQUIV(R); VALUE R; REAL R;                                    01069000
COMMENT  THIS PROCEDURE FIXES UP THE INFO TABLE FOR THE EQUIV OR        01069100
           COMMON RING. THE FIRST ELEMENT PAST HAS AN OFFSET (DO NOT    01069110
           ALTER THIS) THE TYPE IS FIXED.  THE OFFSET IS DETERMINED     01069120
           FROM THE FIRST.  CORRECTINFO ADJUST THE OFFSET IF THERE      01069130
           IS A NEGATIVE OFFSET ON ANY ELEMENT.  THE INFA[ADJ] BIT IS   01069140
           SET IF THE ELEMENT HAS A NEGATIVE OFFSET.  IF THE ELEMENT    01069150
           APPEARED IN MORE THAN ONE EQUIVALENCE STATEMENT OR AN        01069160
           EQUIVALENCE STATEMENT AND A COMMON STATEMENT THE ELEMENTS    01069170
           ARE LINKED BY COM[LASTC] WHICH POINTS TO THE HEADER          01069180
           OF THAT STATEMENT;                                           01069190
BEGIN                                                                   01070000
   DEFINE BASS    = LOCALS    #,  % THESE DEFINES ARE USED TO REDUCE THE01071000
          REL     = PARMS     #,  % STACKSIZE OF EQUIV FOR RECURSION    01071100
          I       = PRTS      #,                                        01071200
          T       = LSTS      #,                                        01071250
          Q       = LSTA      #,                                        01071400
          LAST    = TV        #,                                        01071500
          B       = SAVESUBS  #,                                        01071600
          P       = NAMEIND   #,                                        01071700
          PRTX    = LSTI      #,                                        01071800
          C       = FX1       #,                                        01071900
          INFA    = FX2       #,                                        01072000
          INFB    = FX3       #,                                        01072100
          INFC    = NX1       #;                                        01072200
   LABEL XIT, CHECK;                                                    01073000
IF DEBUGTOG THEN FLAGROUTINE("   EQU","IV    ",TRUE) ;                  01073010
   IF GETC(R) <0 THEN GO TO XIT;                                        01074000
   PUTC(R,-GETC(R)) ;                                                   01075000
   PRTX ~ GROUPPRT;                                                     01076000
   C~REAL(GETC(R).CE=1) ;                                               01077000
   LAST~GETC(R).LASTC-1 ;                                               01078000
   BASS~GETC(R+1);  P~0 ;                                               01079000
   FOR I ~ R+2 STEP 1 UNTIL LAST DO                                     01080000
   BEGIN IF GETC(I).CLASS=ENDCOM THEN I~GETC(I).LINK ;                  01081000
   GETALL(T~GETC(I).LINK,INFA,INFB,INFC) ;                              01082000
   IF Q~INFC.SIZE=0 THEN %   A SIMPLE VARIABLE                          01083000
      INFC.SIZE ~ Q ~ IF INFA.SUBCLASS { LOGTYPE THEN 1 ELSE 2;         01084000
   PUT(T+2,INFC);                                                       01085000
   IF INFA.SUBCLASS>LOGTYPE THEN         SEENADOUB~TRUE;                01085500
   IF BOOLEAN(C) THEN                                                   01086000
      BEGIN COM[PWI].RELADD~REL~P ;                                     01087000
         P ~ P + Q;                                                     01088000
      END ELSE COM[PWI].RELADD~REL~BASS-GETC(I).RELADD ;                01089000
      IF INFA    < 0 THEN IF INFA    .ADJ = 1 THEN                      01090000
         B ~ -INFC.BASE - REL ELSE B ~ INFC.BASE - REL;                 01091000
   END;                                                                 01092000
   FOR I ~ R+2 STEP 1 UNTIL LAST DO                                     01093000
   BEGIN IF GETC(I).CLASS=ENDCOM THEN I~GETC(I).LINK ;                  01094000
      GETALL(T~GETC(I).LINK,INFA,INFB,INFC) ;                           01095000
   IF INFA.CLASS = 1 THEN SWARYCT ~ 1;                                  01095500
      P~B+GETC(I).RELADD ;                                              01096000
      Q ~ INFC   .SIZE;                                                 01097000
      IF INFA     < 0 THEN                                              01098000
      BEGIN IF INFA    .ADJ = 1 THEN BASS ~ -INFC    .BASE ELSE         01099000
         BASS ~ INFC.BASE;                                              01100000
         IF P ! BASS THEN                                               01101000
         BEGIN XTA ~ INFB   ; FLAG(2) END;                              01102000
         GO TO CHECK;                                                   01104000
      END;                                                              01105000
      INFA    ~ -INFA    & PRTX[TOADDR];                                01108000
    IF INFA    .CLASS = UNKNOWN THEN INFA   .CLASS ~ VARID;             01109000
    INFA   .TYPEFIXED ~ 1;                                              01110000
    INFC.BASE ~ P;                                                      01111000
    PUT(T+2,INFC);                                                      01112000
    IF P < 0 THEN INFA   .ADJ ~ 1;                                      01113000
    PUT(T,INFA);                                                        01114000
    CHECK:                                                              01115000
    IF P+Q > LENGTH THEN LENGTH ~ P+Q;                                  01116000
    IF P < LOWERBOUND THEN LOWERBOUND ~ P;                              01117000
    END;                                                                01118000
    FOR I ~ R+2 STEP 1 UNTIL LAST DO                                    01119000
    BEGIN                                                               01120000
       IF GETC(I).CLASS=ENDCOM THEN I~GETC(I).LINK ;                    01121000
       IF T~GETC(I).LASTC!R THEN                                        01122000
          IF GETC(T)}0 THEN                                             01122500
               BEGIN R~R&LAST[3:33:15]&I[18:33:15] ;                    01122550
               EQUIV(T);  LAST~R.[3:15];  I~R.[18:15];  R~R.[33:15] ;   01122600
               END;                                                     01122650
    END;                                                                01123000
    XIT:                                                                01124000
IF DEBUGTOG THEN FLAGROUTINE("   EQU","IV    ",FALSE) ;                 01124010
END EQUIV;                                                              01125000
ALPHA PROCEDURE GETSPACE(S); VALUE S; ALPHA S;                          01126000
BEGIN LABEL RPLUS, FMINUS, XIT;                                         01127000
   LABEL DONE;                                                          01128000
   REAL A;                                                              01129000
   BOOLEAN OWNID;                                                       01129100
   IF OWNID ~ S < 0 THEN S~ -S;       % IN DATA STMT, THUS OWN          01129200
   IF A ~ GET(GETSPACE~S) < 0 THEN GO TO DONE;                          01130000
   IF A.CLASS GEQ 13 THEN FLAG(34) ELSE                            %104-01130500
CASE A.CLASS OF                                                         01131000
BEGIN                                                                   01132000
BEGIN                                                                   01133000
   PUT(S,A~A&VARID[TOCLASS]);                                           01134000
   PUT(S+2,(GET(S+2)   &(IF A.SUBCLASS { LOGTYPE                        01135000
       THEN 1 ELSE 2 )[TOSIZE]));                                       01136000
END;                                                                    01137000
   IF BOOLEAN(A.FORMAL) THEN BUMPLOCALS;                                01138000
;                                                                       01139000
BEGIN A.TYPEFIXED ~ 1; GO TO RPLUS END;                                 01140000
GO TO RPLUS;                                                            01141000
GO TO RPLUS;                                                            01142000
GO TO DONE;                                                             01143000
BEGIN A.TYPEFIXED ~ 1; IF BOOLEAN(A.FORMAL) THEN GO TO FMINUS           01144000
   ELSE GO TO RPLUS;                                                    01145000
END;                                                                    01146000
BEGIN A.TYPEFIXED ~ 1; GO TO RPLUS END;                                 01147000
IF BOOLEAN(A.FORMAL) THEN GO TO FMINUS ELSE GO TO RPLUS;                01148000
IF BOOLEAN(A.FORMAL) THEN GO TO FMINUS ELSE GO TO RPLUS;                01149000
GO TO RPLUS;                                                            01150000
GO TO RPLUS;                                                            01151000
END OF CASE STATEMENT;                                                  01152000
A.TYPEFIXED ~ 1;                                                        01153000
IF BOOLEAN(A.FORMAL) THEN                                               01154000
         GO TO FMINUS;                                                  01155000
IF BOOLEAN(A.CE) OR BOOLEAN(A.EQ) THEN                                  01156000
BEGIN                                                                   01157000
   PUT(S,A);                                                            01158000
   CALLEQUIV(A.ADDR,OWNID,GET(S+1)) ;                                   01159000
   GO TO DONE;                                                          01160000
END;                                                                    01161000
   A.TWOD ~ REAL(GET(S+2).SIZE > 1023);                                 01162000
FMINUS:                                                                 01163000
   IF OWNID THEN BEGIN BUMPPRT; A.ADDR~PRTS END ELSE                    01163100
    BEGIN BUMPLOCALS; A.ADDR ~ LOCALS +1536 END;                        01164000
   IF A.CLASS = VARID THEN IF A.SUBCLASS } DOUBTYPE THEN                01165000
   IF OWNID THEN BUMPPRT ELSE                                           01165100
   BUMPLOCALS;                                                          01166000
   GO TO XIT;                                                           01167000
RPLUS:                                                                  01168000
   BUMPPRT; A.ADDR~PRTS;                                                01169000
XIT:                                                                    01170000
   PUT(S, -A);                                                          01171000
DONE:                                                                   01172000
END GETSPACE;                                                           01173000
INTEGER STREAM PROCEDURE LBLSHFT(S);     VALUE S;                       01174000
    BEGIN                                                               01175000
         LOCAL T;                                                       01176000
         LABEL L;                                                       01177000
         DI ~ LOC LBLSHFT; DS ~ 8 LIT "00      ";                       01178000
         DI ~ DI - 6; SI ~LOC S; SI ~ SI + 2;                           01179000
         TALLY ~ 1; T ~ TALLY;                                          01180000
     5(T(IF SC="0" THEN BEGIN SI~SI+1; JUMP OUT 1 TO L END              01181000
      ELSE TALLY~0; T~TALLY);                                           01182000
         IF SC}"0" THEN DS~CHR ELSE IF SC=" " THEN SI~SI+1              01183000
         ELSE JUMP OUT;  L: ) ;                                         01183100
         IF SC ! " " THEN BEGIN DI ~ LOC LBLSHFT; DS ~ LIT "+" END;     01184000
    END LBLSHFT;                                                        01185000
         COMMENT EMITTERS AND CODE CONTROL;                             01186000
ALPHA PROCEDURE B2D(B); VALUE B; REAL B;                                01187000
         B2D ~ 0&B[45:45:3]&B[39:42:3]&B[33:39:3]&B[27:36:3];           01188000
PROCEDURE DEBUG(S);     % PRINTS OUT DEBUG CODE                         01189000
    VALUE S; REAL S;    % IF S<0 THEN S IS FIELD TYPE OPERATOR          01190000
    BEGIN                                                               01191000
         FORMAT FF(X35,*(33(".")),A4,":",A1,2(X2,A4),X4,A4) ;           01192000
         ALPHA CODE,MNM,SYL;                                            01193000
    REAL T;                                                             01194000
PROCEDURE SEARCH(CODE,S); VALUE S; REAL S,CODE;                         01195000
    BEGIN  % SEARCHS WOP TO FIND CODE FOR S                             01196000
    REAL N,I;                                                           01197000
    LABEL L;                                                            01198000
         N ~ 64;                                                        01199000
         FOR I ~ 66 STEP IF WOP[I] < S THEN N ELSE -N                   01200000
         WHILE N ~ N DIV 2 } 1 DO                                       01201000
         IF WOP[I] =S THEN GO TO L;                                     01202000
         I ~ 0;         % NOT FOUND                                     01203000
    L:   CODE ~ WOP[I+1];                                               01204000
    END SEARCH;                                                         01205000
         IF S < 0 THEN                                                  01206000
    BEGIN     % FIELD TYPE OPERATOR                                     01207000
         SYL ~ S;                                                       01208000
         MNM ~ B2D(S.[36:6]);                                           01209000
         IF (S ~ S.[42:6]) = 37 THEN CODE ~ "ISO " ELSE                 01210000
         IF S = 45 THEN CODE ~ "DIA " ELSE                              01211000
         IF S = 49 THEN CODE ~ "DIB " ELSE                              01212000
         IF S = 53 THEN CODE ~ "TRB ";                                  01213000
    END                                                                 01214000
         ELSE                                                           01215000
    BEGIN                                                               01216000
         IF (T ~ S.[46:2]) ! 1 THEN                                     01217000
    BEGIN                                                               01218000
         SYL ~ S;                                                       01219000
         MNM ~ B2D(S.[36:10]);                                          01220000
         IF T = 0 THEN CODE ~ "LITC"                                    01221000
         ELSE IF T =2 THEN CODE ~ "OPDC"                                01222000
         ELSE CODE ~ "DESC";                                            01223000
    END                                                                 01224000
         ELSE                                                           01225000
    BEGIN      % SEARCH WOP FOR OPERATOR NAME                           01226000
         SYL ~ S;                                                       01227000
         MNM ~ "    ";                                                  01228000
         SEARCH(CODE,S.[36:10]);                                        01229000
    END;                                                                01230000
    END;                                                                01231000
         WRITALIST(FF,6,IF ADR{DEBUGADR THEN 1 ELSE -1,B2D(ADR.[36:10]),01232000
                   B2D(ADR.[46:2]),CODE,MNM,B2D(SYL),0,0) ;             01233000
         IF DEBUGADR<ADR THEN DEBUGADR~ADR;                             01233100
    END DEBUG;                                                          01234000
PROCEDURE DEBUGWORD(N); VALUE N; REAL N; %PRINTS OUT C+ CONSTANTS       01235000
    BEGIN                                                               01236000
         STREAM PROCEDURE WB2D(F,T);                                    01237000
              BEGIN                                                     01238000
                   DI ~ T;                                              01239000
                   DI ~ DI+35; DS~10LIT"CONSTANT  " ;                   01240000
                   SI ~ F;                                              01241000
                   16(DS ~ 3 RESET; 3(IF SB THEN DS ~ SET               01242000
                                             ELSE DS ~ RESET;           01243000
                                       SKIP SB));                       01244000
              END WB2D;                                                 01247000
         ARRAY A[0:14];  FORMAT F(X63,"(DEC ",B,")") ;                  01248000
         WRITE(A[*],F,N);  WB2D(N,A) ;                                  01249000
         WRITAROW(15,A) ;                                               01250000
    END DEBUGWORD;                                                      01251000
REAL PROCEDURE GIT(Z);  % RETURNS OPERATOR IN SYLLABLE Z                01252000
    VALUE Z; REAL Z;                                                    01253000
    BEGIN                                                               01254000
         INTEGER STREAM PROCEDURE GT(S,SKP); VALUE SKP;                 01255000
         BEGIN                                                          01256000
              SI ~ S; SKP(SI ~ SI + 2);                                 01257000
              DI ~ LOC GT; DI ~ DI +6; DS ~ 2 CHR;                      01258000
         END GT;                                                        01259000
         GIT ~ GT(EDOC[Z.[36:3],Z.[39:7]],Z.[46:2]);                    01260000
    END GIT;                                                            01261000
REAL STREAM PROCEDURE SPCLBIN2DEC(N);  VALUE N ;                        01261100
    BEGIN LOCAL L; LABEL B1 ;                                           01261110
    DI~LOC L; SI~LOC N; DS~8DEC; SI~LOC L; TALLY~8 ;                    01261120
B1: IF SC="0" THEN BEGIN TALLY~TALLY+63; SI~SI+1; GO B1 END;            01261130
    DI~LOC SPCLBIN2DEC; DI~DI+2; DS~6LIT" "; DI~DI-6; N~TALLY; DS~N CHR;01261140
    END OF SPCLBIN2DEC;                                                 01261150
STREAM PROCEDURE PACK(T,F,SKP); VALUE SKP,F;                            01262000
    BEGIN     % PACKS OPERATORS INTO EDOC                               01263000
         SI ~ LOC F; SI ~ SI + 6;DI ~ T; SKP(DI ~ DI + 2);              01264000
         DS ~ 2 CHR;                                                    01265000
    END PACK;                                                           01266000
PROCEDURE EMITO(N); VALUE N; REAL N;                                    01267000
    BEGIN                                                               01268000
   BUMPADR;                                                             01269000
         PACK(EDOC[EDOCI],(N~1&N[36:38:10]),ADR.[46:2]);                01270000
         IF CODETOG THEN DEBUG(N);                                      01271000
END EMITO;                                                              01272000
PROCEDURE EMITN(P); VALUE P; REAL P;                                    01273000
BEGIN LABEL XIT;                                                        01274000
   ALPHA S;                                                             01275000
   IF S~GET(P)>0 THEN S~GET(GETSPACE(P));                               01276000
   IF S.CLASS = VARID THEN IF BOOLEAN(S.CE) THEN                        01277000
      IF BOOLEAN(S.TWOD) THEN                                           01278000
      BEGIN                                                             01279000
         EMITL( (T~GET(P+2).BASE).[33:7]);                              01280000
         EMITDESCLIT(S.ADDR);                                           01281000
         EMITO(LOD);                                                    01282000
         EMITL(T.[40:8]);                                               01283000
         EMITO(CDC);                                                    01284000
         GO TO XIT;                                                     01285000
      END ELSE                                                          01286000
      EMITNUM(GET(P+2).BASE)                                            01287000
      ELSE                                                              01288000
      IF NOT BOOLEAN(S.FORMAL) THEN IF NOT DESCREQ THEN                 01289000
      BEGIN                                                             01290000
         EMITL(S~S.ADDR);                                               01291000
         IF S.[37:2]=1 THEN %REFERENCING 2ND HALF OF PRT;               01292000
         BEGIN                                                          01293000
    IF ADR } 4087 THEN                                                  01294000
            BEGIN ADR ~ ADR+1; SEGOVF END;                              01295000
            EMITO(XRT);                                                 01296000
         END;                                                           01297000
         GO TO XIT;                                                     01298000
      END;                                                              01299000
      EMITDESCLIT(S.ADDR);                                              01300000
   XIT:                                                                 01301000
END EMITN;                                                              01302000
PROCEDURE EMITV(P); VALUE P; ALPHA P;                                   01303000
    BEGIN                                                               01304000
   ALPHA S;                                                             01305000
   IF S~ GET(P) > 0 THEN S ~ GET(GETSPACE(P));                          01306000
   IF S.CLASS = VARID THEN                                              01307000
      IF BOOLEAN(S.CE) THEN                                             01308000
         IF BOOLEAN(S.TWOD) THEN                                        01309000
            BEGIN                                                       01310000
               EMITL( (T~GET(P+2).BASE).[33:7]);                        01311000
               EMITDESCLIT(S.ADDR);                                     01312000
               EMITO(LOD);                                              01313000
               IF S.SUBCLASS } DOUBTYPE THEN                            01314000
               BEGIN                                                    01315000
                  EMITO(DUP);                                           01316000
                  EMITPAIR(T.[40:8]+1, COC);                            01317000
                  EMITO(XCH);                                           01318000
                  EMITPAIR(T.[40:8], COC);                              01319000
               END ELSE EMITPAIR(T.[40:8], COC);                        01320000
            END                                                         01321000
            ELSE                                                        01322000
            IF S.SUBCLASS } DOUBTYPE THEN                               01323000
            BEGIN                                                       01324000
               EMITNUM( (T~GET(P+2).BASE)+1);                           01325000
               EMITOPDCLIT(S.ADDR);                                     01326000
               EMITNUM(T);                                              01327000
               EMITOPDCLIT(S.ADDR);                                     01328000
            END ELSE                                                    01329000
            BEGIN                                                       01330000
               EMITNUM(GET(P+2).BASE);                                  01331000
               EMITOPDCLIT(S.ADDR);                                     01332000
            END                                                         01333000
      ELSE                                                              01334000
      IF S.SUBCLASS } DOUBTYPE THEN                                     01335000
      IF BOOLEAN(S.FORMAL) THEN                                         01336000
      BEGIN                                                             01337000
         EMITDESCLIT(S.ADDR);                                           01338000
         EMITO(DUP);                                                    01339000
         EMITPAIR(1, XCH);                                              01340000
         EMITO(INX);                                                    01341000
         EMITO(LOD);                                                    01342000
         EMITO(XCH);                                                    01343000
         EMITO(LOD);                                                    01344000
      END ELSE                                                          01345000
      BEGIN                                                             01346000
         EMITOPDCLIT(S.ADDR+1);                                         01347000
         EMITOPDCLIT(S.ADDR);                                           01348000
      END                                                               01349000
      ELSE EMITOPDCLIT(S.ADDR)                                          01350000
   ELSE EMITOPDCLIT(S.ADDR);                                            01351000
END EMITV;                                                              01352000
PROCEDURE EMITL(N); VALUE N; REAL N;                                    01353000
    BEGIN                                                               01354000
   BUMPADR;                                                             01355000
         PACK(EDOC[EDOCI],(N~0&N[36:38:10]),ADR.[46:2]);                01356000
         IF CODETOG THEN DEBUG(N);                                      01357000
END EMITL;                                                              01358000
PROCEDURE EMITD(R, OP); VALUE R, OP; REAL R, OP;                        01359000
BEGIN                                                                   01360000
   BUMPADR;                                                             01361000
   PACK(EDOC[EDOCI], (R ~ OP & R[36:42:6]), ADR.[46:2]);                01362000
   IF CODETOG THEN DEBUG(-R);                                           01363000
END EMITD;                                                              01364000
PROCEDURE EMITDDT(B,A,X);  VALUE B,A,X;  INTEGER B,A,X ;                01364010
    BEGIN % DOES DIB B, DIA A, TRB X; HANDLES [B:A:X].                  01364020
    EMITD(B~B MOD 6+B DIV 6|8,DIB);  EMITD(A~A MOD 6+A DIV 6|8,DIA) ;   01364030
    EMITD(X~X,TRB);                                                     01364035
    END OF EMITDDT ;                                                    01364040
PROCEDURE EMITPAIR(L, OP); VALUE L, OP; INTEGER L, OP;                  01365000
BEGIN                                                                   01366000
   EMITL(L);                                                            01367000
   IF L.[37:2] = 1 THEN                                                 01368000
   BEGIN                                                                01369000
    IF ADR } 4087 THEN                                                  01370000
      BEGIN ADR ~ ADR+1; SEGOVF END;                                    01371000
      EMITO(XRT);                                                       01372000
   END;                                                                 01373000
   EMITO(OP);                                                           01374000
END EMITPAIR;                                                           01375000
PROCEDURE ADJUST;                                                       01376000
         WHILE ADR.[46:2] ! 3 DO EMITO(NOP);                            01377000
PROCEDURE EMITNUM(N); VALUE N; REAL N;                                  01378000
    BEGIN                                                               01379000
         DEFINE CPLUS = 1792#;                                          01380000
         IF N.[3:6] =0 AND ABS(N) < 1024 THEN                           01381000
    BEGIN                                                               01382000
         EMITL(N);                                                      01383000
         IF N < 0 THEN EMITO(SSN);                                      01384000
    END ELSE                                                            01385000
    BEGIN                                                               01386000
    IF ADR } 4079 THEN                                                  01387000
         BEGIN ADR ~ ADR+1; SEGOVF END;                                 01388000
         EMITOPDCLIT(CPLUS +  (ADR+1).[46:1] + 1);                      01389000
         EMITL(2);                                                      01390000
         EMITO(GFW);                                                    01391000
         ADJUST;                                                        01392000
         BUMPADR;                                                       01393000
         PACK(EDOC[EDOCI],N.[1:11],ADR.[46:2]);                         01394000
         BUMPADR;                                                       01395000
         PACK(EDOC[EDOCI],N.[12:12],ADR.[46:2]);                        01396000
         BUMPADR;                                                       01397000
         PACK(EDOC[EDOCI],N.[24:12],ADR.[46:2]);                        01398000
         BUMPADR;                                                       01399000
         PACK(EDOC[EDOCI],N.[36:12],ADR.[46:2]);                        01400000
         IF N.[36:12]=49 THEN %%% IF C-REL CONSTANT LOOKS LIKE AN XRT   01400400
         EMITO(NOP);          %%% THEN INSURE AGAINST P-BIT INTERRUPT.  01400600
         IF CODETOG THEN DEBUGWORD(N);                                  01401000
     END;                                                               01402000
END EMITNUM;                                                            01403000
PROCEDURE EMITNUM2(HI,LO);VALUE HI,LO; REAL HI,LO;                      01404000
    BEGIN                                                               01405000
    BOOLEAN B;  REAL I,N;                                               01406000
    LABEL Z,X;                                                          01407000
         DEFINE CPLUS = 1792#;                                          01408000
    IF HI=0 OR LO=0 THEN BEGIN EMITNUM(LO); EMITNUM(HI); GO Z END;      01408100
         ADJUST;                                                        01409000
    IF ADR } 4077 THEN                                                  01410001
         BEGIN ADR~ADR+1; SEGOVF; ADR~-1 END;                           01411000
         EMITOPDCLIT(CPLUS + 2);   EMITOPDCLIT(CPLUS + 1);              01412000
         EMITPAIR(3,GFW);                                               01413000
    X:   FOR I ~ 0 STEP 1 UNTIL 3 DO                                    01415000
    BEGIN                                                               01416000
         CASE I OF BEGIN                                                01417000
                        N ~ HI.[ 1:11];                                 01418000
                        N ~ HI.[12:12];                                 01419000
                        N ~ HI.[24:12];                                 01420000
                        N ~ HI.[36:12];                                 01421000
                   END CASE;                                            01422000
         BUMPADR; PACK(EDOC[EDOCI],N,ADR.[46:2]);                       01423000
    END;                                                                01424000
         IF CODETOG THEN DEBUGWORD(HI);                                 01425000
         IF NOT B THEN BEGIN B~TRUE; HI~LO; GO TO X; END;               01426000
         IF N=49 THEN   %%% IF C-REL CONSTANT LOOKS LIKE AN XRT         01426400
         EMITO(NOP) ;   %%% THEN INSURE AGAINST P-BIT INTERRUPT.        01426600
Z:                                                                      01426650
    END EMITNUM2;                                                       01427000
PROCEDURE EMITLINK(N); VALUE N; REAL N; % EMITS LINKS                   01428000
    BEGIN                                                               01429000
         FORMAT FF(X35,*(33(".")),A4,":",A1,"  LINK",X10,A4,"******") ; 01430000
         BUMPADR;                                                       01431000
         PACK(EDOC[EDOCI],N,ADR.[46:2]);                                01432000
         IF CODETOG THEN                                                01433000
         WRITALIST(FF,4,IF ADR{DEBUGADR THEN 1 ELSE -1,B2D(ADR.[36:10]),01434000
                   B2D(ADR.[46:2]),B2D(N),0,0,0,0) ;                    01435000
         IF DEBUGADR<ADR THEN DEBUGADR~ADR ;                            01435010
    END EMITLINK;                                                       01436000
PROCEDURE EMITSTORE(IX, EXP); VALUE IX, EXP; REAL IX, EXP;              01437000
BEGIN                                                                   01438000
   REAL E, VT;                                                          01439000
   P ~ REAL(ERRORTOG);                                                  01440000
   ERRORTOG ~ FALSE;                                                    01441000
   E ~ GET(GETSPACE(IX));                                               01442000
   IF NOT( (VT ~ E.SUBCLASS) = LOGTYPE EQV EXP = LOGTYPE) OR            01443000
      NOT(VT = COMPTYPE EQV EXP = COMPTYPE) THEN                        01444000
      BEGIN XTA ~ GET(IX+1); FLAG(86) END;                              01445000
   IF E.CLASS = VARID THEN                                              01446000
   BEGIN                                                                01447000
      IF BOOLEAN(E.FORMAL) OR BOOLEAN(E.CE) THEN                        01448000
      BEGIN                                                             01449000
         IF VT { LOGTYPE THEN                                           01450000
         BEGIN                                                          01451000
            IF VT = INTYPE AND EXP } REALTYPE THEN EMITPAIR(1, IDV);    01452000
            EMITN(IX);                                                  01453000
            EMITO(IF VT = INTYPE THEN ISD ELSE STD);                    01454000
            IF EXP } DOUBTYPE THEN EMITO(DEL);                          01455000
         END ELSE                                                       01456000
         BEGIN                                                          01457000
            EMITN(IX);                                                  01458000
            EMITPAIR(JUNK, STN);                                        01459000
            EMITO(STD);                                                 01460000
            IF EXP < DOUBTYPE THEN EMITL(0);                            01461000
            EMITL(1);                                                   01462000
            EMITPAIR(JUNK, LOD);                                        01463000
            EMITO(INX);                                                 01464000
            EMITO(STD);                                                 01465000
         END                                                            01466000
    END ELSE                                                            01467000
    BEGIN                                                               01468000
       IF VT = INTYPE AND EXP } REALTYPE THEN EMITPAIR(1, IDV);         01469000
       EMITPAIR(E.ADDR, IF VT = INTYPE THEN ISD ELSE STD);              01470000
       IF VT { LOGTYPE THEN                                             01471000
          IF EXP } DOUBTYPE THEN EMITO(DEL) ELSE ELSE                   01472000
       BEGIN                                                            01473000
          IF EXP < DOUBTYPE THEN EMITL(0);                              01474000
          EMITPAIR(E.ADDR+1, STD);                                      01475000
       END                                                              01476000
    END                                                                 01477000
END ELSE                                                                01478000
IF E.CLASS = ARRAYID THEN                                               01479000
BEGIN                                                                   01480000
   IF VT { LOGTYPE THEN                                                 01481000
   BEGIN                                                                01482000
      IF VT = INTYPE AND EXP } REALTYPE THEN EMITPAIR(1, IDV);          01483000
      IF EXP } DOUBTYPE THEN                                            01484000
      BEGIN                                                             01485000
         EMITO(XCH);                                                    01486000
         EMITO(DEL);                                                    01487000
      END;                                                              01488000
      EMITO(XCH);                                                       01489000
      EMITO(IF VT = INTYPE THEN ISD ELSE STD);                          01490000
   END ELSE                                                             01491000
   BEGIN                                                                01492000
      IF EXP } DOUBTYPE THEN                                            01493000
      BEGIN                                                             01494000
         EMITPAIR(JUNK, STD);                                           01495000
         EMITO(XCH);                                                    01496000
         EMITOPDCLIT(JUNK);                                             01497000
         EMITO(XCH);                                                    01498000
         EMITPAIR(JUNK, STN);                                           01499000
         EMITO(STD);                                                    01500000
         EMITL(1);                                                      01501000
         EMITPAIR(JUNK, LOD);                                           01502000
         EMITO(INX);                                                    01503000
         EMITO(STD);                                                    01504000
      END ELSE                                                          01505000
      BEGIN                                                             01506000
         EMITO(XCH);                                                    01507000
         EMITPAIR(JUNK, STN);                                           01508000
         EMITO(STD);                                                    01509000
         EMITL(0);                                                      01510000
         EMITL(1);                                                      01511000
         EMITPAIR(JUNK, LOD);                                           01512000
         EMITO(INX);                                                    01513000
         EMITO(STD);                                                    01514000
      END                                                               01515000
   END                                                                  01516000
END ELSE BEGIN XTA ~ GET(IX+1); FLAG(49) END;                           01517000
ERRORTOG ~ ERRORTOG OR BOOLEAN(P);                                      01518000
END EMITSTORE;                                                          01519000
PROCEDURE EMITB(A,C); VALUE A,C; REAL A; BOOLEAN C;                     01520000
BEGIN COMMENT  GENERATES LITC AND BRANCH FROM CURRENT ADR TO ADDRESS A. 01521000
IF THE BOOLEAN C IS TRUE THEN THE BRANCH IS CONDITIONAL.  BEOREF IS     01522000
TRUE IF THE BRANCH IS BACKWARDS;                                        01523000
BOOLEAN BEOREF;                                                         01524000
         REAL SEG;                                                      01525000
    IF ADR } 4086 THEN                                                  01526000
      BEGIN ADR ~ ADR+1; SEGOVF END;                                    01527000
         IF A < 0 THEN                                                  01528000
    BEGIN                                                               01529000
         IF BRANCHX>LBRANCH THEN FATAL(123);                            01530000
         BRANCHX ~ BRANCHES[LAX~BRANCHX];                               01531000
         BRANCHES[LAX] ~ -(ADR+1);                                      01532000
         EMITLINK(0);                                                   01533000
         EMITO(IF C THEN BFC ELSE BFW);                                 01534000
         EMITO(NOP);                                                    01534100
    END ELSE                                                            01535000
    BEGIN                                                               01536000
         SEG ~ A.SEGNO;                                                 01537000
         A ~ A.LINK;                                                    01538000
         BEOREF ~ ADR > A;                                              01539000
         IF A.[46:2] =0 THEN                                            01540000
    BEGIN                                                               01541000
         IF SEG > 0 AND SEG ! NSEG THEN                                 01542000
            EMITOPDCLIT(PRGDESCBLDR(2, 0, A.[36:10], SEG))              01543000
         ELSE                                                           01544000
         EMITL(ABS((ADR+2).[36:10] - A.[36:10]));                       01545000
         IF BEOREF THEN                                                 01546000
         EMITO( IF C THEN GBC ELSE GBW) ELSE                            01547000
         EMITO( IF C THEN GFC ELSE GFW);                                01548000
    END ELSE                                                            01549000
    BEGIN                                                               01550000
         EMITL(ABS(ADR + 3 - A));                                       01551000
         IF BEOREF THEN                                                 01552000
         EMITO(IF C THEN BBC ELSE BBW) ELSE                             01553000
         EMITO(IF C THEN BFC ELSE BFW);                                 01554000
    END;                                                                01555000
  END;                                                                  01556000
END EMITB;                                                              01557000
PROCEDURE EMITDESCLIT(N); VALUE N; REAL N;                              01558000
    BEGIN                                                               01559000
         IF N.[37:2] = 1 THEN                                           01560000
         BEGIN                                                          01561000
    IF ADR } 4087 THEN                                                  01562000
            BEGIN ADR ~ ADR+1; SEGOVF END;                              01563000
            EMITO(XRT);                                                 01564000
         END;                                                           01565000
         BUMPADR;                                                       01566000
         PACK(EDOC[EDOCI],(N~3&N[36:38:10]),ADR.[46:2]);                01567000
         IF CODETOG THEN DEBUG(N);                                      01568000
END EMITDESCLIT;                                                        01569000
PROCEDURE EMITOPDCLIT(N);       VALUE N; REAL N;                        01570000
    BEGIN                                                               01571000
         IF N.[37:2] = 1 THEN                                           01572000
         BEGIN                                                          01573000
    IF ADR } 4087 THEN                                                  01574000
            BEGIN ADR ~ ADR+1; SEGOVF END;                              01575000
            EMITO(XRT);                                                 01576000
         END;                                                           01577000
         BUMPADR;                                                       01578000
         PACK(EDOC[EDOCI],(N~2&N[36:38:10]),ADR.[46:2]);                01579000
         IF CODETOG THEN DEBUG(N);                                      01580000
END EMITOPDCLIT;                                                        01581000
PROCEDURE EMITLABELDESC(N); VALUE N; ALPHA N;                           01582000
BEGIN                                                                   01583000
   LABEL XIT;                                                           01584000
   REAL T,B,C,D ;                                                       01585000
   IF N ~ LBLSHFT(XTA~N) = 0 OR N = BLANKS THEN                         01586000
   BEGIN FLAG(135); GO TO XIT END;                                      01587000
   IF T ~ SEARCH(N) = 0 THEN                                            01588000
      T ~ ENTER(0 & LABELID[TOCLASS], N) ELSE                           01588100
      IF GET(T).CLASS ! LABELID THEN                                    01588200
      BEGIN FLAG(144); GO TO XIT END;                                   01588300
   IF XREF THEN ENTERX(N,0&LABELID[TOCLASS]);                           01588400
   IF B ~(C~GET(T+2)).BASE =0 THEN                                      01589000
     IF (D~GET(T)).SEGNO!0 THEN C.BASE~B~PRGDESCBLDR(2,0,D.ADDR DIV 4,  01589010
     D.SEGNO) ELSE                                                      01589020
         BEGIN BUMPPRT; C.BASE~B~PRTS END; PUT(T+2,C);                  01590000
   EMITL(B); EMITO(MKS);                                                01591000
   EMITDESCLIT(1536);        % F+0                                      01592000
   EMITOPDCLIT(1537);        % F+1                                      01593000
   EMITV(NEED(".LABEL", INTRFUNID));                                    01594000
   XIT:                                                                 01595000
END EMITLABELDESC;                                                      01596000
COMMENT TRACEBACK, OFLOWHANGERS, AND PRTSAVER ARE                       01597000
PROCEDURES USED TO ACCUMULATE FORMAT AND NAMELIST ARRAYS;               01598000
PROCEDURE TRACEBACK(M,DEX,PRT);  VALUE M,DEX,PRT; INTEGER M,DEX,PRT;    01599000
BEGIN INTEGER I,J; REAL C;                                              01600000
   IF (C~GET(M+2)).BASE ! 0 THEN                                        01601000
   BEGIN I ~ ADR;   ADR ~ C.BASE;                                       01602000
         DO BEGIN J ~ GIT(ADR);                                         01603000
                  ADR ~ ADR - 1;                                        01604000
                  EMITL(DEX);                                           01605000
                  EMITPAIR(PRT,LOD);                                    01606000
            END UNTIL ADR ~ J = 0;                                      01607000
            ADR ~ I;                                                    01608000
   END;                                                                 01609000
INFO[M.IR,M.IC].ADDR ~ PRT; PUT(M+2,0&DEX[TOBASE]);                     01610000
END TRACEBACK;                                                          01611000
PROCEDURE OFLOWHANGERS(I);   VALUE I;   INTEGER I;                      01612000
BEGIN INTEGER J;   LABEL XIT;                                           01613000
FOR J ~ 1 STEP 1 UNTIL MAXNBHANG DO                                     01614000
IF FNNHANG[J] = 0 THEN    %  MAKE AN ENTRY                              01615000
BEGIN FNNHANG[J] ~ I;                                                   01616000
      PUT(I+2,J);                                                       01617000
      GO TO XIT;                                                        01618000
END;                                                                    01619000
XTA ~ MAXNBHANG;   %  IF WE REACH HERE WERE HURTIN                      01620000
FLAG(91);                                                               01621000
XIT:                                                                    01622000
END OFLOWHANGERS;                                                       01623000
PROCEDURE PRTSAVER(M,SZ,ARY);   VALUE M,SZ;                             01624000
INTEGER M,SZ;   ARRAY ARY[0];                                           01625000
BEGIN INTEGER I; REAL INFA;                                             01626000
LABEL SHOW,XIT;                                                         01626100
IF (INFA~GET(M)) < 0 THEN   % PREVIOUSLY DEFINED                        01627000
BEGIN XTA ~ GET(M+1);                                                   01628000
      FLAG(20); GO TO XIT;                                              01629000
END;                                                                    01630000
IF I ~ INFA   .ADDR ! 0 THEN  %  PRT ASSIGNED AT OFLOW TIME             01631000
SHOW:                                                                   01631100
BEGIN I ~ PRGDESCBLDR(1,I,0,NXAVIL ~ NXAVIL + 1);                       01632000
      WRITEDATA(SZ,NXAVIL,ARY);                                         01633000
      FNNHANG[GET(M+2).SIZE] ~ 0;                                       01634000
END ELSE   %  ADD THIS ARRAY TO HOLD                                    01635000
BEGIN IF FNNPRT=0 THEN BEGIN BUMPPRT; FNNPRT~PRTS END;                  01636000
      IF FNNINDEX + SZ > DUMPSIZE THEN   %  ARRAY WONT FIT              01637000
      IF SZ > DUMPSIZE THEN   %  ARRAY WILL NEVER FIT                   01638000
      BEGIN BUMPPRT;FNNHANG[GET(M+2).SIZE]~0; TRACEBACK(M,0,I~PRTS);    01639000
            GO TO SHOW;                                                 01640000
      END ELSE   %  DUMP OUT CURRENT HOLDINGS                           01641000
      BEGIN FNNPRT ~ PRGDESCBLDR(1,FNNPRT,0,NXAVIL ~ NXAVIL + 1);       01642000
            WRITEDATA(FNNINDEX,NXAVIL,FNNHOLD);                         01643000
            FNNINDEX ~ 0; BUMPPRT; FNNPRT ~PRTS;                        01644000
      END;                                                              01645000
      FNNHANG[GET(M + 2).SIZE] ~0;                                      01646000
      TRACEBACK(M,FNNINDEX,FNNPRT);                                     01647000
      MOVEW(ARY,FNNHOLD[FNNINDEX],SZ.[36:6],SZ);                        01648000
      FNNINDEX ~ FNNINDEX + SZ;                                         01649000
END;                                                                    01650000
PUT(M,-GET(M));         %  ID NOW ASSIGNED                              01651000
XIT:                                                                    01651100
END PRTSAVER;                                                           01652000
PROCEDURE SEGOVF;                                                       01653000
    BEGIN                                                               01654000
   REAL I, T, A, J, SADR, INFC, LABPRT;                                 01655000
   REAL SAVINS;                                                         01655100
   FOR T ~ 1 STEP 1 UNTIL MAXNBHANG DO                                  01656000
IF J~FNNHANG[T]!0 THEN BEGIN BUMPPRT;TRACEBACK(J,FNNHANG[T]~0,PRTS) END;01657000
   SEGOVFLAG ~ TRUE;                                                    01661000
BUMPPRT;                                                                01662000
   IF PRTS.[37:2]=1 THEN BEGIN                                          01662300
        PACK(EDOC[EDOCI],(T~1&XRT[36:38:10]),ADR.[46:2]);               01662500
        IF CODETOG THEN DEBUG(T); ADR~ADR+1 END;                        01662700
   PACK(EDOC[EDOCI], (T~2&PRTS[36:38:10]), ADR.[46:2]);                 01663000
   IF CODETOG THEN DEBUG(T);                                            01664000
   ADR ~ ADR+1;                                                         01665000
   PACK(EDOC[EDOCI], (T~1&BFW [36:38:10]), ADR.[46:2]);                 01666000
   IF CODETOG THEN DEBUG(T);                                            01667000
         SADR ~ ADR;                                                    01668000
   T ~ PRGDESCBLDR(2, PRTS, 0, NXAVIL+1);                               01669000
   FOR I ~ 0 STEP 1 UNTIL SHX DO                                        01670000
   BEGIN T ~ STACKHEAD[I];                                              01671000
      WHILE T ! 0 DO                                                    01672000
      BEGIN IF (A~ GET(T)).CLASS = LABELID THEN                         01673000
         IF A > 0 THEN                                                  01674000
         BEGIN                                                          01675000
            ADR ~ A.ADDR;                                               01676000
            IF LABPRT ~ (INFC~GET(T+2)).BASE = 0 THEN                   01677000
            BEGIN                                                       01678000
            BUMPPRT; LABPRT~PRTS;                                       01679000
               PUT(T+2, INFC & PRTS[TOBASE]);                           01680000
            END;                                                        01681000
            WHILE ADR ! 0 DO                                            01682000
            BEGIN J ~ GIT(ADR); ADR ~ ADR-1;                            01683000
               SAVINS~GIT(ADR+2).[36:10];                               01683100
               EMITOPDCLIT(LABPRT);                                     01684000
               EMITO(SAVINS);                                           01684100
               ADR ~ J;                                                 01685000
            END;                                                        01686000
            INFO[T.IR,T.IC].ADDR ~ 0;                                   01687000
        END;                                                            01688000
        T ~ A.LINK;                                                     01689000
      END;                                                              01690000
  END;                                                                  01691000
  FOR I ~ 0 STEP 1 UNTIL LBRANCH DO                                     01692000
  IF T ~ - BRANCHES[I] > 0 AND T < 4096 THEN                            01693000
  BEGIN                                                                 01694000
     ADR ~ T-1;                                                         01695000
               SAVINS~GIT(ADR+2).[36:10];                               01695100
  BUMPPRT; EMITOPDCLIT(PRTS);                                           01696000
               EMITO(SAVINS);                                           01696100
     BRANCHES[I] ~ - (PRTS+4096);                                       01697000
  END;                                                                  01698000
        SEGMENT((SADR+4) DIV 4,NSEG,FALSE,EDOC);                        01699000
        SEGMENTSTART;                                                   01700000
  EMITO(NOP); EMITO(NOP);                                               01701000
  SEGOVFLAG ~ FALSE;                                                    01702000
END SEGOVF;                                                             01703000
PROCEDURE ARRAYDEC(I); VALUE I; REAL I;                                 01704000
    BEGIN     % DECLARES ARRAYS WHOSE INFO INDEX IS I                   01705000
         REAL PRT,LNK,J;                                                01706000
              LABEL XIT;                                                01706010
         BOOLEAN OWNID; REAL X;                                         01706100
IF DEBUGTOG THEN FLAGROUTINE("  ARRA","YDEC  ",TRUE );                  01706110
         PRT ~ GET(I).ADDR;                                             01707000
              IF LNK ~ GET(I+2).SIZE = 0 THEN GO TO XIT ;               01708000
         IF (OWNID ~ PRT < 1536 AND DATAPRT ! 0) THEN                   01708100
    BEGIN                                                               01708200
         EMITOPDCLIT(DATAPRT); EMITO(LNG);                              01708300
         EMITB(-1, TRUE); X ~ LAX;                                      01708400
    END;                                                                01708500
         EMITO(MKS);                                                    01709000
         EMITDESCLIT(PRT);   % STACK OR PRT ADDRESS                     01710000
         IF LNK { 1023 THEN                                             01711000
    BEGIN                                                               01712000
         IF OWNID THEN EMITL(0);       % LOWER BOUND                    01712100
         EMITL(LNK);    % ARRAY SIZE                                    01713000
         EMITL(1);      % ONE DIMENSION                                 01714000
    END                                                                 01715000
         ELSE                                                           01716000
    BEGIN                                                               01717000
         J ~ (LNK + 255) DIV 256;                                       01718000
         LNK ~ 256;   %INCLUDE ENTIRE ARRAY SIZE IN ESTIMATE      %512- 01719000
         IF OWNID THEN EMITL(0);       % FIRST LOWER BOUND              01719100
         EMITL(J);      % NUMBER OF ROWS                                01720000
         IF OWNID THEN EMITL(0);       % SECOND LOWER BOUND             01720100
         EMITL(256);    % SIZE OF EACH ROW                              01721000
         EMITL(2);      % TWO DIMENSIONS                                01722000
    END;                                                                01723000
         EMITL(1);      % ONE ARRAY                                     01724000
         EMITL(IF OWNID THEN 2 ELSE 0);  %OWN OR LOCAL                  01725000
         EMITOPDCLIT(5); % CALL BLOCK                                   01726000
         ARYSZ ~ ARYSZ + J + LNK;                                       01727000
         IF NOT(F2TOG OR OWNID) THEN                                    01728000
    BEGIN                                                               01729000
         F2TOG ~ TRUE;                                                  01730000
         EMITL(1);                                                      01731000
         EMITPAIR(FPLUS2,STD);%        F+2~TRUE                         01732000
    END;                                                                01733000
         IF OWNID THEN FIXB(X);                                         01733100
              XIT:                                                      01733105
IF DEBUGTOG THEN FLAGROUTINE("  ARRA","YDEC  ",FALSE) ;                 01733200
    END ARRAYDEC;                                                       01734000
REAL PROCEDURE SEARCH(E); VALUE E; REAL E;                              01735000
BEGIN REAL T; LABEL XIT;                                                01736000
   T ~ STACKHEAD[E MOD SHX];                                            01737000
   WHILE T ! 0 DO                                                       01738000
      IF INFO[(T+1).IR,(T+1).IC] = E THEN GO TO XIT                     01739000
      ELSE T ~ INFO[T.IR,T.IC].LINK;                                    01740000
   XIT: SEARCH ~ T;                                                     01741000
END SEARCH;                                                             01742000
INTEGER PROCEDURE GLOBALSEARCH(E); VALUE E; REAL E;                     01743000
BEGIN REAL T; LABEL XIT;                                                01744000
   T ~ GLOBALSTACKHEAD[E MOD GHX];                                      01745000
   WHILE T ! 0 DO                                                       01746000
      IF INFO[(T+1).IR,(T+1).IC] = E THEN GO TO XIT                     01747000
      ELSE T ~ INFO[T.IR,T.IC].LINK;                                    01748000
   XIT: GLOBALSEARCH ~ T;                                               01749000
END GLOBALSEARCH;                                                       01750000
PROCEDURE PURGEINFO;                                                    01751000
BEGIN REAL J;                                                           01752000
   FLAG(13);                                                            01753000
   FOR J ~ 0 STEP 1 UNTIL SHX DO STACKHEAD[J] ~ 0;                      01754000
   NEXTINFO ~ 2;                                                        01755000
   NEXTCOM ~ 0;                                                         01756000
   END;                                                                 01757000
INTEGER PROCEDURE ENTER(W, E); VALUE W, E; ALPHA W, E;                  01758000
BEGIN REAL J;                                                           01759000
   IF GLOBALNEXTINFO { NEXTINFO THEN PURGEINFO;                         01760000
   W.LINK ~ STACKHEAD[J ~ E MOD SHX];                                   01761000
   STACKHEAD[J] ~ ENTER ~ J ~ NEXTINFO;                                 01762000
   INFO[J.IR,J.IC] ~ W;                                                 01763000
   INFO[(J~J+1).IR,J.IC] ~ E;                                           01764000
   INFO[(J~J+1).IR,J.IC] ~ 0;                                           01765000
   NEXTINFO ~ NEXTINFO + 3;                                             01766000
END ENTER;                                                              01767000
INTEGER PROCEDURE GLOBALENTER(W, E); VALUE W, E; ALPHA W, E;            01768000
BEGIN REAL J;                                                           01769000
   IF GLOBALNEXTINFO { NEXTINFO THEN PURGEINFO;                         01770000
   W.LINK ~ GLOBALSTACKHEAD[J ~ E MOD GHX];                             01771000
   GLOBALSTACKHEAD[J] ~ GLOBALENTER ~ J ~ GLOBALNEXTINFO;               01772000
   INFO[J.IR,J.IC] ~ W;                                                 01773000
   INFO[(J~J+1).IR,J.IC] ~ E;                                           01774000
   INFO[(J~J+1).IR,J.IC] ~ 0;                                           01775000
   GLOBALNEXTINFO ~ GLOBALNEXTINFO - 3;                                 01776000
END GLOBALENTER;                                                        01777000
PROCEDURE LABELBRANCH(K, C); VALUE K, C; REAL K; BOOLEAN C;             01778000
BEGIN REAL TS,T,I,X;                                                    01779000
DEFINE LABL = K#;                                                       01780000
COMMENT LABELBRANCH GENERATES A "LITC ..." AND "BRANCH" FROM THE        01781000
CURRENT ADDRESS TO LABEL K.   IF THE BOOLEAN C IS TRUE                  01782000
THE BRANCH IS CONDITIONAL.  IF THE LABEL HAS NOT BEEN ENCOUNTERED       01783000
THEN THE APPROPRIATE LINKAGE IS MADE;                                   01784000
   LABEL XIT;                                                           01785000
    IF ADR } 4086 THEN                                                  01786000
   BEGIN ADR ~ ADR+1; SEGOVF END;                                       01787000
   IF LABL ~ LBLSHFT(XTA~LABL) { 0 OR LABL = BLANKS THEN                01788000
   BEGIN FLAG(135); GO TO XIT END;                                      01789000
   IF T ~ SEARCH(LABL) ! 0 THEN                                         01790000
   BEGIN TS ~ (I ~ GET(T)).ADDR;                                        01791000
      IF I.CLASS ! LABELID THEN BEGIN FLAG(144); GO TO XIT END;         01791100
      IF I > 0 THEN                                                     01792000
         BEGIN EMITLINK(TS);                                            01793000
               EMITO(IF C THEN BFC ELSE BFW);                           01794000
            PUT(T,I&(ADR-1)[TOADDR]);                                   01795000
               EMITO(NOP);                                              01795100
         END ELSE                                                       01796000
         IF I.SEGNO = NSEG THEN EMITB(TS, C) ELSE                       01799000
    BEGIN IF TS~(X~GET(T+2)).BASE = 0 THEN                              01800000
       X.BASE ~ TS ~ PRGDESCBLDR(2,0,(I.ADDR).[36:10],I.SEGNO);         01801000
       PUT(T+2,X);                                                      01802000
       EMITOPDCLIT(TS);                                                 01803000
       EMITO(IF C THEN BFC ELSE BFW);                                   01804000
    END;                                                                01805000
END ELSE                                                                01806000
    BEGIN                                                               01807000
       IF ADR < 0 THEN EMITO(NOP);                                      01808000
       EMITLINK(0);                                                     01809000
          EMITO( IF C THEN BFC ELSE BFW);                               01810000
          T ~ ENTER(0 & LABELID[TOCLASS] & (ADR-1)[TOADDR], LABL);      01811000
          EMITO(NOP);                                                   01811100
    END;                                                                01812000
    IF XREF THEN ENTERX(LABL,0&LABELID[TOCLASS]);                       01812100
    XIT:                                                                01813000
END LABELBRANCH;                                                        01814000
PROCEDURE DATASET;       % SCANS CONSTANTS IN BLOCK DATA                01815000
    BEGIN                                                               01816000
         REAL LST,CUR,LTYP,CTYP,SIZ,RPT;                                01817000
         REAL CUD;                                                      01818000
         BOOLEAN SGN;                                                   01819000
                                                                        01820000
                                                                        01821000
         DEFINE TYP = GLOBALNEXT#,                                      01822000
                TYPC = 18:33:15#;                                       01823000
         LABEL XIT,ERROR,DPP,SPP,CPP,COMM,S;                            01824000
IF DEBUGTOG THEN FLAGROUTINE("  DATA","SET   ",TRUE) ;                  01825000
         DATATOG ~ TRUE; FILETOG ~ TRUE;                                01826000
         SCAN;                                                          01827000
         LSTS ~ -1; LTYP ~77;                                           01828000
    S:   IF TYP = PLUS OR (SGN ~ TYP = MINUS ) THEN SCAN;               01829000
         IF TYP = NUM THEN                                              01830000
    BEGIN                                                               01831000
         IF NUMTYPE = STRINGTYPE AND STRINGSIZE > 1 THEN                01832000
    BEGIN                                                               01833000
         IF LTYP ! 77 THEN                                              01834000
              BEGIN  % NOT FIRST ENTRY-PUSH DOWN PRIOR NUMBER           01835000
                   IF LSTS+2 > LSTMAX THEN                              01836000
                   BEGIN FLAG(127); GO TO ERROR END;                    01837000
                   LSTT[LSTS~LSTS+1] ~ RPT&LTYP[TYPC];                  01838000
                   LSTT[LSTS~LSTS+1] ~ LST;                             01839000
                   LTYP ~ 77;                                           01840000
              END;                                                      01841000
                                                                        01841100
         IF LSTS + STRINGSIZE > LSTMAX THEN                             01842000
         BEGIN FLAG(127); GO TO ERROR END;                              01843000
                   LSTT[LSTS~LSTS+1] ~ STRINGSIZE & STRINGTYPE[TYPC]    01844000
                                          & SIZ[3:33:15];               01844100
                   MOVEW(STRINGARRAY,LSTT[LSTS~LSTS+1],                 01845000
                         STRINGSIZE.[36:6],STRINGSIZE);                 01846000
         LSTS ~ LSTS + STRINGSIZE -1;                                   01846100
         SCAN;                                                          01847000
         GO TO COMM;                                                    01848000
    END;                                                                01849000
              % GOT NUMBER                                              01850000
         IF NUMTYPE = STRINGTYPE THEN                                   01851000
    BEGIN                                                               01851100
         FNEXT ~ STRINGARRAY[0];                                        01851200
         NUMTYPE ~ INTYPE;                                              01851300
         IF SIZ = 0 THEN SIZ ~ 1;                                       01851400
    END;                                                                01851500
         CUR ~ IF SGN THEN -FNEXT ELSE FNEXT;                           01852000
         CTYP ~ NUMTYPE; CUD ~ DBLOW;                                   01853000
                                                                        01854000
         SCAN;                                                          01855000
         IF TYP = COMMA OR TYP = SLASH THEN                             01856000
    BEGIN                                                               01857000
         IF SIZ = 0 THEN SIZ ~ 1;                                       01857100
         IF CTYP = DOUBTYPE THEN                                        01858000
    BEGIN                                                               01859000
    DPP: IF LTYP ! 77 THEN                                              01860000
              BEGIN                                                     01861000
                   IF LSTS+2 > LSTMAX THEN                              01862000
                   BEGIN FLAG(127); GO TO ERROR END;                    01863000
                   LSTT[LSTS~LSTS+1] ~ RPT&LTYP[TYPC];                  01864000
                   LSTT[LSTS~LSTS+1] ~ LST;                             01865000
                   LTYP ~ 77;                                           01866000
              END;                                                      01867000
          IF LSTS+3 > LSTMAX THEN BEGIN FLAG(127); GO TO ERROR END;     01868000
          LSTT[LSTS~LSTS+1] ~ SIZ&DOUBTYPE[TYPC];                       01869000
          LSTT[LSTS~LSTS+1] ~ CUR;                                      01870000
          LSTT[LSTS~LSTS+1] ~ CUD;                                      01871000
          GO TO COMM;                                                   01872000
     END;                                                               01873000
               % SINGLE PRECISION                                       01874000
     SPP:                                                               01875000
          IF LTYP = 77 THEN                                             01876000
               BEGIN                                                    01877000
                    LST ~ CUR;                                          01878000
                    LTYP ~ CTYP;                                        01879000
                    RPT ~ SIZ;                                          01880000
                    GO TO COMM;                                         01881000
               END;                                                     01882000
          IF LTYP = CTYP THEN                                           01883000
          IF REAL(BOOLEAN(CUR) EQV BOOLEAN(LST)) = REAL(NOT FALSE) THEN 01883100
               BEGIN                                                    01884000
                    RPT ~ RPT + SIZ;                                    01885000
                    GO TO COMM;                                         01886000
               END;                                                     01887000
          IF LSTS+2 > LSTMAX THEN BEGIN FLAG(127); GO TO ERROR END;     01888000
          LSTT[LSTS~LSTS+1] ~ RPT&LTYP[TYPC];                           01889000
          LSTT[LSTS~LSTS+1] ~ LST;                                      01890000
          RPT ~ SIZ;                                                    01891000
          LST ~ CUR; LTYP ~ CTYP;                                       01892000
          GO TO COMM;                                                   01893000
     END;                                                               01894000
               % TYP ! COMMA - CHECK FOR *                              01895000
          IF TYP ! STAR THEN BEGIN FLAG(125); GO TO ERROR END;          01896000
          IF CTYP ! INTYPE THEN BEGIN FLAG(113); GO TO ERROR END;       01897000
          IF SIZ ! 0 OR SIZ ~ CUR { 0 THEN                              01898000
          BEGIN FLAG(64); GO TO ERROR END;                              01899000
          SCAN; GO TO S;                                                01900000
     END;                                                               01912000
               % TYP ! NUM AT LABEL S                                   01913000
          IF SIZ = 0 THEN SIZ ~ 1;                                      01913050
          IF NAME = "T     " OR NAME = "F     " THEN                    01913100
          BEGIN                                                         01913200
               CUR ~ REAL(NAME = "T     ");                             01913300
               CTYP ~ LOGTYPE;                                          01913400
               SCAN; GO TO SPP;                                         01913500
          END;                                                          01913600
               IF TYP ! LPAREN THEN BEGIN FLAG(64); GO TO ERROR END;    01914000
                                                                        01915000
          CPP:      % COMPLEX                                           01916000
               IF LTYP ! 77 THEN                                        01917000
                    BEGIN                                               01918000
                         IF LSTS+2 > LSTMAX THEN                        01919000
                         BEGIN FLAG(127); GO TO ERROR END;              01920000
                         LSTT[LSTS~LSTS+1] ~ RPT&LTYP[TYPC];            01921000
                         LSTT[LSTS~LSTS+1] ~ LST;                       01922000
                         LTYP ~ 77;                                     01923000
                    END;                                                01924000
               SCAN;                                                    01925000
               IF TYP = PLUS OR (SGN~TYP=MINUS) THEN SCAN;              01926000
               IF TYP ! NUM OR NUMTYPE > REALTYPE THEN                  01927000
               BEGIN FLAG(64); GO TO ERROR END;                         01928000
               IF LSTS+2 > LSTMAX THEN BEGIN FLAG(127); GO TO ERROR END;01929000
               LSTT[LSTS~LSTS+1] ~ SIZ&COMPTYPE[TYPC];                  01930000
               LSTT[LSTS~LSTS+1] ~ IF SGN THEN -FNEXT ELSE FNEXT;       01931000
               SCAN;                                                    01932000
               IF TYP ! COMMA THEN BEGIN FLAG(114); GO TO ERROR END;    01933000
               SCAN;                                                    01934000
               IF TYP = PLUS OR (SGN ~ TYP = MINUS) THEN SCAN;          01935000
               IF TYP ! NUM OR NUMTYPE > REALTYPE THEN                  01936000
               BEGIN FLAG(64); GO TO ERROR END;                         01937000
               LSTT[LSTS~LSTS+1]~IF SGN THEN - FNEXT ELSE FNEXT ;       01938000
               SCAN;                                                    01939000
               IF TYP ! RPAREN THEN BEGIN FLAG(108); GO TO ERROR END;   01940000
               SCAN;                                                    01941000
          COMM:                                                         01942000
               SIZ ~ 0;                                                 01942100
               IF TYP = COMMA THEN BEGIN SCAN; GO TO S; END;            01943000
               IF TYP = SLASH THEN GO TO XIT;                           01944000
               FLAG(126);                                               01945000
          ERROR:                                                        01946000
               LSTS ~ 0;                                                01947000
               WHILE TYP ! COMMA AND TYP ! SLASH AND TYP ! SEMI DO SCAN;01948000
               IF TYP = COMMA THEN GO TO COMM;                          01949000
          XIT:                                                          01950000
               IF LTYP ! 77 THEN                                        01951000
                    BEGIN                                               01952000
                      IF LSTS+2>LSTMAX THEN BEGIN FLAG(127); LSTS~0 END;01953000
                         LSTT[LSTS~LSTS+1] ~ RPT&LTYP[TYPC];            01954000
                         LSTT[LSTS~LSTS+1] ~ LST;                       01955000
                    END;                                                01956000
               IF LSTS+1 > LSTMAX THEN BEGIN FLAG(127); LSTS~0 END;     01957000
               LSTT[LSTS~LSTS+1]~0;                                     01958000
IF DEBUGTOG THEN FLAGROUTINE("  DATA","SET   ",FALSE);                  01959000
               DATATOG ~ FALSE; FILETOG ~ FALSE;                        01960000
END DATASET;                                                            01961000
ALPHA PROCEDURE CHECKDO;                                                01962000
BEGIN ALPHA X, T; INTEGER N;                                            01963000
STREAM PROCEDURE CKDO(A, ID, LAB);                                      01964000
BEGIN                                                                   01965000
   SI ~ A; SI ~ SI+4; DI ~ LAB; DI ~ DI+2;                              01966000
   5(IF SC } "0" THEN DS ~ CHR ELSE JUMP OUT);                          01967000
   DI ~ ID; DI ~ DI+2;                                                  01968000
   6(IF SC = ALPHA THEN DS ~ CHR ELSE JUMP OUT);                        01969000
END CKDO;                                                               01970000
   IF (XTA~HOLDID[0]).[12:24] = "FILE" THEN FLOG(37) ELSE               01971000
         IF XTA.[12:12] ! "DO" THEN FLOG(17) ELSE                       01971010
   BEGIN                                                                01972000
      X ~ T ~ BLANKS;                                                   01973000
      CKDO(HOLDID[0], X, T);                                            01974000
         IF X=BLANKS THEN FLOG(105);                                    01974500
      IF T ~ LBLSHFT(T) < 0 OR T = BLANKS THEN FLOG(17) ELSE            01975000
      TEST ~ NEED(T, LABELID);                                          01976000
      DOLAB[DT]~ T;                                                     01977000
      IF XREF THEN ENTERX(T,0&LABELID[TOCLASS]);                        01977100
         IF GET(TEST) < 0 THEN   %  TEST FOR PREV DEFINITION            01978000
      BEGIN                                                             01979000
         XTA ~ GET(TEST+1);                                             01980000
         FLAG(15);                                                      01981000
         DT ~ DT-1;                                                     01982000
      END;                                                              01983000
      IF N ~ SEARCH(X) = 0 THEN                                         01984000
      N~ENTER(TIPE[IF T~X.[12:6]!"0" THEN T ELSE 12],X);                01985000
      CHECKDO ~ GETSPACE(N);                                            01987000
      IF XREF THEN ENTERX(X,1&GET(N) [15:15:9]);                        01987100
      IF (X~GET(N)).SUBCLASS > REALTYPE OR X.CLASS ! VARID THEN         01988000
      BEGIN XTA ~ GET(N+1); FLAG(84) END;                               01989000
      IF GET(FX1).CLASS = UNKNOWN THEN PUT(FX1+1, "......");            01990000
   END;                                                                 01991000
END CHECKDO;                                                            01992000
PROCEDURE FIXB(N); VALUE N; REAL N;                                     01993000
BEGIN                                                                   01994000
   REAL T, U, FROM;                                                     01995000
   LABEL XIT, BIGJ;                                                     01996000
IF DEBUGTOG THEN FLAGROUTINE("    FI","XB    ",TRUE);                   01996010
   IF N } 10000 THEN FROM ~ N-10000 ELSE                                01997000
   IF FROM ~ - BRANCHES[N] > 4095 THEN                                  01998000
   BEGIN                                                                01999000
      ADJUST;                                                           02000000
      T ~ PRGDESCBLDR(2, FROM.LINK, (ADR+1).[36:10], NSEG);             02001000
      GO TO XIT;                                                        02002000
   END;                                                                 02003000
T ~ ADR;   ADR ~ FROM - 1;                                              02004000
IF (T + 1).[46:2] = 0 THEN GO TO BIGJ;                                  02005000
IF (U ~ T - 2 - ADR) { 1023 THEN EMITL(U) ELSE                          02006000
BEGIN ADR ~ T;   ADJUST;  T ~ ADR;  ADR ~ FROM - 1;                     02007000
BIGJ: EMITL((T+1).[36:10] - (ADR+2).[36:10]);                           02008000
      EMITO(IF BOOLEAN(GIT(FROM + 1).[36:1]) THEN GFW ELSE GFC);        02009000
END;                                                                    02010000
ADR ~ T;                                                                02011000
   XIT:                                                                 02012000
   IF N < 10000 THEN BEGIN                                              02013000
   BRANCHES[N] ~ BRANCHX;                                               02014000
   BRANCHX ~ N;                                                         02015000
   END;                                                                 02016000
IF DEBUGTOG THEN FLAGROUTINE("    FI","XB    ",FALSE);                  02016010
END FIXB;                                                               02017000
PROCEDURE DATIME;            % PRODUCES HEADING LINE FOR LISTING.       02018000
    BEGIN                                                               02019000
    INTEGER D;                                                          02020000
   FORMAT T(X9,"B 5 7 0 0    F O R T R A N    C O M P I L A T I O N   ",02021000
"XVI.0"                                                                 02022000
           ,".",A2,".",A8,"DAY, ".2(A2,"/"),A2,".",A2,":",A2," H."/);   02022500
    WRITALIST(T,7,                                                      02024000
     "16"                                                          %999-02025000
              ,TIME(6),(D~TIME(5)).[12:12],D.[24:12],D.[36:12],         02026000
            D~(D~RTI DIV 216000) MOD 10+D DIV 10|64,                    02027000
            D~(D~RTI DIV 3600 MOD 60) MOD 10+D DIV 10|64,0) ;           02028000
    IF D~LINE.TYPE=10 OR D=12 OR D=13 THEN                              02029000
         BEGIN                                                          02030000
         LOCK(LINE);  LINE.AREAS~0;  LINE.AREASIZE~0 ;                  02031000
         IF D ! 12 THEN LINE.TYPE~12;  SPACE(LINE,2) ;                  02032000
         END;                                                           02033000
    FIRSTCALL~FALSE ;                                                   02034000
    END DATIME;                                                         02039000
PROCEDURE PRINTCARD;                                                    02040000
BEGIN                                                                   02041000
   STREAM PROCEDURE MOVE(P, Q, A); VALUE A, Q;                          02042000
   BEGIN                                                                02043000
      SI ~ Q; DI ~ P;                                                   02044000
      DS ~ CHR;                                                         02045000
      DI ~ DI+11; SI ~ LOC A;                                           02046000
      DS ~ 4 DEC;                                                       02047000
   END MOVE;                                                            02048000
   STREAM PROCEDURE MOVEBACK(P);                                        02049000
   BEGIN DI ~ P; DS ~ LIT "]" END;                                      02050000
    MOVE (CRD[9],BUFL,(ADR+1).[36:10]);                                 02051000
   IF FIRSTCALL THEN DATIME;                                            02052000
   IF UNPRINTED THEN WRITAROW(15,CRD) ;                                 02053000
    MOVEBACK(CRD[9]);                                                   02054000
    IF SEQERRORS THEN WRITAROW(14,ERRORBUFF) ;                          02054010
END PRINTCARD;                                                          02055000
BOOLEAN PROCEDURE READACARD; FORWARD;                                   02056000
PROCEDURE FILEOPTION;  FORWARD;                                         02058000
BOOLEAN PROCEDURE LABELR;                                               02059000
BEGIN                                                                   02060000
LABEL XIT, LOOP;                                                        02061000
                                                                        02062000
BOOLEAN STREAM PROCEDURE CHECK(CD, LAB);                                02063000
BEGIN LABEL XIT; LOCAL T1;                                              02064000
   SI ~ CD;                                                             02065000
   IF SC ! " " THEN IF SC < "0" THEN                                    02066000
         BEGIN DI ~ LAB;   DI ~ DI + 2;                                 02067000
               DS ~ 6 CHR;  GO TO XIT;                                  02068000
         END;                                                           02069000
   DI ~LOC T1; DS ~ 6 LIT " "; DI ~ DI -6;                              02070000
   5(IF SC } "0" THEN DS ~ CHR ELSE SI ~ SI+1);                         02071000
   DI ~LAB; DI ~DI + 2; SI ~ LOC T1;                                    02072000
    5(IF SC ! "0" THEN JUMP OUT; SI ~ SI + 1);                          02073000
   5(IF SC } "0" THEN DS ~ CHR ELSE JUMP OUT);                          02074000
   TALLY ~ 1;                                                           02075000
   XIT: CHECK ~ TALLY;                                                  02076000
END CHECK;                                                              02077000
BOOLEAN STREAM PROCEDURE BLANKCARD(CD);                                 02077100
BEGIN   LABEL XIT;                                                      02077200
   SI ~ CD;                                                             02077300
   2(36( IF SC ! " " THEN JUMP OUT 2 TO XIT ELSE SI ~ SI + 1));         02077400
   TALLY ~ 1;                                                           02077600
   XIT: BLANKCARD ~ TALLY;                                              02077700
END BLANKCARD;                                                          02077800
   LOOP:                                                                02078000
   LABL ~ BLANKS;                                                       02079000
   IF LABELR ~ NOT READACARD THEN GO TO XIT;                            02080000
      IF NOT CHECK(CRD[0],LABL) THEN                                    02081000
   BEGIN IF LABL = "FILE  " THEN FILEOPTION ELSE                        02082000
      BEGIN IF LISTOG THEN PRINTCARD;                                   02083000
         IF (XTA ~ LABL).[12:6] ! "C" THEN FLAG(135);                   02083100
      END;                                                              02083200
      GO TO LOOP;                                                       02084000
   END;                                                                 02085000
   IF ENDSEGTOG THEN IF BLANKCARD(CRD) THEN                             02086000
      BEGIN IF LISTOG THEN PRINTCARD;  GO TO LOOP END ELSE              02086500
   BEGIN SEGMENTSTART;                                                  02087000
     IF LISTOG THEN PRINTCARD;                                          02088000
     IF LABL = BLANKS THEN GO TO XIT;                                   02089000
   END ELSE                                                             02090000
   BEGIN                                                                00091000
         IF LABL = BLANKS THEN                                          02092000
          BEGIN IF LISTOG THEN PRINTCARD; GO TO XIT END;                02093000
         IF ADR > 0 THEN ADJUST;                                        02094000
         IF LISTOG THEN PRINTCARD;                                      02095000
   END;                                                                 02096000
   XIT:                                                                 02116000
END LABELR;                                                             02117000
PROCEDURE FILEOPTION;                                                   02118000
BEGIN COMMENT  THIS PROCEDURE PROCESSES THE OPTIONAL FILE CONTROL CARD. 02119000
THE WORD "FILE" APPEARS IN COL. 1 - 4.  COL. 5 AND 6 ARE BLANK.         02120000
#1 BELOW IS REQUIRED, OTHER ENTRIES MAY BE AS SPARSE AS DESIRED.        02121000
1. FILE  <NUM> = <MULTI-FILE ID> / <FILE ID>                            02122000
               OR                                                       02123000
   FILE  <NUM> = <FILE ID>                                              02124000
      THE FOLLOWING "/" IS A DOCUMMENTARY OR.                           02125000
      THE SEQUENCE OF RESERVED WORDS MUST BE MAINTAINED.                02126000
2. UNIT=PRINT/READER/PUNCH/DISK/TAPE7/TAPE9/REMOTE   (UNIT DESIGNATE).  02127000
3. UNLABELED     (FOR UNLABELED TAPES)                                  02128000
4. ALPHA     (FOR ALPHA RECORDING MODE)                                 02129000
5. BCL     (IGNORED,    FOR 3500 USE)                                   02130000
6. FIXED   (IGNORED,    FOR 3500 USE)                                   02131000
7. SAVE = <NUM>     (SAVE FACTOR IN DAYS)                               02132000
8. LOCK     (LOCK FILE AT EOJ)                                          02133000
9. RANDOM/SERIAL/UPDATE     (DISK USE)                                  02134000
10. AREA = <NUM>     (DISK RECORDS/ROW)                                 02135000
11. BLOCKING = <NUM>     (RECORD PER BLOCK)                             02136000
12. RECORD = <NUM>     (RECORD SIZE)                                    02137000
13. BUFFER = <NUM>     (# OF BUFFERS)                                   02138000
14. WORKAREA      (IGNORED, FOR 3500)  ;                                02139000
ALPHA P,KEEP;   BOOLEAN TOG,CA,TS;   LABEL XIT;                         02140000
COMMENT   INXFIL = INFC.ADINFO,  MULTI FILE ID = FILEINFO[1,INXFIL],    02141000
       FILE ID = FILEINFO[2,INXFIL],  DISK RECORDS = FILEINFO[3,INXFIL],02142000
       FILEINFO[0,INXFIL] FROM RIGHT TO LEFT IS;                        02143000
INTEGER  %  NAME           USE                            BITS          02144000
            BUFF,       %  # BUFFERS                        6           02145000
            RECORD,     %  RECORD SIZE                     12           02146000
            BLOCK,      %  BLOCK SIZE                      12           02147000
            SAVER,      %  SAVE FACTOR                     12           02148000
            SPIN,       %  REW & LOCK @ EOJ                 2           02149000
            ALPH;       %  RECORDING MODE                   1           02150000
PROCEDURE FETCH;                                                        02151000
BEGIN SCAN;  XTA ~ SYMBOL;                                              02152000
      IF NEXT=COMMA OR NEXT=MINUS THEN                                  02153000
      BEGIN SCAN;  XTA ~ SYMBOL;                                        02154000
            IF NEXT ! ID THEN  FLOG(37);                                02155000
      END;                                                              02156000
END FETCH;                                                              02157000
INTEGER STREAM PROCEDURE MAKEINT(XTA);                                  02158000
BEGIN LABEL LOOP;  LOCAL T;                                             02159000
SI ~ XTA;  SI ~ SI + 2;                                                 02160000
LOOP:  IF SC } "0" THEN                                                 02161000
     BEGIN TALLY ~ TALLY + 1;  SI ~ SI + 1; GO TO LOOP END;             02162000
T ~ TALLY; SI ~ XTA;  SI ~ SI + 2;  DI ~ LOC MAKEINT;  DS ~ T OCT;      02163000
END MAKEINT;                                                            02164000
INTEGER PROCEDURE REPLACEMENT;                                          02165000
BEGIN                                                                   02166000
FETCH;   IF NEXT = EQUAL THEN                                           02167000
BEGIN FETCH;  IF XTA.[12:6] { 11 THEN BEGIN REPLACEMENT ~ MAKEINT(XTA); 02168000
      FETCH END ELSE FLOG(37);                                          02169000
END ELSE FLOG(37);                                                      02170000
END REPLACEMENT;                                                        02171000
INTEGER STREAM PROCEDURE SRI7(S);                                       02172000
BEGIN SI ~ S;  DI ~ LOC SRI7;                                           02173000
      SI ~ SI + 2;  DI ~ DI + 1;     DS ~ 7 CHR;                        02174000
END SRI7;                                                               02175000
COMMENT * * * * * START OF CODE * * * * ;                               02176000
IF DEBUGTOG THEN FLAGROUTINE(" FILEO","PTION ", TRUE);                  02176010
ERRORTOG ~ FALSE;                                                       02176100
IF LISTOG THEN PRINTCARD;                                               02177000
XTA ~ "FILE  ";                                                         02178000
IF NSEG ! 0 THEN FLAG(60);                                              02179000
IF INXFIL ~ INXFIL + 1 > MAXOPFILES THEN                                02180000
BEGIN FLAG(59); GO TO XIT END;                                          02181000
BUMPPRT;                                                                02182000
MAXFILES ~ MAXFILES + 1;                                                02183000
FILETOG ~ TRUE;  SCN ~ 1;   %  START SCAN MAINTAINENCE                  02184000
FETCH;  IF XTA.[12:6] > 11 THEN BEGIN FLAG(37);  GO TO XIT END;         02185000
     IF XTA.[12:6] = 0 THEN BEGIN FLOG(037);  GO TO XIT END;            02185010
IF T ~ GLOBALSEARCH(P ~ 0&"."[12:42:6]&XTA[18:12:30]) ! 0 THEN FLAG(20) 02186000
ELSE BEGIN P~ GLOBALENTER(-0&PRTS[TOADDR]&FILEID[TOCLASS],P);           02187000
           PUT(P+2,GET(P+2)&INXFIL[TOADINFO]);                          02188000
           IF XREF THEN ENTERX(XTA &1[TOCE],1&FILEID[TOCLASS]);         02188100
     END;                                                               02189000
INFC ~ GET(P + 2);                                                      02190000
FETCH;   IF NEXT = EQUAL THEN FETCH ELSE                                02191000
   BEGIN FLOG(37);  GO TO XIT;  END;                                    02192000
IF NEXT = SEMI THEN                                                     02193000
BEGIN FLAG(37); GO TO XIT END                                           02194000
    ELSE FILEINFO[2,INXFIL] ~ SRI7(ACCUM[1]);                           02195000
FETCH;   IF NEXT = SLASH THEN                                           02196000
      BEGIN FILEINFO[1,INXFIL] ~ FILEINFO[2,INXFIL];   %  MULTI FILE ID 02197000
            FETCH;                                                      02198000
            IF NEXT = SEMI THEN BEGIN FLAG(37);   GO TO XIT;  END       02199000
                 ELSE FILEINFO[2,INXFIL] ~ SRI7(ACCUM[1]);              02200000
            FETCH;                                                      02201000
      END;                                                              02202000
IF XTA = "UNIT  " THEN                                                  02203000
BEGIN                                                                   02204000
   FETCH;                                                               02205000
   IF NEXT = EQUAL THEN FETCH ELSE FLOG(37);                            02206000
      INFC.LINK ~ KEEP ~ (IF TOG ~ XTA = "PRINT "                       02207000
                                   OR XTA = "PRINTE" THEN 18 ELSE       02208000
                      IF CA ~ TOG ~ XTA = "READ  "                      02209000
                                   OR XTA = "READER" THEN 2 ELSE        02210000
                      IF CA ~ TOG ~ XTA = "PUNCH " THEN 0 ELSE          02211000
                            IF TOG ~ XTA = "DISK  " THEN 12 ELSE        02212000
                            IF TOG ~ XTA = "TAPE  "                     02213000
                                   OR XTA = "TAPE7 " THEN 2 ELSE        02214000
                                  IF TOG ~ XTA = "PAPER " THEN 8 ELSE   02214100
                      IF CA ~TOG~XTA= "REMOTE" THEN 19 ELSE             02214500
                            IF TOG ~ XTA = "TAPE9 " THEN 2 ELSE 2);     02215000
   IF TOG THEN FETCH ELSE FLOG(37)                                      02216000
END ELSE INFC.LINK~KEEP~IF DCINPUT THEN 12 ELSE 2 ;                     02217000
TS~KEEP=12 ;                                                            02217050
IF XTA="BACKUP" THEN                                                    02217100
    BEGIN                                                               02217150
    FETCH;  IF KEEP!0 AND KEEP!18 THEN FLAG(37);                        02217200
    IF TOG~XTA="DISK  " THEN KEEP~IF KEEP=0 THEN 22 ELSE 15             02217250
    ELSE IF TOG~XTA="TAPE  " THEN KEEP~IF KEEP=0 THEN 20 ELSE 6         02217275
         ELSE BEGIN                                                     02217300
              TOG~XTA="ALTERN";  KEEP~IF KEEP=0 THEN 25 ELSE 16 ;       02217350
              END;                                                      02217400
    IF TOG THEN FETCH;  INFC.LINK~KEEP ;                                02217450
    END ;                                                               02217500
IF XTA = "UNLABE" THEN  %   FOR UNLABELED TAPES                         02218000
      BEGIN IF KEEP = 2 THEN INFC   .LINK ~ 9; FETCH;  END;             02219000
IF XTA = "ALPHA " THEN FETCH ELSE IF KEEP = 2 THEN ALPH ~ 1;   %  MODE  02220000
IF XTA = "BCL   " THEN FETCH;   %  FOR B3500                            02221000
IF XTA = "FIXED " THEN FETCH;   %  FOR B3500                            02222000
IF XTA = "SAVE  " THEN SAVER ~ REPLACEMENT;                             02223000
IF XTA = "LOCK  " THEN BEGIN SPIN ~ 2; FETCH END;  %  REW & LOCK AT EOJ 02224000
      IF TOG ~ XTA = "RANDOM" THEN T ~ 10 ELSE                          02225000
      IF TOG ~ XTA = "SERIAL" THEN T ~ 12 ELSE                          02226000
      IF TOG ~ XTA = "UPDATE" THEN T ~ 13;                              02227000
IF TOG THEN                                                             02228000
    BEGIN IF KEEP=12 THEN INFC.LINK~T ELSE FLAG(37); FETCH END;         02229000
IF XTA="AREA  " THEN                                                    02230000
    BEGIN                                                               02230010
    IF KEEP!12 THEN     FLAG(37);                                       02230020
    T~REPLACEMENT;                                                      02230030
    IF XTA="EU    " THEN                                                02230040
         IF I~REPLACEMENT>19 THEN FLAG(37)                              02230045
         ELSE T.EUNF~I+1;%             0 MEANS EU NOT SPECIFIED         02230050
    IF XTA="SPEED " THEN                                                02230060
         BEGIN                                                          02230070
         FETCH;                                                         02230080
         IF NEXT=EQUAL THEN                                             02230090
              BEGIN                                                     02230100
              FETCH;                                                    02230110
              IF XTA.[12:6]{SLOWV THEN                                  02230115
                   IF I~MAKEINT(XTA)>SLOWV THEN FLAG(37)                02230120
                   ELSE                                                 02230125
              ELSE IF XTA="FAST  " THEN           T.SPDF~FASTV          02230130
                   ELSE IF XTA="SLOW  " THEN      T.SPDF~SLOWV          02230140
                        ELSE FLOG(37);                                  02230150
              FETCH;                                                    02230160
              END                                                       02230170
         ELSE FLOG(37);                                                 02230180
         END;                                                           02230190
    IF XTA="SENSIT" THEN                                                02230200
         BEGIN                                                          02230210
         T.SENSE~1;                                                     02230220
         FETCH;                                                         02230230
         END;                                                           02230240
    FILEINFO[3,INXFIL]~T;                                               02230300
    END;                                                                02230400
IF XTA = "BLOCKI" THEN BLOCK ~ REPLACEMENT & 1[2:47:1];                 02231000
RECORD ~ IF XTA="RECORD" THEN REPLACEMENT ELSE IF CA THEN 10 ELSE IF TS 02232000
    AND NOT (BOOLEAN(BLOCK.[2:1])) THEN 10 & 1[2:47:1] ELSE 17;         02232010
BUFF   ~ IF XTA = "BUFFER" THEN REPLACEMENT ELSE 2;                     02233000
IF XTA = "WORKAR" THEN FETCH;  %  IGNORED, FOR 3500                     02234000
IF BUFF<1 OR BUFF>32 THEN BEGIN XTA~"BUFFER"; FLAG(152) END ;           02236000
IF RECORD<1 THEN BEGIN XTA~"RECORD"; FLAG(152)END ;                     02236010
IF SAVER>999 THEN BEGIN XTA~"SAVE  "; FLAG(152) END ;                   02236020
IF T~INFC.LINK=10 OR T=12 OR T=13 THEN %%% ARE IN DISK FILE             02237000
    BEGIN                                                               02237010
    IF BOOLEAN(RECORD.[2:1])THEN BLOCK ~ 300                            02237012
    ELSE                                                                02237015
         IF BLOCK~BLOCK|RECORD>1890 OR RECORD>1023 THEN                 02237020
              BEGIN XTA~"BK/REC"; FLAG(152)  END                        02237021
    END                                                                 02237030
ELSE IF BLOCK~BLOCK|RECORD>1023 OR RECORD>1023 THEN IF KEEP ! 2 THEN    02237040
    BEGIN XTA~"BK/REC"; FLAG(58 ) END ELSE BEGIN RECORD~257; BLOCK~0END;02237050
FILEINFO[0,INXFIL] ~ 0&BUFF[42:42:6]&RECORD[30:36:12]&BLOCK[18:36:12]   02238000
       &SAVER[6:36:12]&SPIN[4:46:2]&ALPH[3:47:1];                       02239000
XIT:  IF NEXT ! SEMI THEN                                               02240000
      BEGIN FLOG(37);  DO SCAN UNTIL NEXT = SEMI;  END;                 02241000
     FILETOG ~ FALSE;   %  END SCAN MAINTAINENCE                        02242000
      PUT(P+2,INFC);                                                    02243000
IF DEBUGTOG THEN FLAGROUTINE(" FILEO","PTION ",FALSE) ;                 02243100
END FILEOPTION;                                                         02244000
PROCEDURE DOLOPT;                                                       02245000
BEGIN                                                                   02245300
REAL STREAM PROCEDURE SCAN(BUF,ID); VALUE BUF;                          02245600
    BEGIN     LABEL     LP,LA,LE,XIT;                                   02245900
           SI ~ BUF; DI ~ ID; DS ~ 2 LIT "0";                           02246200
     LP:   IF SC = " " THEN BEGIN SI~SI+1; GO TO LP; END;               02246500
           IF SC = "," THEN BEGIN SI~SI+1; GO TO LP; END;               02246800
           IF SC = "+" THEN BEGIN DS~CHR; GO TO XIT; END;               02246900
           IF SC = "-" THEN BEGIN DS~CHR; GO TO XIT; END;               02247000
           IF SC < "A" THEN BEGIN DI ~ ID; DS ~ 8 LIT "+0000001";       02247100
LE:                               SI~SI+1;                              02247200
                                  GO TO XIT;                            02247400
                            END;                                        02247700
           IF SC="|" THEN    GO TO LE;%     THIS IS > "A"               02247800
           IF SC="!" THEN    GO TO LE;%     THIS IS > "A"               02247900
           6(IF SC = ALPHA THEN DS ~ CHR ELSE JUMP OUT);                02248000
      LA:  IF SC = ALPHA THEN BEGIN SI~SI+1; GO TO LA; END;             02248300
      XIT:                                                              02248600
           SCAN ~ SI;                                                   02248900
     END SCAN;                                                          02249200
REAL STREAM PROCEDURE GETVOID(BUF,VOIDSEQ,FR); VALUE BUF,FR;            02249500
     BEGIN LABEL L,LC,LD,LE,XIT; LOCAL TA;                              02249800
           SI ~ BUF; DI~VOIDSEQ; DS~8LIT" "; DI~VOIDSEQ;                02250100
     L:    IF SC = " " THEN BEGIN SI~SI+1; GO TO L;  END;               02250400
           TA ~ SI;                                                     02250500
           IF SC = """ THEN                                             02250700
           BEGIN 9(SI~SI+1;                                             02251000
                IF SC = """ THEN BEGIN SI~SI+1; JUMP OUT TO LC; END     02251300
                ELSE TALLY ~ TALLY + 1);                                02251600
                 TALLY~TALLY+63; SI~TA; SI~SI+1; GO TO LE;              02251900
           END;                                                         02252200
           IF SC < "0" THEN GO TO LD;                                   02252500
           DS:=8LIT"0";                                            %115-02252600
           8(SI:=SI+1; DI:=DI-1; TALLY:=TALLY+1;                   %115-02252800
             IF SC LSS "0" THEN JUMP OUT);                         %115-02252850
      LC:   SI ~ TA;                                                    02252900
      LE:  TA~TALLY; DS~TA CHR; GETVOID~SI; GO TO XIT;                  02253100
      LD:  GETVOID~SI;                                                  02253400
           FR(DS~8LIT"9");                                              02253700
     XIT:                                                               02254000
     END GETVOID;                                                       02254300
REAL STREAM PROCEDURE SEQNUM(BUF,VLU); VALUE BUF;                       02254600
     BEGIN LABEL L,LA,LC; LOCAL TA,TB;                                  02254900
           SI ~ BUF;                                                    02255200
     L:    IF SC = " " THEN BEGIN SI~SI+1; GO TO L; END;                02255500
           IF SC = "," THEN BEGIN SI~SI+1; GO TO L; END;                02255800
           TA ~ SI;                                                     02256100
           IF SC = "+" THEN                                             02256400
           BEGIN SI~SI+1;                                               02256700
     LA:         IF SC = " " THEN BEGIN SI~SI+1; GO TO LA;END;          02257400
                 TB ~ SI;                                               02257300
                 IF SC < "0" THEN BEGIN SI~TA; GO TO LC; END;           02257600
                 DI~TB;TA~DI;                                           02257900
           END;                                                         02258200
           8(IF SC < "0" THEN JUMP OUT TO LC;                           02258500
           TALLY~TALLY+1; SI~SI+1;);                                    02258800
     LC:   TB ~ TALLY; SEQNUM ~ SI;                                     02259100
           SI ~ TA; DI ~ VLU; DS ~ TB OCT;                              02259400
     END SEQNUM;                                                        02259700
REAL STREAM PROCEDURE MKABS(S);                                         02260000
     BEGIN SI ~ S; SI~SI+1; MKABS ~ SI;                                 02260300
           DI ~ S; 9(DI ~ DI + 8); DS ~ LIT "[";                        02260600
     END MKABS;                                                         02260900
STREAM PROCEDURE MOVEW(P,Q); VALUE Q;                                   02260925
BEGIN SI~P; DI ~ Q; DS~CHR; END   ;                                     02260950
    REAL BUF,ID;                                                        02261200
    BOOLEAN VAL, SAVELISTOG;                                       %511-02261500
    LABEL LP,SET,RESET;                                                 02261800
    FORMAT WARN(X18,A6," ILLEGAL CONSTRUCT ON DOLLAR CARD XXXX",X39,    02262100
               "WARNING");                                              02262400
    DEFINE GETID = BEGIN ID~ "      "; BUF ~ SCAN(BUF,ID) END#;         02262700
         SAVELISTOG ~ LISTOG;                                     %511- 02262775
         MOVEW(CRD[9],BUFL);                                            02262800
         BUF ~ MKABS(CRD[0]);                                           02263000
         GETID;                                                         02263300
         IF ID = "VOID  " THEN                                          02263600
            BEGIN BUF ~ GETVOID(BUF, VOIDSEQ,0); VOIDTOG ~ TRUE         02263900
            END ELSE                                                    02264200
         IF ID = "VOIDT " THEN                                          02264500
            BEGIN BUF ~ GETVOID(BUF, VOIDTSEQ,0); VOIDTTOG ~ TRUE       02264800
            END ELSE                                                    02265100
    BEGIN                                                               02265400
          TAPETOG.[47:1] ~ LASTMODE = 2;                           %517-02265700
         IF ID = "SET   " OR ID = "+     " THEN                         02267200
SET:        BEGIN GETID; VAL~ TRUE END                                  02267500
         ELSE                                                           02267800
         IF ID = "RESET " OR ID = "-     " THEN                         02268100
RESET:      BEGIN GETID; VAL ~ FALSE END                                02268400
         ELSE                                                           02268700
         BEGIN                                                          02269000
         TSSMESTOG ~ VAL; TSSEDITOG ~ VAL; CHECKTOG ~ VAL;         %501-02269300
         SINGLETOG~NOT VAL;  HOLTOG~VAL;                           %501-02269600
         LISTOG~VAL; CODETOG ~ DEBUGTOG ~ VAL; NEWTPTOG ~ VAL;          02269900
         PRTOG~VAL;  DOLIST~VAL;  LIBTAPE~VAL;  SEGPTOG~VAL;       %501-02270200
         LISTPTOG ~ VAL; FREEFTOG ~ XREF ~ VAL ;                        02270500
         VAL ~ TRUE;                                                    02270800
         END;                                                           02271100
LP:      IF ID > 0 THEN                                                 02271400
         BEGIN                                                          02271700
         IF ID = "TRACE " THEN                                          02272000
            BEGIN PRTOG~VAL; LISTOG~VAL; CODETOG~DEBUGTOG~VAL;          02272300
            END ELSE                                                    02272400
         IF ID = "CARD  " THEN                                          02272500
            BEGIN TAPETOG.[47:1]~NOT VAL; LASTMODE~2-REAL(VAL) END ELSE 02272510
         IF ID = "TAPE  " THEN                                          02272550
            BEGIN TAPETOG.[47:1] ~ VAL; LASTMODE ~ REAL(VAL)+1; END ELSE02272560
         IF ID = "NOSEQ " THEN SEQTOG ~ FALSE ELSE                      02272600
         IF ID = "SET   " OR ID = "+     " THEN GO TO SET ELSE          02272900
         IF ID = "RESET " OR ID = "-     " THEN GO TO RESET ELSE        02273200
         IF ID = "ONSITE" AND NOT REMFIXED THEN REMOTETOG ~ FALSE ELSE  02273500
         IF ID = "REMOTE" AND NOT REMFIXED THEN REMOTETOG ~ VAL ELSE    02273800
         IF ID = "FREEFO" THEN FREEFTOG ~ VAL ELSE                      02274100
         IF ID = "SINGLE" OR ID = "SGL   " THEN                         02274400
            BEGIN SINGLETOG ~ VAL; LISTOG ~ TRUE; END ELSE              02274700
         IF ID = "NEW   " OR ID = "NEWTAP" THEN                         02275000
            BEGIN LIBTAPE~VAL; NEWTPTOG~VAL; NTAPTOG~TRUE;         %501-02275100
            IF ID = "NEW   " THEN                                  %501-02275120
               BEGIN                                               %501-02275140
               GETID;                                              %501-02275160
               IF ID ! "TAPE  " THEN                               %501-02275180
                    GO TO LP;                                      %501-02275200
               END;                                                %501-02275220
             END ELSE                                              %501-02275240
         IF ID = "LIST  " THEN LISTOG ~ VAL ELSE                        02275300
         IF ID = "SEQXEQ" AND NOT SEGSWFIXED THEN SEGSW ~ VAL ELSE      02275600
         IF ID = "PRT   " THEN PRTOG ~ VAL ELSE                         02275900
         IF ID = "DEBUGN" THEN                                          02276200
            BEGIN LISTOG~VAL; CODETOG~VAL; PRTOG ~ VAL END ELSE         02276500
         IF ID = "TIME  " THEN TIMETOG ~ VAL ELSE                       02276800
         IF ID = "ERRMES" THEN TSSMESTOG ~ VAL ELSE                     02277100
         IF ID = "TSSEDI" THEN TSSEDITOG ~ VAL ELSE                     02277400
         IF ID = "LISTLI" THEN LISTLIBTOG ~ VAL ELSE                    02277700
         IF(ID = "SEGMEN" OR ID = "SEG   ") AND VAL THEN                02278000
            BEGIN ADR~ADR+1; SEGOVF; END ELSE                           02278300
         IF ID = "PAGE  " AND VAL THEN WRITE(LINE[PAGE]) ELSE           02278600
         IF ID = "VOID  " THEN                                          02278900
            BEGIN VOIDTOG ~ VAL;                                        02279200
                  IF VAL THEN BUF ~ GETVOID(BUF,VOIDSEQ,1);             02279300
            END ELSE                                                    02279500
         IF ID = "VOIDT " THEN                                          02279800
            BEGIN VOIDTTOG ~ VAL;                                       02280100
                   IF VAL THEN BUF ~ GETVOID(BUF,VOIDTSEQ,1);           02280300
            END ELSE                                                    02280400
         IF ID = "LIMIT " THEN                                          02280700
            BEGIN LIMIT ~ IF VAL THEN 0 ELSE @60;                       02281000
                  BUF ~ SEQNUM(BUF,LIMIT);                              02281300
                  IF LIMIT LEQ ERRORCT THEN GO TO POSTWRAPUP;           02281600
            END ELSE                                                    02282500
         IF ID = "XREF  " THEN                                          02282800
            BEGIN                                                       02282850
                  PXREF ~ TRUE; XREF ~ VAL;                             02282900
            END ELSE                                                    02282950
         IF ID = "SEQ   " THEN                                          02283100
         BEGIN SEQTOG ~ VAL;                                            02283200
               IF VAL THEN                                              02283300
            BEGIN SEQBASE ~ SEQINCR ~ 0;                                02283400
                  BUF ~ SEQNUM(BUF,SEQBASE);                            02283700
                  BUF ~ SEQNUM(BUF,SEQINCR);                            02284000
                  IF SEQINCR { 0 THEN SEQINCR ~ 1000;                   02284600
         END END ELSE                                                   02284900
         IF ID = "LISTDO" THEN DOLIST ~ VAL ELSE                        02285200
         IF ID = "HOL   " THEN HOLTOG ~ VAL ELSE                        02285500
         IF ID = "CHECK " THEN CHECKTOG ~ VAL ELSE                      02285800
         IF ID = "NEWPAG" THEN SEGPTOG ~ VAL ELSE                  %501-02286100
         IF ID = "LISTP " THEN LISTPTOG ~ VAL ELSE                      02286400
         BEGIN IF FIRSTCALL THEN DATIME;                                02286700
               IF UNPRINTED THEN BEGIN PRINTCARD; UNPRINTED~FALSE END;  02287000
               IF SINGLETOG THEN WRITE(LINE,WARN,ID)                    02287300
               ELSE WRITE(RITE,WARN,ID);                                02287600
         END                                                            02287900
         ;                                                              02288200
         GETID;                                                         02288500
         GO TO LP;                                                      02288800
         END;                                                           02289100
    END;                                                                02289400
         IF DOLIST OR LISTOG OR SAVELISTOG THEN                    %511-02289450
            IF UNPRINTED THEN PRINTCARD;                           %517-02289500
    UNPRINTED ~ TRUE;                                                   02289600
END DOLOPT;                                                             02289700
STREAM PROCEDURE NEWSEQ(A,B); VALUE B;                                  02317000
    BEGIN                                                               02318000
         SI ~ LOC B; DI ~ A; DS ~ 8 DEC;                                02319000
    END NEWSEQ;                                                         02320000
INTEGER STREAM PROCEDURE SEQCHK(T,C);                                   02321000
    BEGIN                                                               02322000
         SI ~ T; DI ~ C;                                                02323000
         IF 8 SC < DC THEN TALLY ~ 4 ELSE                               02324000
    BEGIN                                                               02325000
         SI ~ SI - 8; DI ~ DI - 8;                                      02326000
         IF 8 SC =DC THEN TALLY ~ 2                                     02327000
                     ELSE TALLY ~ 3;                                    02328000
    END;                                                                02329000
         SEQCHK ~ TALLY;                                                02330000
    END SEQCHK;                                                         02331000
BOOLEAN PROCEDURE READACARD;                                            02332000
BEGIN                                                                   02333000
DEFINE FLAGI(FLAGI1) = BEGIN FLAG(FLAGI1); GO TO E4A;END #;             02333050
REAL STREAM PROCEDURE SCANINC(BUF,ID,RESULT,N,M);                       02333100
    VALUE BUF,M,N;                                                      02333120
    BEGIN                                                               02333140
         LOCAL TA;                                                      02333160
         LABEL LP,LQ,XIT;                                               02333180
         DI := RESULT; DI := DI +7;                                     02333200
         SI := BUF;                                                     02333210
     LP: IF SC = " " THEN BEGIN SI := SI + 1; GO TO LP; END;            02333220
         IF SC = ALPHA THEN ELSE BEGIN DS:=LIT "1"; DI:=ID; DS:=2LIT"0";02333240
              DS := CHR; DS := 5LIT" ";GO TO XIT; END;                  02333260
         IF SC LSS "0" THEN DS:=LIT "2" ELSE DS:=LIT "3";          %400-02333270
         N (DI:=ID; DS:=8 LIT "0       "; DI:=DI-7;                %400-02333280
            7(IF SC=ALPHA THEN DS~CHR ELSE JUMP OUT 2 TO XIT);          02333300
          JUMP OUT TO XIT);                                             02333320
         M ( 8 ( IF SC LSS "0" THEN JUMP OUT 2 TO LQ;              %400-02333360
                 IF SC GTR "9" THEN JUMP OUT 2 TO LQ;              %400-02333370
              SI:=SI+1; TALLY:=TALLY+1));                          %400-02333380
     LQ: TA := TALLY;                                                   02333400
         SI := SI - TA;                                                 02333420
         DI := ID;                                                      02333440
         DS := TA OCT;                                                  02333460
    XIT:  SCANINC := SI;                                                02333500
    END SCANINC;                                                        02333520
REAL STREAM PROCEDURE MKABS(S);                                         02333540
    BEGIN SI := S; SI := SI + 1;  MKABS := SI;  END;                    02333550
STREAM PROCEDURE MOVE(P, Q); VALUE Q;                                   02334000
BEGIN SI ~ P; DI ~ Q; DS ~ CHR;                                         02335000
   DI ~ P; DS ~ LIT "]";                                                02336000
END MOVE;                                                               02337000
STREAM PROCEDURE MOVEC(C,B);   VALUE B;                                 02337100
BEGIN SI~B; DI~C; DS~CHR; END;                                          02337200
BOOLEAN STREAM PROCEDURE GETCOL1(BUF);                                  02338000
    BEGIN                                                               02339000
         SI ~ BUF; IF SC = "$" THEN TALLY ~ 1;                          02340000
         GETCOL1 ~ TALLY;                                               02341000
    END;                                                                02342000
STREAM PROCEDURE TSSEDITS(C,P);  BEGIN SI~C;  DI~P;  DS~10WDS;  SI~C ;  02342010
IF SC="C" THEN BEGIN DI~P;  DI~DI+1;  DS~LIT"-" END ELSE                02342020
IF SC!"$" THEN BEGIN SI~SI+5;  IF SC!" " THEN IF SC!"0" THEN BEGIN DI~P;02342030
DS~6LIT"-     " END END END OF TSSEDITS ;                               02342040
STREAM PROCEDURE MOVEW(F,T,B,R); VALUE B, R;                            02343000
    BEGIN                                                               02344000
         LABEL XIT;                                                     02345000
         SI ~ F; DI ~ T;                                                02346000
         B(                                                             02347000
         2(40( IF SC = ALPHA THEN DS ~ CHR ELSE                         02348000
              IF SC = " " THEN DS ~ CHR ELSE                            02349000
              IF SC = "%" THEN BEGIN DS ~ LIT "("; SI ~ SI+1 END ELSE   02350000
              IF SC = "[" THEN BEGIN DS ~ LIT ")"; SI ~ SI+1 END ELSE   02351000
              IF SC = "#" THEN BEGIN DS ~ LIT "="; SI ~ SI+1 END ELSE   02352000
              IF SC = "&" THEN BEGIN DS ~ LIT "+"; SI ~ SI+1 END ELSE   02353000
              IF SC = "@" THEN BEGIN DS ~ LIT """; SI ~ SI+1 END ELSE   02354000
              IF SC = ":" THEN BEGIN DS ~ LIT """; SI ~ SI+1 END ELSE   02354100
              IF SC = "<" THEN BEGIN DS ~ LIT "+"; SI ~ SI+1 END ELSE   02355000
              IF SC = ">" THEN BEGIN DS ~ LIT "="; SI ~ SI+1 END ELSE   02356000
         DS ~ CHR )); JUMP OUT TO XIT);                                 02357000
         DS ~ 10 WDS;                                                   02358000
    XIT:                                                                02359000
         SI~LOC R;  SI~SI+7;  DI~DI+1 ;                                 02360000
         DS~CHR ;                                                       02361000
    END MOVEW;                                                          02362000
ALPHA STREAM PROCEDURE DCMOVEW(F,T,B,FIL,R); VALUE B,FIL,R;             02362010
    BEGIN LOCAL C;  LABEL L1,L2,L3,L4 ;                                 02362020
    SI~F;  DI~T;  2(SI~SI+36;  DS~36LIT" ");  C~SI;  DS~8CHR ;          02362030
    SI~LOC   R; SI~SI+6; DS~2CHR; DI~C; DS~8LIT"]";TALLY~33;SI~F;       02362033
    IF SC = " " THEN     %%% IT MIGHT BE A FILES CARD.                  02362034
         BEGIN SI~SI+1; IF SC="F" THEN                                  02362035
         BEGIN     DI~LOC FIL; DI~DI+2; IF 5SC=DC THEN                  02362036
         BEGIN DI~F; SI~LOC FIL; SI~SI+2; DS~6CHR ; GO TO L1; END       02362037
         ELSE SI~F END ELSE SI~F  END                                   02362038
    ELSE IF SC = "F" THEN BEGIN DI~LOC FIL;DI~DI+2;IF 6SC=DC THEN GO L1 02362040
               ELSE SI~F;END                                            02362041
    ELSE IF SC="-" THEN                                                 02362042
         BEGIN %%% IT IS A CONTINUATION CARD.                           02362044
         SI~SI+1;  DI~T;  DS~6LIT"     *" ;                             02362050
         5(IF SC=" " THEN SI~SI+1 ELSE JUMP OUT); GO TO L2 ;            02362060
         END                                                            02362063
    ELSE IF SC="C" THEN                                                 02362066
         BEGIN %%% IT MIGHT BE A COMMENT CARD.                          02362070
         SI~SI+1;  IF SC="-" THEN GO TO L1 ELSE SI~F ;                  02362080
         END ;                                                          02362090
    IF SC!"$" THEN %%% IT IS NOT A COMMENT CARD, NOR IS IT A $ CARD,    02362100
         BEGIN     %%% NOR A CONTINUATION CARD, NOR A FILES CARD.       02362110
         2(33(IF SC=" " THEN SI~SI+1 ELSE JUMP OUT 2 TO L3)); L3:  DI~T;02362120
         5(IF SC=" " THEN SI~SI+1 ELSE IF SC}"0" THEN IF SC{"9"         02362130
           THEN DS~CHR ELSE JUMP OUT ELSE JUMP OUT) ;                   02362140
         DI~T;  DI~DI+6;  IF SC=" " THEN SI~SI+1 ;                      02362150
         END                                                            02362160
    ELSE                                                                02362170
         BEGIN                                                          02362180
         L1:  SI~F;  DI~T;  TALLY~36 ;                                  02362190
         END ;                                                          02362200
    L2:  C~TALLY ;                                                      02362210
    B(2(C(IF SC>">" THEN DS~CHR ELSE IF SC<"[" THEN DS~CHR ELSE         02362220
          IF SC="%" THEN BEGIN DS~LIT"("; SI~SI+1 END ELSE              02362230
          IF SC="#" THEN BEGIN DS~LIT"="; SI~SI+1 END ELSE              02362235
          IF SC="&" THEN BEGIN DS~LIT"+"; SI~SI+1 END ELSE              02362240
          IF SC="@" THEN BEGIN DS~LIT"""; SI~SI+1 END ELSE              02362245
          IF SC=":" THEN BEGIN DS~LIT"""; SI~SI+1 END ELSE              02362250
          IF SC="<" THEN BEGIN DS~LIT"+"; SI~SI+1 END ELSE              02362255
          IF SC=">" THEN BEGIN DS~LIT"="; SI~SI+1 END ELSE              02362260
          IF SC="[" THEN BEGIN DS~LIT")"; SI~SI+1 END ELSE              02362265
          IF SC="]" THEN JUMP OUT 3 TO L4 ELSE DS~CHR));JUMP OUT TO L4);02362270
    2(C(IF SC="]" THEN JUMP OUT 2 TO L4 ELSE DS~CHR)) ;                 02362275
    L4:  DI~LOC DCMOVEW;  DS~8LIT"00      ";  DI~DI-6 ;                 02362280
    6(IF SC="]" THEN JUMP OUT ELSE DS~CHR) ;                            02362285
    END OF DCMOVEW ;                                                    02362290
STREAM PROCEDURE SEQERR(BUFF, NEW, OLD);                                02362300
BEGIN                                                                   02362400
         DI ~ BUFF; DS ~ 18 LIT "SEQUENCE ERROR    ";                   02362450
         SI ~ NEW; DS ~ LIT""";                                         02362500
         DS ~ 8 CHR; DS ~ LIT """;                                      02362550
         DS ~ 3 LIT " < ";                                              02362600
         SI ~ OLD; DS ~ LIT """;                                        02362650
         DS ~ 8 CHR; DS ~ LIT """;                                      02362700
         DS ~ 59 LIT " ";                                               02362750
         DS ~ 8 LIT "X"; DS ~ 4 LIT " ";                                02362800
END SEQERR;                                                             02362850
STREAM PROCEDURE DCMOVE(E,C,A,N); VALUE A,N;                            02362855
BEGIN SI~C; DI~E; DS~10WDS; DS~4CHR; SI~LOC A; DS~4DEC;                 02362860
      N(DS~8LIT"   PATCH"); END;                                        02362865
     REAL BUF,ID;                                                       02362900
     BOOLEAN NOWRI;  LABEL ENDPB, E4B;                                  02362902
     LABEL LIBADD, ENDPA, E4A, E4, STRTA;                               02362950
     LABEL E1,E2,E3,STRT,ENDP,XIT;                                      02363000
     UNPRINTED~TRUE;                                                    02363100
     GO TO STRT;                                                        02364000
LIBADD:                                                                 02364100
     XTA := BLANKS;                                                     02364130
     IF INSERTDEPTH = -1 THEN SAVECARD ~ NEXTCARD;                      02364160
     MOVE (CRD[9],BUFL);                                                02364240
                                                                        02364280
     IF (INSERTDEPTH ~ INSERTDEPTH + 1) GTR INSERTMAX THEN              02364300
          FLAG(158);                                                    02364320
     NEWTPTOG ~ FALSE;                                                  02364330
     INSERTINX ~ -1;                                                    02364340
     INSERTCOP ~ 0;                                                     02364350
     BLANKIT(SSNM[5],1,0);                                              02364360
     BUF ~ SCANINC(BUF,INSERTMID,RESULT,1,0);                           02364380
     IF RESULT = 1 AND INSERTMID = "+     "THEN                         02364381
     BEGIN BUF~SCANINC(BUF,ID,RESULT,1,0);                              02364382
           IF ID = "COPY   " THEN INSERTCOP ~ 1                         02364383
           ELSE FLAG(155);                                              02364384
           BUF~SCANINC(BUF,INSERTMID,RESULT,1,0);                       02364385
     END;                                                               02364386
     IF RESULT NEQ 2 THEN FLAGI (155);                                  02364400
          BUF := SCANINC(BUF,ID,RESULT,0,1);                       %107-02364420
     IF RESULT = 1  THEN IF ID = "/     " THEN                          02364440
     BEGIN BUF := SCANINC(BUF,INSERTFID,RESULT,1,0);                    02364460
            IF RESULT NEQ 2 THEN FLAGI(155);                            02364480
           BUF := SCANINC(BUF,ID,RESULT,0,1);                           02364500
      END ELSE INSERTFID := TIME(-1) ELSE INSERTFID := TIME(-1);        02364520
     IF RESULT = 3 THEN                                                 02364540
      BEGIN NEWSEQ(SSNM[5],ID);                                         02364560
           BUF := SCANINC(BUF,ID,RESULT,0,1);                           02364580
            IF RESULT NEQ   1 THEN FLAGI(156);                          02364600
            IF ID = "]     " THEN NEWSEQ (INSERTSEQ,99999999)      %400-02364605
            ELSE BEGIN                                             %400-02364610
           BUF ~ SCANINC(BUF,ID,RESULT,0,1);                            02364620
            IF RESULT NEQ   3 THEN FLAGI(157);                          02364640
            NEWSEQ (INSERTSEQ,ID);                                      02364660
            END                                                    %400-02364670
      END ELSE IF ID = "]     " THEN NEWSEQ(INSERTSEQ,999999999)        02364680
          ELSE FLAGI(157);                                              02364700
     IF INSERTDEPTH > 0 THEN CLOSE (LF,RELEASE);                        02364720
     FILL LF WITH     INSERTMID,INSERTFID;                              02364740
     DO BEGIN                                                           02364760
          READ (LF[INSERTINX ~ INSERTINX+1],10,DB[*])[E4];              02364780
          END UNTIL SEQCHK(SSNM[5],DB[9]) NEQ 3;                        02364800
     NEWTPTOG ~ BOOLEAN(INSERTCOP);                                     02364810
     IF NOT NEWTPTOG THEN                                               02364811
     BEGIN                                                              02364815
     IF SEQTOG THEN                                                     02364820
     BEGIN NEWSEQ(CRD[9],SEQBASE); MOVE(CRD[9],BUFL);                   02364830
           SEQBASE~SEQBASE+SEQINCR;                                     02364840
     END;     MOVEC(CRD[9],BUFL);                                       02364850
     IF LIBTAPE AND(INSERTDEPTH = 0 ) THEN WRITE(NEWTAPE,10,CRD[*]);    02364860
     END;                                                      %511-    02364885
     IF LISTOG OR DOLIST THEN PRINTCARD;                       %511-    02364890
     NEXTCARD~7;                                                        02364900
     GO TO STRT;                                                        02364910
    E1:  IF NEXTCARD=1 THEN IF TAPETOG THEN                             02365000
            BEGIN                                                       02366000
            NEXTCARD~5;  READ(TP,10,TB[*])[E2];  GO TO STRT ;           02367000
            END                                                         02368000
         ELSE                                                           02369000
            BEGIN                                                       02370000
            NEXTCARD:=6;                                                02371000
         IF GETCOL1(CRD[0]) THEN BEGIN BUF := MKABS(CRD[0]);            02371002
            BUF:=SCANINC(BUF,ID,RESULT,1,0); IF ID NEQ INCLUDE          02371004
            THEN BLANKIT(CRD,9,1); END;                                 02371006
            GO TO ENDP ;                                                02371010
            END ;                                                       02371020
         NEXTCARD ~ 5; GO TO ENDP;                                      02372000
    E2:  IF NEXTCARD = 5 THEN                                           02372010
            BEGIN                                                       02372020
             NEXTCARD:=6;                                               02372030
         IF GETCOL1(CRD[0]) THEN BEGIN BUF := MKABS(CRD[0]);            02372040
            BUF:=SCANINC(BUF,ID,RESULT,1,0); IF ID NEQ INCLUDE          02372050
            THEN BLANKIT(CRD,9,1); END;                                 02372060
            END                                                         02373000
         ELSE IF NEXTCARD!2 THEN NEXTCARD~1 ELSE                        02373010
            BEGIN                                                       02373020
            NEXTCARD~1;  TAPETOG~BOOLEAN(2);  READ(CR,10,CB[*])[E1] ;   02373030
            END ;                                                       02373040
    IF VOIDTTOG THEN IF SEQCHK(CRD[0],VOIDTSEQ) < 4                %114-02373045
           THEN VOIDTTOG~FALSE                                     %114-02373100
            ELSE BEGIN VOIDTTOG~FALSE; GO TO STRT; END;            %114-02373200
         GO TO ENDP ;                                                   02374000
    E4B: NOWRI ~TRUE;                                                   02374050
         IF SEQTOG THEN NEWSEQ(CRD[9],SEQBASE);                         02374053
         IF NEWTPTOG THEN IF TSSEDITOG THEN                             02374055
         BEGIN TSSEDITS(CRD,PRINTBUFF); WRITE(NEWTAPE,10,PRINTBUFF[*]); 02374060
         END ELSE WRITE(NEWTAPE,10,CRD[*]);                             02374065
    E4:  CLOSE (LF,RELEASE);                                            02374100
         NEWTPTOG~ SAVETOG;                                             02374110
         IF (INSERTDEPTH := INSERTDEPTH - 1) = -1 THEN                  02374150
              BEGIN NEXTCARD ~ SAVECARD; GO TO ENDPA; END               02374200
              ELSE NEWTPTOG ~ BOOLEAN(INSERTCOP);                       02374300
          FILL LF WITH INSERTMID,INSERTFID;                             02374450
          READ(LF[INSERTINX := INSERTINX + 1],10,DB[*])[E4];            02374470
          IF SEQCHK(INSERTSEQ,DB[9]) = 4 THEN GO TO E4;                 02374500
          GO TO ENDP;                                                   02374520
     E4A:                                                               02374560
         NEWTPTOG~SAVETOG;                                              02374580
          IF (INSERTDEPTH ~ INSERTDEPTH-1) = -1 THEN NEXTCARD~SAVECARD  02374600
          ELSE NEWTPTOG ~ BOOLEAN(INSERTCOP);                           02374680
     STRT:                                                              02375000
     STRTA:                                                             02375600
          IF NEXTCARD=6 THEN GO XIT ;                                   02376000
          CARDCOUNT ~ CARDCOUNT+1;                                      02377000
          IF NEXTCARD = 1 THEN                                          02378000
     BEGIN     % CARD ONLY                                              02379000
          IF(NOT DCINPUT OR TSSEDITOG)AND NOT FREEFTOG                  02380000
          THEN MOVEW(CB,CRD,HOLTOG,IF DCINPUT THEN "D" ELSE "R")        02380100
          ELSE IF SSNM[4]~DCMOVEW(CB,CRD,HOLTOG,"FILE  ",IF FREEFTOG    02380125
                  THEN " R" ELSE " D") ! "      " THEN                  02380150
               BEGIN XTA~SSNM[4] ;                                      02380175
              MOVESEQ(SSNM[4],LASTSEQ);  MOVESEQ(LASTSEQ,CRD[9]) ;      02380200
              IF LISTOG THEN                                            02380210
                   BEGIN IF FIRSTCALL THEN DATIME ;                     02380220
                   DCMOVE(PRINTBUFF,CRD,(ADR+1).[36:10],0);             02380230
                   WRITAROW(11,PRINTBUFF);  UNPRINTED~FALSE ;           02380240
                   END ;                                                02380250
              FLOG(149);  MOVESEQ(LASTSEQ,SSNM[4]) ;                    02380300
              END ;                                                     02380400
         IF GETCOL1(CRD[0]) THEN                                        02381000
    BEGIN                                                               02382000
         BUF := MKABS(CRD[0]);                                          02382200
         BUF := SCANINC(BUF,ID,RESULT,1,0);                             02382300
         IF ID NEQ INCLUDE THEN                                         02382400
    BEGIN                                                               02382500
         DOLOPT;                                                        02383000
         IF REAL(TAPETOG)=3 THEN READ(TP) ;                             02383010
         READ(CR,10,CB[*])[E1];                                         02384000
         IF NOT TAPETOG THEN GO TO STRT;                                02385000
         READ(TP,10,TB[*])[E2];                                         02386000
         NEXTCARD ~ SEQCHK(TB[9], CB[9]);                               02387000
         GO TO STRT;                                                    02388000
    END;                                                                02389000
    END;                                                                02389100
         IF LISTPTOG THEN                                               02389200
         BEGIN IF FIRSTCALL THEN DATIME;                                02389300
               IF SEQTOG THEN NEWSEQ(CRD[9],SEQBASE);                   02389400
               DCMOVE(PRINTBUFF,CRD,(ADR+1).[36:10],1);                 02389500
               WRITAROW (12,PRINTBUFF); UNPRINTED ~ FALSE;              02389600
         END;                                                           02389700
         READ(CR,10,CB[*])[E1];                                         02390000
         GO TO ENDP;                                                    02391000
    END;                                                                02392000
         IF NEXTCARD = 5 THEN                                           02393000
    BEGIN                                                               02394000
         MOVEW(TB,CRD,HOLTOG,"T") ;                                     02395000
          READ(TP, 10, TB[*])[E2];                                      02396000
         IF VOIDTTOG THEN IF SEQCHK(CRD[9],VOIDTSEQ) < 4 THEN           02396100
            VOIDTTOG ~ FALSE ELSE GO TO STRT;                           02396200
         GO TO ENDP;                                                    02397000
    END;                                                                02398000
         IF NEXTCARD { 3 THEN                                           02399000
    BEGIN     % CARD OVER TAPE                                          02400000
         IF(NOT DCINPUT OR TSSEDITOG)AND NOT FREEFTOG                   02401000
         THEN MOVEW(CB,CRD,HOLTOG,IF DCINPUT THEN "D" ELSE "R")         02401100
         ELSE IF SSNM[4]~DCMOVEW(CB,CRD,HOLTOG,"FILE  ",IF FREEFTOG     02401125
                 THEN " R" ELSE " D") ! "      " THEN                   02401150
              BEGIN XTA~SSNM[4] ;                                       02401175
              MOVESEQ(SSNM[4],LASTSEQ);  MOVESEQ(LASTSEQ,CRD[9] );      02401200
              IF LISTOG THEN                                            02401210
                   BEGIN IF FIRSTCALL THEN DATIME;                      02401220
                   DCMOVE(PRINTBUFF,CRD,(ADR+1).[36:10],0);             02401230
                   WRITAROW(11,PRINTBUFF);  UNPRINTED~FALSE ;           02401240
                   END;                                                 02401250
              FLOG(149);  MOVESEQ(LASTSEQ,SSNM[4]) ;                    02401300
              END;                                                      02401400
         IF NEXTCARD =2 THEN READ(TP,10,TB[*])[E2];                     02402000
         IF GETCOL1(CRD) THEN                                           02403000
    BEGIN                                                               02404000
         BUF ~ MKABS(CRD[0]);                                           02404200
              BUF ~ SCANINC(BUF,ID,RESULT,1,0);                         02404300
         IF ID NEQ INCLUDE THEN                                         02404400
    BEGIN                                                               02404500
         DOLOPT;                                                        02405000
         READ(CR,10,CB[*])[E3];                                         02406000
         NEXTCARD ~ SEQCHK(TB[9], CB[9]);                               02407000
         GO TO STRT;                                                    02408000
         E3: NEXTCARD~5;  GO TO STRT;                                   02408500
    END;                                                                02409000
    END;                                                                02409100
         IF LISTPTOG THEN                                               02409200
         BEGIN IF FIRSTCALL THEN DATIME;                                02409300
               IF SEQTOG THEN NEWSEQ(CRD[9],SEQBASE);                   02409400
               DCMOVE(PRINTBUFF,CRD,(ADR+1).[36:10],1);                 02409500
               WRITAROW (12,PRINTBUFF); UNPRINTED ~ FALSE;              02409600
         END;                                                           02409700
         READ(CR,10,CB[*])[E1];                                         02410000
         NEXTCARD ~ SEQCHK(TB[9], CB[9]);                               02411000
         GO TO ENDP;                                                    02412000
    END;                                                                02413000
              % TAPE BEFORE CARD                                        02414000
         IF NEXTCARD = 7 THEN                                           02414100
    BEGIN                                                               02414150
         IF(NOT DCINPUT OR TSSEDITOG)AND NOT FREEFTOG                   02414175
         THEN MOVEW(DB,CRD,HOLTOG,"L") ELSE IF XTA~DCMOVEW(DB,CRD,      02414200
              HOLTOG,"FILE  ",IF FREEFTOG THEN " R" ELSE " D")          02414225
                 ! "      " THEN FLOG(149);                             02414250
         IF GETCOL1(CRD[0]) THEN                                        02414260
    BEGIN                                                               02414270
         BUF ~ MKABS(CRD[0]);                                           02414280
              BUF ~ SCANINC(BUF,ID,RESULT,1,0);                         02414290
         IF ID = INCLUDE THEN GO TO LIBADD;                             02414300
    END;                                                                02414310
         READ(LF[INSERTINX~INSERTINX+1],10,DB[*])[E4B];                 02414370
         IF SEQCHK(INSERTSEQ,DB[9]) = 4 THEN GO TO E4B;                 02414380
         IF GETCOL1(CRD[0]) THEN BEGIN DOLOPT; GO TO STRT; END;         02414382
         GO TO ENDP;                                                    02414390
    END;                                                                02414400
         MOVEW(TB,CRD,HOLTOG,"T") ;                                     02415000
         READ(TP,10,TB[*])[E2];                                         02416000
         IF VOIDTTOG THEN IF SEQCHK(CRD[9],VOIDTSEQ) < 4 THEN           02416100
           VOIDTTOG~FALSE ELSE BEGIN NEXTCARD~SEQCHK(TB[9],CB[9]); %114-02416200
                                      GO TO STRT; END;             %114-02416300
         NEXTCARD ~ SEQCHK(TB[9], CB[9]);                               02417000
    ENDP:                                                               02418000
         IF NEXTCARD NEQ 7 THEN                                         02418100
         IF VOIDTOG THEN IF SEQCHK(CRD[9],VOIDSEQ) < 4 THEN             02419000
             VOIDTOG ~ FALSE ELSE GO TO STRT;                           02419050
         IF GETCOL1(CRD[0]) THEN                                        02419100
    BEGIN                                                               02419150
         BUF ~ MKABS(CRD[0]);                                           02419200
         BUF ~ SCANINC(BUF,ID,RESULT,1,0);                              02419250
         IF ID = INCLUDE THEN GO TO LIBADD ELSE GO TO STRT;             02419300
    END;                                                                02419325
         SEQERRORS ~ FALSE;                                             02420000
         IF NEXTCARD = 7 THEN                                           02420010
            BEGIN MOVESEQ(LASTSEQ,CRD[9]); GO TO ENDPA; END;            02420011
         IF CHECKTOG AND SEQERRCT=0 THEN SEQERRCT~1 ;                   02420015
         IF CHECKTOG THEN IF SEQCHK(LASTSEQ,CRD[9])=3 THEN              02420020
            BEGIN                                                       02420030
            SEQERR(ERRORBUFF,CRD[9],LASTSEQ) ;                          02420040
            MOVESEQ(LASTSEQ,CRD[9]) ;                                   02420050
            IF SEQTOG THEN                                              02420053
               BEGIN NEWSEQ(CRD[9],SEQBASE);SEQBASE~SEQBASE+SEQINCR END;02420057
            MOVESEQ(LINKLIST,CRD[9]);                                   02420060
            MOVE(CRD[9],BUFL) ;                                         02420070
            SEQERRCT~SEQERRCT+1 ;                                       02420080
            SEQERRORS~TRUE ;                                            02420090
            IF NOT LISTOG THEN PRINTCARD ;                              02420100
            END                                                         02420110
         ELSE MOVESEQ(LASTSEQ,CRD[9]) ELSE MOVESEQ(LASTSEQ,CRD[9]) ;    02420120
                                                                        02420150
                                                                        02420200
                                                                        02420250
                                                                        02420300
                                                                        02420350
                                                                        02420400
                                                                        02420450
                                                                        02420500
ENDPA:                                                                  02420550
         IF SEQTOG THEN                                                 02421000
         BEGIN                                                          02422000
         NEWSEQ(CRD[9],SEQBASE);                                        02423000
         SEQBASE ~ SEQBASE + SEQINCR;                                   02424000
         END;                                                           02425000
   IF NOWRI THEN GO TO ENDPB;                                           02425100
   IF NEWTPTOG THEN IF TSSEDITOG THEN BEGIN TSSEDITS(CRD,PRINTBUFF) ;   02426000
   WRITE(NEWTAPE,10,PRINTBUFF[*]) END ELSE WRITE(NEWTAPE,10,CRD[*]) ;   02426005
ENDPB:                                                                  02426008
   IF NOT SEQERRORS THEN                                                02426010
      BEGIN                                                             02426020
      MOVESEQ(LINKLIST,CRD[9]) ;                                        02426030
      MOVE(CRD[9],BUFL) ;                                               02426040
      END ;                                                             02427000
   NCR ~ INITIALNCR;                                                    02428000
   READACARD ~ TRUE;                                                    02429000
XIT:                                                                    02430000
   SEGSWFIXED ~ TRUE ;                                                  02431000
   REMFIXED~TRUE ;                                                      02431005
   IF TSSEDITOG THEN WARNED~TRUE ;                                      02431100
   IF LISTOG AND FIRSTCALL THEN DATIME;                                 02432000
   IF SEGSW THEN %%% ENTER SEQ# AND ADR TO LINESEG ARRAY.               02432100
      BEGIN IF LASTADDR!ADR THEN BEGIN NOLIN~NOLIN+1;  LASTADDR~ADR END;02432200
      LINESEG[NOLIN.IR,NOLIN.IC]~0 & D2B(LASTSEQ)[10:20:28] & (ADR+3)   02432300
      [38:36:10] ;                                                      02432400
      END ;                                                             02432500
END READACARD;                                                          02433000
INTEGER STREAM PROCEDURE CONVERT(NUB,SIZE,P,CHAR); VALUE P;             02434000
    BEGIN                                                               02435000
    LOCAL T;                                                            02436000
         SI ~ P;                                                        02437000
         8(IF SC < "0" THEN JUMP OUT;                                   02438000
             SI ~ SI + 1; TALLY ~ TALLY + 1);                           02439000
         CONVERT ~ SI;                                                  02440000
         DI ~ CHAR; DS ~ 7 LIT "0"; DS ~ CHR;                           02441000
         T ~ TALLY;                                                     02442000
         SI ~ P; DI ~ NUB; DS ~ T OCT;                                  02443000
         DI ~ SIZE ; SI ~ LOC T; DS ~ WDS;                              02444000
    END CONVERT;                                                        02445000
PROCEDURE SCAN;                                                         02446000
BEGIN                                                                   02447000
BOOLEAN STREAM PROCEDURE ADVANCE(NCR, ACR, CHAR, NCRV, ACRV);           02448000
VALUE NCRV, ACRV, CHAR;                                                 02449000
BEGIN LABEL LOOP;                                                       02450000
   LABEL DIG, ALPH, BK1, BK2, SPEC;                                     02451000
   DI ~ ACRV;                                                           02452000
   SI ~ CHAR; SI ~ SI+8;                                                02453000
   IF SC ! " " THEN                                                     02454000
      IF SC } "0" THEN BEGIN SI ~ NCRV; GO TO BK1 END ELSE              02455000
                       BEGIN SI ~ NCRV; GO TO BK2 END;                  02456000
   SI ~ NCRV;                                                           02457000
   LOOP:                                                                02458000
   IF SC = " " THEN BEGIN SI~SI+1; GO TO LOOP END;                      02459000
   IF SC } "0" THEN                                                     02460000
   BEGIN                                                                02461000
      DIG: DS ~ CHR;                                                    02462000
      BK1: IF SC = " " THEN BEGIN SI ~ SI+1; GO TO BK1 END;             02463000
      IF SC } "0" THEN GO TO DIG;                                       02464000
      GO TO SPEC;                                                       02465000
   END;                                                                 02466000
   IF SC = ALPHA THEN                                                   02467000
   BEGIN                                                                02468000
      ALPH: DS ~ CHR;                                                   02469000
      BK2: IF SC = " " THEN BEGIN SI ~ SI+1; GO TO BK2 END;             02470000
      IF SC = ALPHA THEN GO TO ALPH;                                    02471000
   END;                                                                 02472000
   SPEC:                                                                02473000
   ACRV ~ DI;                                                           02474000
   DS ~ 6 LIT " ";                                                      02475000
   IF SC = "]" THEN                                                     02476000
   BEGIN TALLY ~ 1; SI ~ LOC ACRV;                                      02477000
      DI ~ ACR; DS ~ WDS;                                               02478000
      DI ~ CHAR; DS ~ LIT ";";                                          02479000
   END ELSE                                                             02480000
   BEGIN DI ~ CHAR; DS ~ CHR;                                           02481000
      ACRV ~ SI; SI ~ LOC ACRV;                                         02482000
      DI ~ NCR; DS ~ WDS;                                               02483000
   END;                                                                 02484000
   ADVANCE ~ TALLY;                                                     02485000
END ADVANCE;                                                            02486000
BOOLEAN PROCEDURE CONTINUE;                                             02487000
BEGIN                                                                   02488000
LABEL LOOP;                                                             02489000
                                                                        02490000
BOOLEAN STREAM PROCEDURE CONTIN(CD);                                    02491000
BEGIN SI~CD;  IF SC!"C" THEN IF SC!"$" THEN BEGIN SI~SI+5;  IF SC!" "   02492000
THEN IF SC!"0" THEN BEGIN TALLY~1;  CONTIN~TALLY END END END OF CONTIN ;02493000
BOOLEAN STREAM PROCEDURE COMNT(CD,T);  VALUE T;                         02494000
BEGIN LABEL L ;                                                         02495000
   SI ~ CD; IF SC = "C" THEN BEGIN T(SI~SI+1;  IF SC="-" THEN TALLY~1   02496000
   ELSE JUMP OUT TO L);  TALLY~1;  L: END;  COMNT~TALLY ;               02497000
END COMNT;                                                              02498000
BOOLEAN STREAM PROCEDURE DCCONTIN(CD);                                  02499000
BEGIN                                                                   02500000
    SI ~ CD; IF SC = "-" THEN TALLY ~ 1;                                02501000
    DCCONTIN ~ TALLY;                                                   02502000
END DCCONTIN;                                                           02503000
LOOP:    IF NOT(CONTINUE ~                                              02504000
           IF(DCINPUT AND NOT TSSEDITOG)OR FREEFTOG THEN                02505000
              IF NEXTCARD < 4 THEN DCCONTIN(CB)                         02506000
              ELSE IF NEXTCARD = 7 THEN DCCONTIN(DB)ELSE CONTIN(TB)     02507000
           ELSE IF NEXTCARD = 7 THEN CONTIN(DB)                         02508000
           ELSE IF NEXTCARD < 4 THEN CONTIN(DB) ELSE                    02509000
           CONTIN(TB)) THEN                                             02510000
         IF(IF NEXTCARD < 4 THEN                                        02511000
               COMNT(CB,(DCINPUT AND NOT TSSEDITOG) OR FREEFTOG)        02512000
            ELSE IF NEXTCARD = 7 THEN                                   02513000
               COMNT(CB,(DCINPUT AND NOT TSSEDITOG) OR FREEFTOG)        02514000
         ELSE COMNT(TB,0) AND NEXTCARD ! 6) THEN                        02515000
         BEGIN                                                          02516000
           IF READACARD THEN IF LISTOG THEN PRINTCARD;                  02517000
            GO TO LOOP;                                                 02518000
         END;                                                           02519000
END CONTINUE;                                                           02520000
                                                                        02521000
PROCEDURE SCANX(EOF1, EOF2, EOS1, EOS2, OK1, OK2);                      02522000
   VALUE        EOF1, EOF2, EOS1, EOS2, OK1, OK2;                       02523000
   INTEGER      EOF1, EOF2, EOS1, EOS2, OK1, OK2;                       02524000
BEGIN LABEL LOOP, LOOP0 ;                                               02525000
   LOOP0:                                                               02526000
   EXACCUM[1] ~ BLANKS;                                                 02527000
   ACR ~ ACR1;                                                          02528000
   LOOP:                                                                02529000
   IF ADVANCE(NCR, ACR, CHR1, NCR, ACR) THEN                            02530000
      IF CONTINUE THEN                                                  02531000
         IF READACARD THEN                                              02532000
              BEGIN                                                     02533000
              IF LISTOG THEN PRINTCARD ;                                02534000
              IF ACR.[33:15]}EXACCUMSTOP THEN                           02535000
                   BEGIN XTA~BLANKS; FLOG(175); GO LOOP0 END ;          02536000
              GO LOOP ;                                                 02537000
               END                                                      02538000
          ELSE SCN ~ IF EXACCUM[1] = BLANKS THEN EOF1 ELSE EOF2         02539000
       ELSE SCN ~ IF EXACCUM[1] = BLANKS THEN EOS1 ELSE EOS2            02540000
    ELSE SCN ~ IF EXACCUM[1] = BLANKS THEN OK1 ELSE OK2;                02541000
END SCANX;                                                              02542000
                                                                        02543000
DEFINE CHAR = ACCUM[0]#;                                                02544000
DEFINE T=SYMBOL#;                                                       02545000
INTEGER N;                                                              02546000
BOOLEAN STREAM PROCEDURE CHECKEXP(NCR, NCRV, A); VALUE NCRV;            02547000
BEGIN                                                                   02548000
   SI ~ NCRV;                                                           02549000
   IF SC = "*" THEN                                                     02550000
   BEGIN DI ~ A; DI ~ DI+2; DS ~ 2 LIT "*"; SI ~ SI+1; NCRV ~ SI;       02551000
      TALLY ~ 1; CHECKEXP ~ TALLY;                                      02552000
      SI ~ LOC NCRV; DI ~ NCR; DS ~ WDS  END;                           02553000
END CHECKEXP;                                                           02554000
PROCEDURE CHECKRESERVED;                                                02555000
BEGIN LABEL RESWD, XIT, FOUND1, FOUND2, DONE;                           02556000
BOOLEAN STREAM PROCEDURE COMPLETECHECK(A,B,N);  VALUE N ;               02557000
    BEGIN LABEL L ;                                                     02558000
    SI~A; SI~SI-2; DI~B; N(IF SC!DC THEN JUMP OUT TO L); TALLY~1;       02559000
    L: COMPLETECHECK~TALLY ;                                            02560000
    END OF COMPLETECHECK;                                               02561000
STREAM PROCEDURE XFER(FROM, T1, T2, N, M); VALUE FROM, N, M;            02562000
BEGIN SI ~ FROM; DI ~ T1; DI ~ DI+2;                                    02563000
   DS ~ M CHR;                                                          02564000
   SI ~ FROM; SI ~ SI+N;                                                02565000
   DI ~ T2; DI ~ DI+2;                                                  02566000
   DS ~ 6 CHR;                                                          02567000
END XFER;                                                               02568000
STREAM PROCEDURE XFERA(FROM, NEXT1, NEXT2);                             02569000
   VALUE FROM;                                                          02570000
BEGIN SI ~ FROM; SI ~ SI+6;                                             02571000
   DI ~ NEXT1; DI ~ DI+2;                                               02572000
   5(IF SC } "0" THEN DS ~ CHR ELSE JUMP OUT);                          02573000
   SI ~ SI+2;                                                           02574000
   DI ~ NEXT2; DI ~ DI+2;                                               02575000
   6(IF SC = ALPHA THEN DS ~ CHR ELSE JUMP OUT);                        02576000
END XFERA;                                                              02577000
BOOLEAN STREAM PROCEDURE CHECKFUN(FROM, TOO, N); VALUE FROM, N;         02578000
BEGIN SI ~ FROM; SI ~ SI +N;                                            02579000
   IF SC = "0" THEN                                                     02580000
   BEGIN SI ~ SI+1;                                                     02581000
      IF SC = "N" THEN                                                  02582000
      BEGIN SI ~ SI+1; TALLY ~ 1;                                       02583000
         DI ~ TOO; DI ~ DI+2;                                           02584000
         DS ~ 6 CHR;                                                    02585000
      END;                                                              02586000
   END;                                                                 02587000
   CHECKFUN ~ TALLY;                                                    02588000
END CHECKFUN;                                                           02589000
BOOLEAN STREAM PROCEDURE MORETHAN6(P);                                  02590000
BEGIN SI ~ P;                                                           02591000
   IF SC ! " " THEN TALLY ~ 1;                                          02592000
   MORETHAN6 ~ TALLY;                                                   02593000
END MORETHAN6;                                                          02594000
INTEGER I; ALPHA ID;                                                    02595000
INTEGER STOR ;                                                          02596000
   IF ACCUM[1] = "      " THEN                                          02597000
   BEGIN XTA ~ CHAR; FLOG(16); GO TO XIT END;                           02598000
   IF CHAR = "=     " OR CHAR = "#     " THEN GO TO XIT;                02599000
   IF CHAR = "~     " THEN GO TO XIT;                                   02600000
   IF CHAR ! "(     " AND CHAR ! "%     " THEN GO TO RESWD;             02601000
   IF MORETHAN6(ACCUM[2]) THEN GO TO RESWD;                             02602000
   COMMENT  AT THIS POINT WE HAVE <ID> ( .                              02603000
   THIS MUST BE ONE OF THE FOLLOWING:                                   02604000
   ASSIGNEMNT STATEMENT WITH SUBSCRIPTED VARIABLE AT THE LEFT.          02605000
   STATEMENT FUNCTION DECLARATION.                                      02606000
CALL, REAL, ENTRY, GO TO, READ, WRITE, FORMAT, IF, DATA, CHAIN, PRINT OR02607000
  PUNCH;                                                                02608000
   IF I ~ SEARCH(T) > 0 THEN                                            02609000
         IF GET(I).CLASS = ARRAYID THEN GO TO XIT;                      02610000
   ID ~ T; ID.[36:12] ~ " ";                                            02611000
    FOR I~0 THRU RSP DO IF RESERVEDWORDSLP[I]=ID THEN IF (IF STOR       02612000
    ~RESLENGTHLP[I]-4<1 THEN TRUE ELSE COMPLETECHECK(ACCUM[2],          02613000
    RESERVEDWORDSLP[I+RSP1],STOR)) THEN GO FOUND1 ;                     02614000
   GO TO XIT;                                                           02615000
   FOUND1:                                                              02616000
   NEXT ~ LPGLOBAL[I];                                                  02617000
   T ~ "      ";                                                        02618000
   XFER(ACR0, T, NEXTACC, I~RESLENGTHLP[I], IF I> 6 THEN 6 ELSE I);     02619000
   GO TO DONE;                                                          02620000
   RESWD:                                                               02621000
   COMMENT  AT THIS POINT WE KNOW THE <ID> MUST BE A SPECIAL WORD       02622000
   TO IDENTIFY THE STATEMENT TYPE;                                      02623000
   ID ~ T; ID.[36:12] ~ " ";                                            02624000
   IF T = "ASSIGN" THEN                                                 02625000
   BEGIN                                                                02626000
      NEXTSCN ~ SCN; SCN ~ 14;                                          02627000
      NEXTACC ~ NEXTACC2 ~ "      ";                                    02628000
      XFERA(ACR0, NEXTACC, NEXTACC2);                                   02629000
      NEXT ~ 1;                                                         02630000
      GO TO XIT;                                                        02631000
   END;                                                                 02632000
    FOR I~1 THRU RSH DO IF RESERVEDWORDS[I]=ID THEN IF (IF STOR~        02633000
    RESLENGTH[I]-4<1 THEN TRUE ELSE COMPLETECHECK(ACCUM[2],RESERVEDWORDS02634000
    [I+RSH1],IF STOR>8 THEN 8 ELSE STOR)) THEN GO FOUND2 ;              02635000
   XTA ~ T; FLOG(16); GO TO XIT;                                        02636000
   FOUND2:                                                              02637000
   NEXT ~ I+1;                                                          02638000
   T ~ "      ";                                                        02639000
   XFER(ACR0, T, NEXTACC, I~RESLENGTH  [I], IF I> 6 THEN 6 ELSE I);     02640000
   DONE: NEXTSCN ~ SCN;                                                 02641000
   SCN ~ 6;                                                             02642000
   IF NEXTACC = "FUNCTI" THEN                                           02643000
      IF CHECKFUN(ACR0, NEXTACC, I+6) THEN SCN ~ 13;                    02644000
   XIT:                                                                 02645000
   EOSTOG~FALSE;                                                        02646000
END CHECKRESERVED;                                                      02647000
                                                                        02648000
BOOLEAN PROCEDURE CHECKOCTAL;                                           02649000
BEGIN                                                                   02650000
   INTEGER S, T; LABEL XIT;                                             02651000
INTEGER STREAM PROCEDURE COUNT(ACRV,T);   VALUE ACRV,T ;                02652000
   BEGIN                                                                02653000
   LOCAL A,B;   SI~LOC T;   SI~SI+7 ;                                   02654000
   IF SC="1" THEN BEGIN SI~ACRV;IF SC="0" THEN SI~SI+1 END ELSE SI~ACRV;02655000
   IF SC!" " THEN                                                       02656000
      BEGIN A~SI;                                                       02657000
    17(IF SC>"7" THEN BEGIN TALLY~17; JUMP OUT END ELSE IF SC < "0" THEN02658000
      BEGIN IF SC!" " THEN TALLY~17; JUMP OUT END; SI~SI+1;             02659000
      TALLY~TALLY+1) ;                                                  02660000
      B~TALLY;   SI~LOC B;   SI~SI+7 ;                                  02661000
      IF SC="+" THEN BEGIN SI~A; IF SC>"3" THEN TALLY~17 END;           02662000
      END ;                                                             02663000
   COUNT~TALLY ;                                                        02664000
   END OF COUNT ;                                                       02665000
ALPHA STREAM PROCEDURE CONV(ACRV, S, T); VALUE ACRV, S, T;              02666000
BEGIN SI ~ ACRV; IF SC = "0" THEN SI ~ SI+1;                            02667000
   DI ~ LOC CONV; SKIP S DB;                                            02668000
   T(SKIP 3 SB; 3(IF SB THEN DS ~ SET ELSE DS ~ RESET; SKIP 1 SB));     02669000
END CONV;                                                               02670000
   IF T~COUNT(ACR0,1) = 0 THEN                                          02671000
   BEGIN S ~ 1;                                                         02672000
      IF T ~ CHAR ! "+     " AND T ! "&     " THEN                      02673000
      IF T = "-     " THEN S ~ -1 ELSE GO TO XIT;                       02674000
      SCANX(4, 4, 3, 3, 10, 10);                                        02675000
      IF SCN ! 10 THEN GO TO XIT;                                       02676000
      IF T~COUNT(ACR1,2) = 0 OR T > 16 THEN GO TO XIT ;                 02677000
      FNEXT ~ CONV(ACR1, (16-T)|3, T);                                  02678000
      IF S < 0 THEN FNEXT ~ -FNEXT;                                     02679000
   END ELSE IF T < 17 THEN FNEXT~CONV(ACR0,(16-T)|3,T) ELSE GO TO XIT ; 02680000
   CHECKOCTAL ~ TRUE;                                                   02681000
   NEXT ~ NUM;                                                          02682000
   NUMTYPE ~ REALTYPE;                                                  02683000
   XIT:                                                                 02684000
END CHECKOCTAL;                                                         02685000
                                                                        02686000
PROCEDURE HOLLERITH;                                                    02687000
BEGIN                                                                   02688000
   REAL T, COL1, T2, ENDP;                                              02689000
   LABEL XIT;                                                           02690000
   INTEGER STREAM PROCEDURE STRCNT(S,D,SZ); VALUE S,SZ;                 02691000
    BEGIN                                                               02692000
         SI ~ S; DI ~ D;DS ~ 8 LIT "00      "; DI ~ D;                  02693000
         DI ~ D; DI ~ DI + 2; DS ~SZ CHR; STRCNT ~ SI;                  02694000
    END STRCNT;                                                         02695000
   INTEGER STREAM PROCEDURE RSTORE(S,D,SKP,SZ);                         02696000
         VALUE S, SKP, SZ;                                              02697000
    BEGIN                                                               02698000
         DI ~ D;                                                        02699000
         SI ~ S; DI ~DI + SKP; DS ~ SZ CHR; RSTORE ~ SI;                02700000
    END RSTORE;                                                         02701000
   F1 ~ FNEXT;                                                          02702000
   NUMTYPE ~ STRINGTYPE;                                                02703000
   T ~ 0 & NCR[30:33:15] & NCR[45:30:3];                                02704000
   COL1 ~ 0 & INITIALNCR[30:33:15];                                     02705000
   ENDP ~ COL1 + 72;                                                    02706000
   STRINGSIZE ~ 0;                                                      02707000
   WHILE F1 >0 DO                                                       02708000
   BEGIN                                                                02709000
    T2 ~ IF F1 > 6 THEN 6 ELSE F1;                                      02710000
      IF STRINGSIZE > MAXSTRING THEN                                    02711000
         BEGIN FLAG(120); STRINGSIZE ~ 0 END;                           02712000
    IF T+T2> ENDP THEN IF DCINPUT OR FREEFTOG THEN                      02713000
         BEGIN XTA~BLANKS;  FLOG(150);  GO TO XIT END                   02714000
    ELSE BEGIN                                                          02715000
      IF TSSEDITOG THEN IF NOT DCINPUT THEN TSSED(BLANKS,1) ;           02716000
      NCR ~ STRCNT(NCR, STRINGARRAY[STRINGSIZE], ENDP-T);               02717000
      IF NOT CONTINUE THEN                                              02718000
         BEGIN FLOG(43); GO TO XIT END;                                 02719000
      IF READACARD THEN;                                                02720000
      IF LISTOG THEN PRINTCARD;                                         02721000
      NCR ~ RSTORE(NCR,STRINGARRAY[STRINGSIZE],ENDP-T+2,T2-(ENDP-T));   02722000
      STRINGSIZE ~ STRINGSIZE+1;                                        02723000
      F1 ~ F1 - T2;                                                     02724000
      T ~ COL1 + 6 + T2 - (ENDP - T);                                   02725000
    END ELSE                                                            02726000
    BEGIN                                                               02727000
       NCR ~ STRCNT(NCR, STRINGARRAY[STRINGSIZE], T2);                  02728000
       STRINGSIZE ~ STRINGSIZE +1;                                      02729000
       T ~ T +T2;                                                       02730000
       F1 ~ F1 - T2;                                                    02731000
    END;                                                                02732000
    END;                                                                02733000
    NUMTYPE ~ STRINGTYPE;                                               02734000
    SCN ~ 1;                                                            02735000
    XIT:                                                                02736000
END HOLLERITH;                                                          02737000
PROCEDURE QUOTESTRING;                                                  02738000
BEGIN                                                                   02739000
   REAL C;                                                              02740000
   LABEL XIT;                                                           02741000
   ALPHA STREAM PROCEDURE STRINGWORD(S,D,SKP,SZ,C);                     02742000
   VALUE S,SKP,SZ;                                                      02743000
   BEGIN                                                                02744000
      LABEL QT, XIT;                                                    02745000
      DI ~ D; SI ~ S;                                                   02746000
      DI ~ DI+SKP; DI ~ DI+2;                                           02747000
      TALLY ~ SKP;                                                      02748000
      SZ( IF SC = """ THEN JUMP OUT TO QT;                              02749000
          IF SC = ":" THEN JUMP OUT TO QT;                              02750000
          IF SC = "@" THEN JUMP OUT TO QT;                              02751000
          IF SC = "]" THEN JUMP OUT TO XIT;                             02752000
          DS ~ CHR; TALLY ~ TALLY+1);                                   02753000
      GO TO XIT;                                                        02754000
      QT: TALLY ~ TALLY+7; SI ~ SI+1;                                   02755000
      XIT: STRINGWORD ~ SI; S ~ TALLY;                                  02756000
      SI ~ LOC S; DI ~ C; DS ~ WDS;                                     02757000
   END STRINGWORD;                                                      02758000
   STRINGSIZE ~ 0;                                                      02759000
   DO                                                                   02760000
   BEGIN                                                                02761000
      IF STRINGSIZE > MAXSTRING THEN                                    02762000
      BEGIN FLAG(120); STRINGSIZE ~ 0 END;                              02763000
      STRINGARRAY[STRINGSIZE] ~ BLANKS;                                 02764000
      NCR ~ STRINGWORD(NCR, STRINGARRAY[STRINGSIZE], 0, 6, C);          02765000
      IF C<6 THEN IF DCINPUT OR FREEFTOG                                02766000
                  THEN BEGIN XTA~BLANKS; FLOG(150); GO TO XIT END       02767000
      ELSE BEGIN                                                        02768000
      IF TSSEDITOG THEN IF NOT DCINPUT THEN TSSED(BLANKS,1) ;           02769000
      IF NOT CONTINUE THEN                                              02770000
         BEGIN FLOG(121); GO TO XIT END;                                02771000
         IF READACARD THEN;                                             02772000
         IF LISTOG THEN PRINTCARD;                                      02773000
         NCR ~ STRINGWORD(NCR, STRINGARRAY[STRINGSIZE  ],C,6-C,C);      02774000
      END;                                                              02775000
      STRINGSIZE ~ STRINGSIZE + 1;                                      02776000
   END UNTIL C } 7;                                                     02777000
   IF C = 7 THEN STRINGSIZE ~ STRINGSIZE-1;                             02778000
   FNEXT ~ STRINGSIZE;                                                  02779000
   NEXT ~ NUM;                                                          02780000
   SYMBOL ~ NAME ~ STRINGARRAY[0];                                      02781000
   NUMTYPE ~ STRINGTYPE;                                                02782000
   SCN ~ 1;                                                             02783000
   XIT:                                                                 02784000
END QUOTESTRING;                                                        02785000
                                                                        02786000
PROCEDURE CHECKPERIOD;                                                  02787000
BEGIN                                                                   02788000
LABEL FRACTION, XIT, EXPONENT, EXPONENTSIGN;                            02789000
LABEL NUMFINI, FPLP, CHKEXP;                                            02790000
ALPHA S, T, I, TS;                                                      02791000
 INTEGER C2;                                                            02792000
BOOLEAN CON;                                                            02793000
 IF T ~ CHAR ! ".     " THEN GO TO CHKEXP;                              02794000
SCANX(4, 9, 3, 8, 10, 11);                                              02795000
IF T ~ EXACCUM[1] = "      " THEN                                       02796000
  BEGIN IF NUMTYPE ! DOUBTYPE THEN NUMTYPE ~ REALTYPE; GO TO XIT END;   02797000
IF T = "E     " OR T = "D     " THEN GO TO EXPONENTSIGN;                02798000
IF T.[12:6] { 9 THEN GO TO FRACTION;                                    02799000
IF T.[18:6] { 9 THEN                                                    02800000
BEGIN                                                                   02801000
   IF S ~ T.[12:6] ! "E" AND S ! "D" THEN                               02802000
      BEGIN XTA ~ T; FLOG(63); GO TO XIT END;                           02803000
   EXACCUM[1].[12:6] ~ 0;                                               02804000
   I ~ 1; GO TO EXPONENT;                                               02805000
END;                                                                    02806000
IF EXACCUM[0] ! ".     " THEN GO TO XIT;                                02807000
FOR I ~ 0 STEP 1 UNTIL 10 DO                                            02808000
   IF T = PERIODWORD[I] THEN                                            02809000
   BEGIN EXACCUM[2] ~ I; SCN ~ 12; GO TO XIT END;                       02810000
GO TO XIT;                                                              02811000
FRACTION: NEXT ~ NUM;                                                   02812000
IF NUMTYPE !DOUBTYPE THEN NUMTYPE ~ REALTYPE;  XTA ~ ACR1;              02813000
FPLP:                                                                   02814000
F1 ~ 0;                                                                 02815000
XTA  ~ CONVERT(F1,C1,XTA ,TS);                                          02816000
C2 ~ C2 + C1;                                                           02817000
IF (F2 ~ FNEXT|TEN[C1]+F1) { MAX                                        02818000
 THEN FNEXT ~ F2                                                        02819000
 ELSE BEGIN                                                             02820000
      NUMTYPE ~ DOUBTYPE;                                               02821000
       CON ~ TRUE;                                                      02822000
      DOUBLE(FNEXT,DBLOW,TEN[C1],TEN[69+C1],|,                          02823000
             F1,0,+,~,FNEXT,DBLOW);                                     02824000
      END;                                                              02825000
IF TS { 9 THEN GO TO FPLP;                                              02826000
F1 ~ 0;                                                                 02827000
IF T ~ EXACCUM[0] ! "E     " AND T ! "D     " THEN                      02828000
BEGIN IF SCN = 8 THEN SCN ~ 3 ELSE SCN ~ 10;                            02829000
   GO TO NUMFINI;                                                       02830000
END;                                                                    02831000
CHKEXP:  FNEXT ~ FNEXT | 1.0;                                           02832000
F1 ~ 0;                                                                 02833000
I ~ 1;                                                                  02834000
SCANX(4, 4, 3, 3, 20, 10);                                              02835000
IF SCN = 20 THEN                                                        02836000
EXPONENTSIGN:                                                           02837000
BEGIN IF S ~ EXACCUM[0] ! "+     " AND S ! "&     " THEN                02838000
      IF S = "-     " THEN I ~ -1 ELSE                                  02839000
         BEGIN XTA ~ S; FLOG(63); SCN ~ 10; GO TO XIT END;              02840000
      SCANX(4, 4, 3, 3, 10, 10);                                        02841000
   END;                                                                 02842000
   IF (S ~ EXACCUM[1]).[12:6] > 9 THEN                                  02843000
   BEGIN XTA ~ IF S ! BLANKS THEN S ELSE T; FLOG(63); GO TO XIT END;    02844000
   EXPONENT:                                                            02845000
   IF NUMTYPE ! DOUBTYPE THEN NUMTYPE ~ REALTYPE;                       02846000
IF T.[12:6] = "D" THEN NUMTYPE ~ DOUBTYPE;                              02847000
   IF SCN = 8 THEN SCN ~ 3 ELSE IF SCN = 11 THEN SCN ~ 10;              02848000
   XTA ~ ACR1;                                                          02849000
   XTA  ~ CONVERT(F1,C1,XTA ,TS);                                       02850000
   IF I < 0 THEN F1 ~ -F1;                                              02851000
   NUMFINI:                                                             02852000
   C1 ~ F1 - C2;                                                        02853000
   IF I ~ (ABS(C1+(FNEXT.[3:6]&FNEXT[1:2:1]))) > 63 OR((ABS(C1) = I OR  02854000
       FNEXT } 5) AND ABS(F1) } 69)                                     02855000
    THEN BEGIN XTA ~ T; FLOG(87); GO TO XIT; END;                       02856000
   IF NUMTYPE ! DOUBTYPE THEN                                           02857000
   BEGIN                                                                02858000
      IF C1} 0 THEN FNEXT ~ FNEXT | TEN[C1]                             02859000
               ELSE FNEXT ~ FNEXT / TEN[-C1];                           02860000
   END ELSE                                                             02861000
   BEGIN                                                                02862000
      IF C1 } 0                                                         02863000
         THEN DOUBLE(FNEXT,DBLOW,TEN[C1],TEN[69+C1],|,~,FNEXT,DBLOW)    02864000
         ELSE DOUBLE(FNEXT,DBLOW,TEN[-C1],TEN[69-C1],/,~,FNEXT,DBLOW);  02865000
      IF CON THEN IF DBLOW.[9:33] = MAX.[9:33] THEN                     02866000
       IF FNEXT.[3:6] LSS 14                                            02867000
         THEN IF BOOLEAN(FNEXT.[2:1]) THEN                              02868000
           BEGIN DBLOW ~ 0; FNEXT ~ FNEXT + 1&FNEXT[2:2:7]; END;        02869000
   END;                                                                 02870000
   XIT:                                                                 02871000
END CHECKPERIOD;                                                        02872000
                                                                        02873000
LABEL LOOP0, NUMBER ;                                                   02874000
LABEL L,XIT;                                                            02875000
LABEL L1,L2,L3,L4,L5,L6,L7,L8,L9,L10,L11,L12,L13,L14,L15,L16,L17,       02876000
      L18,L19,L20,L21,BK ;                                              02877000
SWITCH CASEL~L1,L2,L3,L4,L5,L6,L7,L8,L9,L10,L11,L12,L13,L14,L15,        02878000
              L16,L17,L18,L19,L20,L21 ;                                 02879000
LABEL LOOP, CASESTMT;                                              %994-02880000
LABEL CASE0,CASE1,CASE2,CASE3,CASE4,CASE5,CASE6,CASE7;             %994-02881000
LABEL CASE8,CASE9,CASE10,CASE11,CASE12,CASE13,CASE14;              %994-02882000
PREC~NEXT~FNEXT~REAL(SCANENTER~FALSE) ;                                 02883000
CASESTMT:                                                               02884000
CASE SCN OF                                                             02885000
BEGIN                                                                   02886000
CASE0:                                                             %994-02887000
GO TO IF LABELR THEN CASE5 ELSE CASE1;                                  02888000
CASE1:                                                                  02889000
BEGIN                                                                   02890000
   LOOP0:                                                               02891000
   ACR ~ ACR0;                                                          02892000
   ACCUM[1] ~ BLANKS;                                                   02893000
   LOOP:                                                                02894000
   IF ADVANCE(NCR, ACR, CHR0, NCR, ACR) THEN                            02895000
      IF CONTINUE THEN                                                  02896000
%                                                                       02897000
         IF READACARD THEN                                              02898000
              BEGIN                                                     02899000
              IF LISTOG THEN PRINTCARD ;                                02900000
              IF ACR.[33:15]}ACCUMSTOP THEN                             02901000
                   BEGIN XTA~BLANKS; FLOG(175); GO LOOP0 END ;          02902000
              GO LOOP ;                                                 02903000
              END                                                       02904000
         ELSE IF T ~ ACCUM[1] = "      " THEN GO TO CASE5 ELSE SCN ~ 4  02905000
      ELSE IF T ~ ACCUM[1] = "      " THEN                              02906000
            GO TO CASE3 ELSE SCN ~ 3                                    02907000
   ELSE IF T ~ ACCUM[1] = "      " THEN GO TO CASE2 ELSE SCN ~ 2;       02908000
END;                                                                    02909000
CASE2:                                                                  02910000
BEGIN T ~ CHAR; SCN ~ 1 END;                                            02911000
CASE3:                                                                  02912000
BEGIN T ~ ";     "; NEXT ~ SEMI; SCN ~ 0;                               02913000
      IF EOSTOG THEN IF LOGIFTOG THEN BEGIN LOGIFTOG ~ FALSE; XTA ~ T;  02914000
                  FLAG(101); END;                                       02915000
      GO TO XIT;                                                        02916000
END;                                                                    02917000
CASE4:                                                             %994-02918000
BEGIN T ~ ";     "; NEXT ~ SEMI; SCN ~ 5; GO TO XIT END;                02919000
CASE5:                                                                  02920000
BEGIN T ~ "<EOF> "; NEXT ~ EOF; EOSTOG ~ FALSE; GO TO XIT END;          02921000
CASE6:                                                             %994-02922000
BEGIN T ~ ACCUM[1] ~ NEXTACC; SCN ~ NEXTSCN;                            02923000
   IF T = "      " THEN GO TO CASESTMT;                                 02924000
END;                                                                    02925000
CASE7:                                                             %994-02926000
BEGIN EOSTOG ~ TRUE;                                                    02927000
   IF LABELR THEN GO TO CASE5 ELSE GO TO CASE1;                         02928000
END;                                                                    02929000
CASE8:                                                             %994-02930000
BEGIN T ~ EXACCUM[1]; SCN ~ 3 END;                                      02931000
CASE9:                                                             %994-02932000
BEGIN T ~ EXACCUM[1]; SCN ~ 4 END;                                      02933000
CASE10:                                                            %994-02934000
BEGIN T ~ CHAR ~ EXACCUM[0]; SCN ~ 1  END;                              02935000
CASE11:                                                            %994-02936000
BEGIN T ~ EXACCUM[1]; SCN ~ 10 END;                                     02937000
CASE12:                                                            %994-02938000
BEGIN T ~ EXACCUM[1]; SCN ~ 1;                                          02939000
   IF N ~ EXACCUM[2] { 1 THEN                                           02940000
   BEGIN NEXT ~ NUM; FNEXT ~ N; GO TO XIT END;                          02941000
   NEXT ~ 0;                                                            02942000
   OP ~ N-1;                                                            02943000
   PREC ~ IF N { 4 THEN N-1 ELSE 4;                                     02944000
   GO TO XIT;                                                           02945000
END;                                                                    02946000
CASE13:                                                            %994-02947000
BEGIN T ~ "FUNCTI"; NEXT ~ 16; SCN ~ 6; GO TO XIT END;                  02948000
CASE14:                                                            %994-02949000
BEGIN T ~ ACCUM[1] ~ NEXTACC;                                           02950000
   NEXTACC ~ NEXTACC2; SCN ~ 6;                                         02951000
END;                                                                    02952000
END OF CASE STATEMENT;                                                  02953000
IF NOT FILETOG THEN                                                     02954000
   IF EOSTOG THEN                                                       02955000
      BEGIN                                                             02956000
         NEXT ~ 0;                                                      02957000
         IF T = ";     " THEN GO TO CASESTMT;                           02958000
         CHECKRESERVED;                                                 02959000
         IF NEXT > 0 THEN GO TO XIT;                                    02960000
      END;                                                              02961000
IF (IDINFO~TIPE[T.[12:6]])>0 THEN                                       02962000
    BEGIN                                                               02963000
BK: NEXT~ID ;                                                           02964000
    IF NOT FILETOG THEN                                                 02965000
         IF SCANENTER~((FNEXT~SEARCH(T))=0) THEN FNEXT~ENTER(IDINFO,T)  02966000
         ELSE IF GET(FNEXT).CLASS=DUMMY THEN FNEXT~GET(FNEXT+2).BASE ;  02967000
    GO XIT ;                                                            02968000
    END ;                                                               02969000
GO CASEL[-IDINFO];    % SEE INITIALIZATION OF "TIPE". LINE 03433100%993-02970000
L1:      %DIGITS                                                   %993-02971000
BEGIN NUMTYPE ~ INTYPE; NEXT ~ NUM;  XTA ~ ACR0;                        02972000
    FNEXT ~ DBLOW ~ C1 ~ 0;                                             02973000
   XTA  ~ CONVERT(FNEXT,C1,XTA ,TS);                                    02974000
   WHILE TS { 9 DO                                                      02975000
      BEGIN                                                             02976000
         XTA  ~ CONVERT(F1,C1,XTA ,TS);                                 02977000
         IF (F2 ~ FNEXT|TEN[C1]+F1) { MAX                               02978000
          THEN FNEXT ~ F2                                               02979000
           ELSE BEGIN                                                   02980000
                   NUMTYPE ~ DOUBTYPE;                                  02981000
                   DOUBLE(FNEXT,DBLOW,TEN[C1],TEN[69+C1],|,             02982000
                          F1,0,+,~,FNEXT,DBLOW);                        02983000
               END;                                                     02984000
      END;                                                              02985000
   IF CHAR = ".     " OR CHAR = "E     " OR CHAR = "D     " THEN        02986000
    CHECKPERIOD                                                         02987000
   ELSE IF CHAR = "H     " THEN HOLLERITH;                              02988000
   GO TO XIT;                                                           02989000
END;                                                                    02990000
L2:      % >                                                      %993- 02991000
BEGIN PREC ~ 4; OP ~ 7; GO TO XIT END;                                  02992000
L3:      % }                                                      %993- 02993000
BEGIN PREC ~ 4; OP ~ 8; GO TO XIT END;                                  02994000
L4:      % & OR +                                                 %993- 02995000
BEGIN PREC ~ 5; OP ~ 10; NEXT ~ PLUS; GO TO XIT END;                    02996000
L5:      % .                                                      %993- 02997000
BEGIN                                                                   02998000
    FNEXT ~ DBLOW ~ C1 ~ 0; NUMTYPE ~ REALTYPE;                         02999000
   CHECKPERIOD;                                                         03000000
      T ~ EXACCUM[1];                                                   03001000
   IF SCN = 12 THEN                                                     03002000
   BEGIN SCN ~ 1;                                                       03003000
   IF N ~ EXACCUM[2] { 1 THEN                                           03004000
   BEGIN                                                                03005000
      NEXT ~ NUM; FNEXT ~ N;                                            03006000
      NUMTYPE ~ LOGTYPE; GO TO XIT;                                     03007000
   END;                                                                 03008000
   NEXT ~ 0;                                                            03009000
   OP ~ N-1;                                                            03010000
   PREC ~ IF N { 4 THEN N-1 ELSE 4;                                     03011000
   GO TO XIT;                                                           03012000
END;                                                                    03013000
   IF NEXT ! NUM THEN BEGIN NEXT ~ NUM; XTA ~ T; FLOG(141) END;         03014000
   GO TO XIT;                                                           03015000
END;                                                                    03016000
L6:      % % OR (                                                  %993-03017000
BEGIN NEXT ~ LPAREN; GO TO XIT END;                                     03018000
L7:      % <                                                       %993-03019000
BEGIN PREC ~ OP ~ 4; GO TO XIT END;                                     03020000
L8:      % LETTER 0                                                %993-03021000
BEGIN IF DATATOG THEN IF CHECKOCTAL THEN GO TO XIT;                     03022000
    IDINFO~TIPE[12];  GO BK ;                                           03023000
END;                                                                    03024000
L9:      % $                                                       %993-03025000
BEGIN NEXT ~ DOLLAR; GO TO XIT END;                                     03026000
L10:     % *                                                       %993-03027000
IF CHECKEXP(NCR, NCR, T) THEN                                           03028000
BEGIN PREC ~ 9; OP ~ 15; NEXT ~ UPARROW; GO TO XIT END ELSE             03029000
L11:                                                                    03030000
BEGIN PREC ~ 7; OP ~ 13; NEXT ~ STAR; GO TO XIT END;                    03031000
L12:     % -                                                       %993-03032000
BEGIN PREC ~ 5; OP ~ 11; NEXT ~ MINUS; GO TO XIT END;                   03033000
L13:     % ) OR [                                                  %993-03034000
BEGIN NEXT ~ RPAREN; GO TO XIT END;                                     03035000
L14:     % ;                                                       %993-03036000
BEGIN NEXT ~ SEMI; GO TO XIT END;                                       03037000
L15:     % {                                                       %993-03038000
BEGIN PREC ~ 4; OP ~ 5; GO TO XIT END;                                  03039000
L16:     % /                                                       %993-03040000
BEGIN PREC ~ 7; OP ~ 14; NEXT ~ SLASH; GO TO XIT END;                   03041000
L17:     % ,                                                       %993-03042000
BEGIN NEXT ~ COMMA; GO TO XIT END;                                      03043000
L18:     % !                                                       %993-03044000
BEGIN PREC ~ 4; OP ~ 9; GO TO XIT END;                                  03045000
L19:     % = OR ~ OR #                                            %993- 03046000
BEGIN NEXT ~ EQUAL; GO TO XIT END;                                      03047000
L20:     % ]                                                       %993-03048000
BEGIN XTA ~ T; FLAG(0); GO TO CASESTMT END;                             03049000
L21:     % " OR : OR @                                             %993-03050000
BEGIN QUOTESTRING; GO TO XIT END;                                       03051000
XIT:                                                                    03052000
IF DEBUGTOG THEN WRITALIST(FD,3,NEXT,T,"      ",0,0,0,0,0) ;            03053000
   XTA ~ NAME ~ T;                                                      03054000
END SCAN;                                                               03055000
                                                                        03056000
PROCEDURE WRAPUP;                                                       03057000
         COMMENT WRAPUP OF COMPILIATION;                                03058000
    BEGIN                                                               03059000
ARRAY PRT[0:7,0:127],                                                   03060000
  SEGDICT[0:7,0:127],                                                   03061000
     SEG0[0:29];                                                        03062000
ARRAY FILES[0:BIGGESTFILENB];                                           03063000
INTEGER THEBIGGEST;                                                     03064000
SAVE ARRAY FPB[0:1022]; % FILE PARAMETER BLOCK                          03065000
REAL FPS,FPE;           % START AND END OF FPB                          03066000
REAL GSEG,PRI,FID,MFID,IDNM,FILTYP,FPBI;                                03067000
BOOLEAN ALF;                                                            03068000
REAL PRTADR, SEGMNT, LNK, TSEGSZ, T1, I, FPBSZ;                         03069000
    DEFINE                                                              03070000
         SPDEUN= FPBSZ#,                                                03071000
    ENDDEF=#;                                                           03072000
ARRAY INTLOC[0:150];                                                    03073000
REAL J;                                                                 03074000
FORMAT SEGUS(A6, "  IS SEGMENT ", I4,                                   03075000
         ", PRT IS ", A4, ".");                                         03076000
LIST SEGLS(IDNM,NXAVIL,T1);                                             03077000
LABEL LA, ENDWRAPUP;                                                    03078000
 LABEL QQQDISKDEFAULT;                                             %503-03079000
                   COMMENT FORMAT OF SEGMENT DICTIONARY -RUN TIME ;     03080000
DEFINE        SGTYPF= [1:2]#, %0 = PROGRAM SEGMENTS                     03081000
              SGTYPC= 1:46:2#,%1 = MCP INTRINSIC                        03082000
                              %2 = DATA SEGMENT                         03083000
              PRTLINKF= [8:10]#,  % LINK TO FIRT PRT ENTRY              03084000
              PRTLINKC= 8:38:10#,                                       03085000
              SGLCF   = [18:15]#, % SEGMENT SIZE                        03086000
              SGLCC   = 23:38:10#,                                      03087000
              DKADRF  = [33:15]#, % RELATIVE DISK ADDRESS OF SEGMENT    03088000
                                  % OR MCP INTRINSIC NUMBER             03089000
              DKADRC  = 33:13:15#;                                      03090000
         COMMENT FORMAT OF FIRST SEGMENT OF CODE FILE- RUN TIME;        03091000
COMMENT SEGO[0:29]                                                      03092000
              WORD      CONTENTS                                        03093000
               0        LOCATION OF SEGMENT DICTIONARY                  03094000
               1        SIZE OF SEGMENT DICTIONARY                      03095000
               2        LOCATION OF PRT                                 03096000
               3        SIZE OF PRT                                     03097000
               4        LOCATION OF FILE PARAMETER BLOCK                03098000
               5        SIZE OF FILE PARAMETER BLOCK                    03099000
               6        STARTING SEGMENT NUMBER                         03100000
               7-[2:1] IND FORTRAN FAULT DEC                            03101000
               7-[18:15] NUMBER OF FILES                                03102000
               7-[33:15] CORE REQUIRED/64                               03103000
              ;                                                         03104000
         COMMENT FORMAT OF PRT;                                         03105000
           %  FLGF = [0:4] = 1101 = SET BY STREAM                       03106000
DEFINE        MODEF =[4:2]#,  % 0 = THUNK                               03107000
              MODEC=4:46:2#,  % 1 = WORD MODE PROGRAM DESCRIPTOR        03108000
                              % 2 = LABEL DESCRIPTOR                    03109000
                              % 3 = CHARACTER MODE PROGRAM DESCRIPTOR   03110000
              STOPF =[6:1]#,  % STOPPER = 1 FOR LAST DESCRIPTOR IN      03111000
              STOPC=6:47:1#,  % CHAIN OF SAME SEGMENT DESCRIPTORS       03112000
              LINKF =[7:11]#, % IF STOP = 0 THEN PRTLINK                03113000
              LINKC=7:37:11#, %             ELSE LINK TO SEGDICT        03114000
              FFF   =[18:15]#,% INDEX INTO SEGMENT DICTIONARY           03115000
              FFC   =18:33:15#,                                         03116000
              SINX = [33:15]#;% RELATIVE ADDRESS INTO SEGMENT           03117000
DEFINE        PDR = [37:5]#,                                            03118000
              PDC = [42:6]#;                                            03119000
REAL STREAM PROCEDURE MKABS(F);                                         03120000
    BEGIN                                                               03121000
         SI ~ F; MKABS ~ SI;                                            03122000
    END MKABS;                                                          03123000
REAL STREAM PROCEDURE BUILDFPB(DEST,FILNUM,FILTYP,MFID,FID,IDSZ,        03124000
                                  IDNM,SPDEUN);                         03125000
     VALUE     DEST,IDSZ,SPDEUN;                                        03126000
     BEGIN                                                              03127000
          DI ~ DEST;                                                    03128000
          SI ~ FILNUM; SI ~ SI + 6; DS ~ 2 CHR;                         03129000
          SI ~ FILTYP; SI ~ SI + 7; DS ~ CHR;                           03130000
          SI ~ MFID; SI ~ SI + 1; DS ~ 7 CHR;                           03131000
          SI ~ FID; SI ~ SI + 1; DS ~ 7 CHR;                            03132000
          SI ~ LOC IDSZ; SI ~ SI + 1; DS ~ IDSZ CHR;                    03133000
          SI~LOC SPDEUN;SI~SI+6;DS~2 CHR;%   DISK SPEED & EU NUMBER+1   03134000
          BUILDFPB ~ DI;                                                03135000
          DS ~ 2 LIT "0";                                               03136000
     END BUILDFPB;                                                      03137000
REAL STREAM PROCEDURE GITSZ(F);                                         03138000
    BEGIN                                                               03139000
         SI ~ F; SI ~SI + 7; TALLY ~ 7;                                 03140000
         3(IF SC ! " " THEN JUMP OUT;                                   03141000
           SI ~SI - 1; TALLY ~ TALLY + 63;);                            03142000
         GITSZ ~ TALLY;                                                 03143000
    END GITSZ;                                                          03144000
STREAM PROCEDURE MOVE(F,T,SZ); VALUE SZ;                                03145000
    BEGIN                                                               03146000
         SI ~ F; DI ~T; DS ~ SZ WDS;                                    03147000
         END MOVE;                                                      03148000
INTEGER PROCEDURE MOVEANDBLOCK(FROM,SIZE); VALUE SIZE;                  03149000
    ARRAY FROM[0,0]; INTEGER SIZE;                                      03150000
    BEGIN                                                               03151000
         REAL T,NSEGS,J,I;                                              03152000
    STREAM PROCEDURE M2(F,T); BEGIN SI~F; DI~T; DS ~ 2 WDS; END M2;     03153000
         NSEGS ~ (SIZE+29) DIV 30;                                      03154000
         IF DALOC DIV CHUNK < T ~ (DALOC + NSEGS) DIV CHUNK             03155000
           THEN DALOC ~ CHUNK | T;                                      03156000
         MOVEANDBLOCK ~ DALOC;                                          03157000
         DO BEGIN FOR J ~ 0 STEP 2 WHILE J < 30 AND I<SIZE DO           03158000
          BEGIN                                                         03159000
              M2(FROM[I.[36:5],I.[41:7]],CODE(J));                      03160000
              I ~ I+2;                                                  03161000
          END;                                                          03162000
              WRITE(CODE[DALOC]);                                       03163000
              DALOC ~ DALOC + 1;                                        03164000
            END UNTIL I } SIZE;                                         03165000
    END MOVEANDBLOCK;                                                   03166000
STREAM PROCEDURE MDESC(VLU,PRT); VALUE VLU;                             03167000
    BEGIN                                                               03168000
         DI ~ LOC VLU; DS ~ SET;   % FLAG BIT                           03169000
         DI ~ PRT; SI ~ LOC VLU; DS ~ WDS;                              03170000
    END MDESC;                                                          03171000
INTEGER STREAM PROCEDURE MAKEINT(S);                                    03172000
BEGIN LABEL LOOP;     LOCAL T;                                          03173000
SI ~ S;   SI ~ SI + 3;                                                  03174000
LOOP: IF SC } "0" THEN                                                  03175000
      BEGIN TALLY ~ TALLY + 1;   SI ~ SI + 1;  GO TO LOOP;   END;       03176000
T ~ TALLY;   SI ~ S;  SI ~ SI + 3;  DI ~ LOC MAKEINT;  DS ~ T OCT;      03177000
END MAKEINT;                                                            03178000
LABEL FOUND;                                                            03179000
FORMAT                                                                  03180000
         FILEF(A1, A6, X1,                                              03181000
         "FILE IDENTIFIER, PRT IS ", A4, "."),                          03182000
         BLOKF(A6, X5, "COMMON BLOCK, PRT IS ", A4,                     03183000
              ", LENGTH IS ", I5, " WORDS.");                           03184000
                                                                        03185000
         COMMENT DUMP OUT ACCUMULATED FORMAT AND NAME ARRAYS;           03186000
            IF FNNINDEX ! 0 THEN                                        03187000
            BEGIN FNNPRT ~ PRGDESCBLDR(1,FNNPRT,0,NXAVIL ~ NXAVIL + 1); 03188000
                  WRITEDATA(FNNINDEX,NXAVIL,FNNHOLD);                   03189000
            END;                                                        03190000
             IF SAVESUBS > 0 THEN                                       03191000
               BEGIN T1 ~ GET(T ~ GLOBALSEARCH(".SUBAR")+2);            03192000
                     PUT(T,T1~T1&SAVESUBS[TOSIZE]);                     03193000
               END;                                                     03194000
         T1~PRGDESCBLDR(1,23,0,NSEG~NXAVIL~NXAVIL+1) ; % BUILD TPAR     03195000
         FILL LSTT[*] WITH 21(0),8("        ") ;       % R+23           03196000
         WRITEDATA(29,NXAVIL,LSTT) ;                                    03197000
         PDPRT[(PDINX-1).[37:5],(PDINX-1).[42:6]].[6:1]~1 ; % SAVE BIT  03198000
         T1 ~ PRGDESCBLDR(1,22,0,NSEG ~ NXAVIL ~ NXAVIL + 1);           03199000
         WRITEDATA (138,NXAVIL,TEN);   % POWERS OF TEN TABLE            03200000
         IF  LSTI > 0 THEN                                              03201000
    BEGIN                                                               03202000
         WRITEDATA(LSTI, NXAVIL ~ NXAVIL+1, LSTP);                      03203000
         LSTA ~ PRGDESCBLDR(1, LSTA, 0, NXAVIL);                        03204000
    END;                                                                03205000
         IF TWODPRTX ! 0 THEN                                           03206000
    BEGIN                                                               03207000
         FILL LSTT[*] WITH                                              03208000
         OCT0000000421410010,                                           03209000
         OCT0301001301412025,                                           03210000
         OCT2021010442215055,                                           03211000
         OCT2245400320211025,                                           03212000
         OCT0106177404310415,                                           03213000
         OCT1025042112350000;                                           03214000
         T ~ PRGDESCBLDR(0, TWODPRTX, 0, NXAVIL ~ NXAVIL+1);            03215000
         WRITEDATA(-6, NXAVIL, LSTT);                                   03216000
    END;                                                                03217000
              COMMENT DECLARE GLOBAL FILES AND ARRAYS;                  03218000
         FPS ~ FPE ~ MKABS(FPB);                                        03219000
         SEGMENTSTART;                                                  03220000
         F2TOG ~ TRUE;                                                  03221000
         GSEG ~ NSEG;                                                   03222000
         FPBI ~ 0;                                                      03223000
         EMITL(0); EMITL(2); EMITO(SSF);                                03224000
         EMITL(1);           % SET BLOCK COUNTER TO 1                   03225000
         EMITL(16); EMITO(STD);                                         03226000
         EMITL(0); EMITOPDCLIT(23); EMITO(DEL);                         03227000
         EMITL(REAL(HOLTOG)); EMITPAIR(21,STD);                         03228000
         I ~ GLOBALNEXTINFO;  WHILE I < 4093 DO                         03229000
    BEGIN                                                               03230000
         I ~ I+3;                                                       03231000
         GETALL(I,INFA,INFB,INFC);                                      03232000
     IF INFA.CLASS = FILEID THEN   %SEE COMMENTS ON LINE 02118000  %992-03233000
    BEGIN                                                               03234000
         FPBI ~ FPBI + 1;                                               03235000
         PRI ~ INFA   .ADDR;                                            03236000
         IF (XTA ~ INFB   ).[18:6] < 10 THEN                            03237000
    BEGIN                                                               03238000
         IF XTA ~ MAKEINT(XTA) > BIGGESTFILENB THEN FLAG(77) ELSE       03239000
         FILES[XTA] ~ PRI;                                              03240000
         IF XTA > THEBIGGEST THEN THEBIGGEST ~ XTA;                     03241000
    END;                                                                03242000
         EMITO(MKS);                                                    03243000
         IF J ~ INFC   .ADINFO ! 0 THEN   %  OPTION FILE                03244000
    BEGIN FILTYP ~ INFC   .LINK;                                        03245000
         IDNM ~ "      "&"FILE"[6:24:24]&INFB[30:18:18];                03246000
         T1 ~ GITSZ(IDNM);                                              03247000
         FID ~ FILEINFO[2,J];                                           03248000
         MFID ~ FILEINFO[1,J];                                          03249000
         IF FILTYP}10 AND (T~FILEINFO[3,J].DKAREASZ)!0 THEN             03250000
              BEGIN %%% SET UP <DISK FILE DESCRIPTION>;                 03251000
              SPDEUN~FILEINFO[3,J].SENSPDEUNF;                          03252000
              B~IF (B~((J~FILEINFO[0,J]).[18:12])/(IF A~J.[30:12]{0 THEN03253000
                 1 ELSE A)){0 THEN 1 ELSE B ;                           03254000
                    %%% B=ORIGINAL "BLOCKING" SIZE = # LOGRECS/PHYSREC. 03255000
              A~ENTIER(B|ENTIER(T/(20|B)+.999999999)+.5) ;              03256000
                    %%% T="AREA" SIZE = # LOGRECS IN TOTAL FILE.        03257000
                    %%% A=# LOGRECS PER ROW.                            03258000
              B~ENTIER(T/A+.999999999) ;                                03259000
                    %%% B = # ROWS IN FILE.                             03260000
                    %%% EQUIVALENT ALGOL FILE DESCRIPTION = [B:A].      03261000
                    %%% THE ABOVE LOGIC YIELDS: SHORTEST ROW CONTAINING 03262000
                    %%% AN INTEGER NUMBER OF PHYSICAL RECORDS AND WHICH 03263000
                    %%% REQUIRES 20 OR FEWER ROWS FOR THE TOTAL AREA, T.03264000
              EMITNUM(B); EMITNUM(A) ;                                  03265000
              END ELSE                                                  03266000
              BEGIN EMITL(0); EMITL(0);                                 03267000
                    J ~ FILEINFO[0,J]; % THIS ONE HAS ALL THE GOODIES   03268000
              END;                                                      03269000
 QQQDISKDEFAULT:                                                   %503-03270000
         ESTIMATE~ESTIMATE+(J.[42:6])|(IF A~J.[18:12]=0 THEN J.[30:12]  03271000
              ELSE A) ;                                                 03272000
         EMITL(J.[4:2]);   %  LOCK                                      03273000
         EMITL(FPBI);   %   FILE PARAM INDEX                            03274000
         EMITDESCLIT(PRI);   %  PRT OF FILE                             03275000
         EMITL(J.[42:6]);   %  # BUFFERS                                03276000
         EMITL(J.[3:1]);  %  RECORDING MODE                             03277000
         EMITNUM(J.[30:12]) ;  % RECORD SIZE                            03278000
         EMITNUM(J.[18:12]) ;  % BLOCK SIZE                             03279000
         EMITNUM(J.[ 6:12]) ;  % SAVE FACTOR                            03280000
    END ELSE                                                            03281000
    BEGIN                                                               03282000
         ALF ~TRUE;                                                     03283000
         IF(FILTYP~INFC.LINK=2 OR FILTYP=12) AND INFB.[18:6]{9 THEN     03284000
           IDNM ~ 0&"FILE"[6:24:24]&INFB[30:18:18]                      03285000
              ELSE                                                      03286000
    BEGIN                                                               03287000
         ALF ~ FALSE;                                                   03288000
              IF (IDNM ~ "    "&INFB[6:18:30]) = "READR  " THEN         03289000
                  IDNM ~ "READER ";                                     03290000
    END;                                                                03291000
IF IDNM="READER " OR IDNM="FILE5  " THEN IDNM~"CARD   " ELSE       %503-03292000
IF IDNM="FILE6  " THEN BEGIN IDNM~"PRINTER";FILTYP~18;END ELSE     %503-03293000
 BEGIN                                                             %503-03294000
 EMITL(20);  EMITL(600);  FILTYP~12;  %20 | 600 REC DISK           %503-03295000
    J~0&2[42:42:6]&10[30:36:12]&300[18:36:12];                     %503-03296000
 FID~IDNM;  MFID~"FORTEMP";  T1~GITSZ(IDNM);                       %503-03297000
     GO TO QQQDISKDEFAULT;                                         %503-03298000
 END;                                                              %503-03299000
        T1 ~ GITSZ(IDNM);                                               03300000
        FID ~ IDNM;                                                     03301000
        MFID ~ 0;                                                       03302000
     IF DCINPUT AND ALF THEN BEGIN                                      03303000
        EMITL(20);           % DISK ROWS                                03304000
        EMITL(100);          % DISK RECORD PER ROW                      03305000
        EMITL(2);            % REWIND AND LOCK                          03306000
        EMITL(FPBI);         % FILE NUMBER                              03307000
        EMITDESCLIT(PRI);    % PRT OF FILE                              03308000
        EMITL(2);            % NUMBER OF BUFFERS                        03309000
        EMITL(1);            % RECORDING MODE                           03310000
        EMITL(10);           % RECORD SIZE                              03311000
        EMITL(30);           % BLOCK SIZE                               03312000
        EMITL(1);            % SAVE FACTOR                              03313000
     END ELSE                                                           03314000
     BEGIN                                                              03315000
        EMITL(0);      % DISK ROWS                                      03316000
        EMITL(0);      % DISK RECORDS PER ROW                           03317000
        EMITL(0);      % REWIND & RELEASE                               03318000
        EMITL(FPBI);   % FILE NUMBER                                    03319000
        EMITDESCLIT(PRI);  % PRT OF FILE                                03320000
        EMITL(2);      % 2 BUFFERS                                      03321000
        EMITL(REAL(ALF));                                               03322000
        EMITL(IF FILTYP = 0 THEN 10 ELSE 17);                           03323000
        EMITL(0);     % 15 WORD BUFFERS                                 03324000
        EMITL(0);      % SAVE FACTOR (SCRATCH BY DEFAULT)               03325000
     END;                                                               03326000
   END;                                                                 03327000
        EMITL(11);     % INPUT OR OUTPUT                                03328000
        EMITL(8);      % SWITCH CODE FOR BLOCK                          03329000
        EMITOPDCLIT(5);  % CALL BLOCK                                   03330000
        FPE~BUILDFPB(FPE,FPBI,FILTYP,MFID,FID,T1,IDNM,SPDEUN);          03331000
        IF PRTOG THEN WRITALIST(FILEF,3,IDNM.[6:6],IDNM,B2D(PRI),       03332000
        0,0,0,0,0) ;                                                    03333000
   END                                                                  03334000
        ELSE                                                            03335000
        IF INFA.CLASS = BLOCKID THEN                                    03336000
   BEGIN                                                                03337000
        IF PRTOG THEN WRITALIST(BLOKF,3,INFB,B2D(INFA.ADDR),            03338000
        INFC.SIZE,0,0,0,0,0) ;                                          03339000
        IF INFA < 0 THEN ARRAYDEC(I);                                   03340000
   END;                                                                 03341000
        IF (T1 ~ INFA   .CLASS) } FUNID                                 03342000
         AND T1 { SUBRID THEN                                           03343000
   BEGIN                                                                03344000
        PRI ~ 0;                                                        03345000
        IF INFA   .SEGNO = 0 THEN                                       03346000
   BEGIN                                                                03347000
        A~0;  B~NUMINTM1 ;                                              03348000
        WHILE A+1 < B DO                                                03349000
        BEGIN                                                           03350000
           PRI ~ REAL(BOOLEAN(A+B) AND BOOLEAN(1022));                  03351000
           IF IDNM ~ INT[PRI] = INFB THEN GO TO FOUND;                  03352000
           IF INFB < IDNM THEN B ~ PRI.[36:11] ELSE A ~ PRI.[36:11];    03353000
        END;                                                            03354000
        IF IDNM ~ INT[PRI~(A+B)|2-PRI] = INFB THEN GO TO FOUND;         03355000
        XTA ~ INFB; FLAG(30);                                           03356000
        GO TO LA;                                                       03357000
   FOUND:                                                               03358000
        IF (T1~INT[PRI+1].INTPARMS)!0                                   03359000
        AND INFC     < 0                                                03360000
        THEN IF T1 ! INFC.NEXTRA THEN                                   03361000
           BEGIN XTA ~ INFB   ; FLAG(28); END;                          03362000
        IF (FID~INTLOC[MFID~INT[PRI+1].INTNUM])=0 THEN                  03363000
   BEGIN                                                                03364000
        PDPRT[PDIR,PDIC] ~                                              03365000
          0&1[STYPC]                                                    03366000
           &(FID ~ INTLOC[MFID] ~ NXAVIL ~ NXAVIL + 1)[SGNOC]           03367000
           &1[SEGSZC];                                                  03368000
        PDINX ~ PDINX + 1;                                              03369000
   END;                                                                 03370000
        T1 ~ PRGDESCBLDR(1,INFA   .ADDR,0,FID);                         03371000
        IF PRTOG THEN WRITALIST(SEGUS,3,IDNM,FID,B2D(T1),0,0,0,0,0) ;   03372000
        IF INT[PRI+1] < 0 THEN                                          03373000
   BEGIN                                                                03374000
        T1 ~ PRGDESCBLDR(1,INT[PRI+1].INTPRT,0,FID);                    03375000
        INT[PRI+1] ~ ABS(INT[PRI + 1]);                                 03376000
   END;                                                                 03377000
   END                                                                  03378000
        ELSE IF PRTOG THEN WRITALIST(SEGUS,3,INFB,                      03379000
        INFA.SEGNO,B2D(INFA.ADDR),0,0,0,0,0) ;                          03380000
   END;                                                                 03381000
   LA:                                                                  03382000
   END;                                                                 03383000
COMMENT MUST FOLLOW THE FOR STATEMENT;                                  03384000
IF FILEARRAYPRT ! 0 THEN                                                03385000
BEGIN   %  BUILDING OBJECT TIME FILE SEARCH ARRAY                       03386000
      J ~ PRGDESCBLDR(1,FILEARRAYPRT,0,NXAVIL ~ NXAVIL + 1);            03387000
      WRITEDATA(THEBIGGEST + 1,NXAVIL,FILES);                           03388000
END;                                                                    03389000
         XTA ~ BLANKS;                                                  03390000
         IF NXAVIL > 1023 THEN FLAG(45);                                03391000
         IF PRTS > 1023 THEN FLAG(46);                                  03392000
         IF STRTSEG = 0 THEN FLAG(65);                                  03393000
         PRI ~ 0;                                                       03394000
         WHILE (IDNM ~ INT[PRI]) ! 0 DO                                 03395000
         IF INT[PRI+1] } 0 THEN PRI ~ PRI + 2 ELSE                      03396000
    BEGIN                                                               03397000
         IF (FID~INTLOC[MFID~INT[PRI+1].INTNUM])=0 THEN                 03398000
    BEGIN                                                               03399000
         PDPRT[PDIR,PDIC] ~                                             03400000
           0&1[STYPC]                                                   03401000
            &MFID[DKAC]                                                 03402000
            &(FID ~ INTLOC[MFID] ~ NXAVIL ~ NXAVIL + 1)[SGNOC]          03403000
            &1[SEGSZC];                                                 03404000
         PDINX ~ PDINX + 1;                                             03405000
    END;                                                                03406000
         T1 ~ PRGDESCBLDR(1,INT[PRI + 1].INTPRT,0,FID);                 03407000
         PRI ~ PRI+2;                                                   03408000
    END;                                                                03409000
         FOR I ~ 1 STEP 1 UNTIL BDX DO                                  03410000
         BEGIN EMITO(MKS); EMITOPDCLIT(BDPRT[I]) END;                   03411000
         EMITO(MKS);                                                    03412000
         EMITOPDCLIT(STRTSEG.[18:15]);                                  03413000
         T ~ PRGDESCBLDR(1,0,0,NSEG);                                   03414000
         SEGMENT((ADR+4) DIV 4,NSEG,FALSE,EDOC);                        03415000
         IF ERRORCT ! 0 THEN GO TO ENDWRAPUP;                           03416000
         FILL SEG0[*] WITH                                              03417000
              OCT020005,     % BLOCK                                    03418000
              OCT220014,     % WRITE                                    03419000
              OCT230015,     % READ                                     03420000
              OCT240016;     % FILE CONTROL                             03421000
              COMMENT INTRINSIC FUNCTIONS;                              03422000
         FOR I ~ 0 STEP 1 UNTIL 3 DO                                    03423000
    BEGIN                                                               03424000
         T1 ~ PRGDESCBLDR(1,SEG0[I].[36:12],0,                          03425000
                           NSEG ~ NXAVIL ~ NXAVIL + 1);                 03426000
         PDPRT[PDIR,PDIC] ~                                             03427000
           0&1[STYPC]                                                   03428000
            &(SEG0[I].[30:6])[DKAC]                                     03429000
            &NXAVIL[SGNOC]                                              03430000
            &1[SEGSZC];                                                 03431000
         PDINX ~ PDINX + 1;                                             03432000
    END;                                                                03433000
              COMMENT GENERATE PRT AND SEGMENT DICTIONARY;              03434000
         PRT[0,41] ~ PDPRT[0,0] & 63[10:42:6];  % USED FOR FAULT OPTN   03435000
         FOR I ~ 1 STEP 1 UNTIL PDINX-1 DO                              03436000
         IF (T1~PDPRT[I.PDR,I.PDC]).SEGSZF = 0 THEN                     03437000
    BEGIN           % PRT ENTRY                                         03438000
         PRTADR ~T1.PRTAF;                                              03439000
         SEGMNT ~T1.SGNOF;                                              03440000
         LNK ~ SEGDICT[SEGMNT.[36:5], SEGMNT.[41:7]].PRTAF;             03441000
         MDESC(T1.RELADF&SEGMNT[FFC]                                    03442000
             &(REAL(LNK=0))[STOPC]                                      03443000
             &(IF LNK=0 THEN SEGMNT ELSE LNK)[LINKC]                    03444000
              &(T1.DTYPF)[MODEC]                                        03445000
              &5[1:45:3],                                               03446000
              PRT[PRTADR.[36:5],PRTADR.[41:7]]);                        03447000
         SEGDICT[SEGMNT.[36:5],SEGMNT.[41:7]].PRTLINKF ~ PRTADR;        03448000
    END                                                                 03449000
         ELSE                                                           03450000
    BEGIN          % SEGMENT DICTIONARY ENTRY                           03451000
         SEGMNT ~ T1.SGNOF;                                             03452000
         SEGDICT[SEGMNT.[36:5],SEGMNT.[41:7]]~                          03453000
         SEGDICT[SEGMNT.[36:5],SEGMNT.[41:7]]                           03454000
             &T1[SGLCC]                                                 03455000
             &T1[DKADRC]                                                03456000
             & T1[4:12:1]                                               03457000
             &T1[6:6:1]                                                 03458000
             &T1[1:1:2];                                                03459000
         TSEGSZ ~ TSEGSZ + T1.SEGSZF;                                   03460000
    END;                                                                03461000
              COMMENT WRITE OUT FILE PARAMETER BLOCK;                   03462000
         FPBSZ ~ ((FPE.[33:15] - FPS) | 8 + FPE.[30:3] + 9) DIV 8;      03463000
         I ~ (FPBSZ + 29) DIV 30;                                       03464000
         IF DALOC DIV CHUNK < T1 ~ (DALOC +I) DIV CHUNK                 03465000
           THEN DALOC ~ CHUNK | T1;                                     03466000
         SEG0[4] ~ DALOC;                                               03467000
         SEG0[5] ~ FPBSZ;                                               03468000
         SEG0[5].FPBVERSF~FPBVERSION;                                   03469000
         FOR I ~ 0 STEP 30 WHILE I < FPBSZ DO                           03470000
    BEGIN                                                               03471000
         MOVE(FPB[I],CODE(0),IF (FPBSZ-I) } 30                          03472000
                             THEN 30 ELSE (FPBSZ-I));                   03473000
         WRITE(CODE[DALOC]);                                            03474000
         DALOC ~ DALOC + 1;                                             03475000
    END;                                                                03476000
         SEG0[2] ~ MOVEANDBLOCK(PRT,PRTS+1); % WRITES OUT PRT           03477000
                                            % SAVES ADDRESS OF PRT      03478000
         SEG0[3] ~ PRTS + 1;     % SIZE OF PRT                          03479000
         SEG0[0] ~ MOVEANDBLOCK(SEGDICT,NXAVIL + 1); % WRITE SEG DICT   03480000
         SEG0[1] ~ NXAVIL + 1;         % SIZE OF SEGMENT DICTIONARY     03481000
         SEG0[6] ~ -GSEG;   % FIRST SEGMENT TO EXECUTE                  03482000
         SEG0[7].[33:15] ~ FPBI;   % NUMBER OF FILES                    03483000
         SEG0[7].[18:15] ~ ESTIMATE ~ IF   % CORE ESTIMATE              03484000
           ( I ~                                                        03485000
           ESTIMATE+60+ %%% OPTION FILE BUFF SIZES + DEFAULT BUFF SIZES.03486000
           PRTS + 512   % PRT AND STACK SIZE                            03487000
          +TSEGSZ       % TOTAL SIZE OF CODE                            03488000
          + 1022   % FOR INTRINSICS                                     03489000
          +ARYSZ        % TOTAL ARRAY SIZE                              03490000
          + (MAXFILES | 28) % SIZE OF ALL FIBS                          03491000
          +FPBSZ        % SIZE OF FILE PARAMETER BLOCK                  03492000
          + (IF ESTIMATE = 0 THEN 0 ELSE (ESTIMATE + 1000))             03493000
          + (NXAVIL + 1)     % SIZE OF SEGMENT DICTIONARY               03494000
          ) > 32768 THEN 510 ELSE (I DIV 64);                           03495000
         COMMENT IF SEGSW THEN UPDATE LINDICT, SEG0[0] & WRITE IT ;     03496000
         SEG0[7].[2:1] ~ 1;  % USED FOR FORTRAN FAULT DEC;              03497000
       IF SEGSW THEN                                                    03498000
       BEGIN                                                            03499000
         FOR I ~ NXAVIL + 1 STEP -1 UNTIL 1 DO                          03500000
          IF LINEDICT[I.IR,I.IC] = 0 THEN % INDICATE NO LINE SEGMENT    03501000
             LINEDICT[I.IR,I.IC] ~ -1;   % FOR THIS SEGMENT             03502000
         SEG0[0] ~ SEG0[0] & (MOVEANDBLOCK(LINEDICT,NXAVIL+1))[TOBASE]; 03503000
       END;                                                             03504000
         WRITE(CODE[0],30,SEG0[*]);                                     03505000
         IF ERRORCT = 0 AND SAVETIME } 0 THEN LOCK(CODE);               03506000
    ENDWRAPUP:                                                          03507000
         LOCK(TAPE);       %RW/L TAPE FILE OR LOCK DISK            %502-03508000
         IF NTAPTOG THEN LOCK(NEWTAPE,*); %RW/L TAPE OR CRUNCH DISK%502-03509000
    END WRAPUP;                                                         03510000
PROCEDURE INITIALIZATION;                                               03511000
BEGIN COMMENT   INITIALIZATION;                                         03512000
ALPHA STREAM PROCEDURE MKABS(P);                                        03513000
BEGIN SI ~ P; MKABS ~ SI END;                                           03514000
STREAM PROCEDURE BLANKOUT(CRD, N); VALUE N;                             03515000
BEGIN DI ~ CRD; N(DS ~ LIT " ") END;                                    03516000
BLANKOUT(CRD[10], 40);                                                  03517000
BLANKOUT(LASTSEQ, 8);                                                   03518000
BLANKOUT(LASTERR, 8);                                                   03519000
INITIALNCR ~ MKABS(CRD[0])&6[30:45:3];                                  03520000
CHR0       ~ MKABS(ACCUM[0])& 2[30:45:3];                               03521000
ACR0 ~ CHR0+1;                                                          03522000
ACR1 ~ (CHR1~MKABS(EXACCUM[0]) & 2[30:45:3]) +1;                        03523000
ACCUMSTOP~MKABS(ACCUM[11]);  EXACCUMSTOP~MKABS(EXACCUM[11]) ;           03524000
BUFL ~ MKABS(BUFF) & 2[30:45:3];                                        03525000
NEXTCARD ~ 1;                                                           03526000
GLOBALNEXTINFO ~ 4093;                                                  03527000
PDINX ~ 1;                                                              03528000
LASTNEXT~1000 ;                                                         03529000
PRTS ~ 41; % CURRENTLY . . . . . LAST USED PRT                          03530000
READ(CR, 10, CB[*]);                                                    03531000
LISTOG~TRUE;  SINGLETOG~TRUE; CHECKTOG ~ FALSE;  %DEFAULT       %501-   03532000
FIRSTCALL ~ TRUE;                                                       03533000
IF BOOLEAN(ERRORCT.[46:1]) THEN LISTOG ~ FALSE;                         03534000
IF BOOLEAN(ERRORCT.[47:1]) THEN DCINPUT ~ TRUE;                         03535000
ERRORCT ~ 0;                                                            03536000
IF DCINPUT THEN SEGSW ~ TRUE;                                           03537000
IF DCINPUT THEN REMOTETOG ~ TRUE;                                       03538000
LIMIT~IF DCINPUT THEN 20 ELSE 100 ;                                     03539000
IF SEGSW THEN SEGSWFIXED ~ TRUE;                                        03540000
EXTRAINFO[0,0] ~ 0 & EXPCLASS[TOCLASS];                                 03541000
NEXTEXTRA ~ 1;                                                          03542000
LASTMODE ~ 1;                                                           03543000
DALOC ~ 1;                                                              03544000
TYPE ~ -1;                                                              03545000
   MAP[0] ~ MAP[2] ~ MAP[4] ~ MAP[7] ~ -10;                             03546000
   MAP[5] ~ 1; MAP[6] ~ 2;                                              03547000
FILL XR[*] WITH 0,0,0,0,0,0,0,                                          03548000
    "INTEGE","R    R","      ","      "," REAL ","      ",              03549000
    "LOGICA","L    L","DOUBLE","      ","COMPLE","X    X",              03550000
    "------","-    -","      ","      "," ---- ","      ",              03551000
    "------","-    -","------","      ","------","-    -";              03552000
FILL TYPES[*] WITH "      ","INTGER","      ","REAL  ",                 03553000
   "LOGCAL", "DOUBLE", "COMPLX";                                        03554000
FILL KLASS[*] WITH                                                      03555000
   "NULL  ", "ARRAY ", "VARBLE", "STFUN ",                              03556000
   "NAMLST", "FORMAT", "ERROR ", "FUNCTN",                              03557000
   "INTRSC", "EXTRNL", "SUBRTN", "COMBLK",                              03558000
   "FILE  ";                                                            03559000
FILL RESERVEDWORDSLP[*] WITH                                            03560000
   "CALL  ","ENTR  ","FORM  ","GOTO  ","IF    ","READ  ",               03561000
   "REAL  ","WRIT  ","DATA  ","CLOS  ","LOCK  ","PURG  ","CHAI  ",      03562000
   "PRIN  ","PUNC  ",                                                   03563000
   0,"Y       ","AT      ",0,0,0,0,"E       ",0,"E       ",0,"E       ",03564000
   "N       ","T       ","H       ";                                    03565000
FILL RESERVEDWORDS[*] WITH                                              03566000
   "ASSI  ","BACK  ","BLOC  ","CALL  ","COMM  ","COMP  ","CONT  ",      03567000
   "DATA  ","DIME  ","DOUB  ","END   ","ENDF  ","ENTR  ","EQUI  ",      03568000
   "EXTE  ","FUNC  ","GOTO  ","INTE  ","LOGI  ","NAME  ","PAUS  ",      03569000
   "PRIN  ","PROG  ","PUNC  ","READ  ","REAL  ","RETU  ","REWI  ",      03570000
   "STOP  ","SUBR  ","WRIT  ",                                          03571000
   "CLOS  ","LOCK  ","PURG  ",                                          03572000
   0,0,0,                                                               03573000
   "FIXF  ","VARY  ","AUXM  ","RELE  ",                                 03574000
   "IMPL  ",                                                            03575000
   "GN      ","SPACE   ","KDATA   ",0,"ON      ","LEX     ","INUE    ", 03576000
   0,"NSION  ","LEPRECIS",0,"ILE     ","Y       ","VALENCE ","RNAL    " 03577000
   ,"TION    ",0,"GER     ","CAL     ","LIST    ","E       ","T       ",03578000
   "RAM     ","H       ",0,0,"RN      ","ND      ",0,"OUTINE  ",        03579000
   "E       ","E       ",0,"E       ",0,0,0,"D       ","ING     ",      03580000
   "EM      ","ASE     "                                                03581000
  ,"ICIT    "                                                           03582000
   ;                                                                    03583000
FILL RESLENGTHLP[*] WITH                                                03584000
   4,5,6,4,2,4,4,5,4,5,4,5,5,5,5;                                       03585000
FILL LPGLOBAL[*] WITH                                                   03586000
    4, 13, 36, 17, 35, 25,                                              03587000
   26, 31,  8, 32, 33, 34, 37, 22, 24;                                  03588000
FILL RESLENGTH[*] WITH                                                  03589000
   0, 9, 9, 4, 6,                                                       03590000
   7, 8, 4, 9, 15,                                                      03591000
   3, 7, 5, 11, 8,                                                      03592000
   8, 4, 7, 7, 8,                                                       03593000
   5, 5, 7, 5, 4,                                                       03594000
   4, 6, 6, 4, 10, 5,                                                   03595000
   5, 4, 5, 0, 0, 0, 5, 7, 6, 7                                         03596000
  ,8                                                                    03597000
    ;                                                                   03598000
         FILL WOP[*] WITH                                               03599000
         "LITC","    ",                                                 03600000
         "OPDC","DESC",                                                 03601000
  10,"DEL ", 11,"NOP ", 12,"XRT ", 16,"ADD ", 17,"AD2 ", 18,"PRL ",     03602000
  19,"LNG ", 21,"GEQ ", 22,"BBC ", 24,"INX ", 35,"LOR ", 37,"GTR ",     03603000
  38,"BFC ", 39,"RTN ", 40,"COC ", 48,"SUB ", 49,"SB2 ", 64,"MUL ",     03604000
  65,"ML2 ", 67,"LND ", 68,"STD ", 69,"NEQ ", 70,"SSN ", 71,"XIT ",     03605000
  72,"MKS ",                                                            03606000
 128,"DIV ",129,"DV2 ",130,"COM ",131,"LQV ",132,"SND ",133,"XCH ",     03607000
 134,"CHS ",167,"RTS ",168,"CDC ",197,"FTC ",260,"LOD ",261,"DUP ",     03608000
 278,"GBC ",280,"SSF ",294,"GFC ",322,"ZP1 ",384,"IDV ",453,"FTF ",     03609000
 515,"MDS ",532,"ISD ",533,"LEQ ",534,"BBW ",548,"ISN ",549,"LSS ",     03610000
 550,"BFW ",581,"EQL ",582,"SSP ",584,"ECM ",709,"CTC ",790,"GBW ",     03611000
 806,"GFW ",896,"RDV ",965,"CTF ",                                      03612000
         1023,1023,1023,1023,1023,1023,1023,1023,1023,1023,1023, 1023;  03613000
FILL TIPE[*] WITH 10(-1),-19,-21,OCT300000000,-21,-2,-3,-4,             03614000
                  8(OCT300000000),OCT100000000,-5,-13,-4,-6,-7,-19,-11, 03615000
                  5(OCT100000000),-8,3(OCT300000000),-9,-10,-12,-13,-14,03616000
                  -15,-100,-16,8(OCT300000000),-17,-6,-18,-19,-20,-21 ; 03617000
FILL PERIODWORD[*] WITH                                                 03618000
   "FALSE ", "TRUE  ", "OR    ", "AND   ", "NOT   ",                    03619000
   "LT    ", "LE    ", "EQ    ", "GT    ", "GE    ", "NE    ";          03620000
ACCUM[0] ~ EXACCUM[0] ~ ";     ";                                       03621000
INCLUDE ~ "NCLUDE" & "I"[6:42:6];                                       03622000
INSERTDEPTH ~ -1;                                                       03623000
FILL TEN[*] WITH   %  POWERS OF TEN TO PRT 22                           03624000
    OCT1141000000000000,    OCT1131200000000000,    OCT1121440000000000,03625000
    OCT1111750000000000,    OCT1102342000000000,    OCT1073032400000000,03626000
    OCT1063641100000000,    OCT1054611320000000,    OCT1045753604000000,03627000
    OCT1037346545000000,    OCT1011124027620000,    OCT0001351035564000,03628000
    OCT0011643245121000,    OCT0022214116345200,    OCT0032657142036440,03629000
    OCT0043432772446150,    OCT0054341571157602,    OCT0065432127413542,03630000
    OCT0076740555316473,    OCT0111053071060221,    OCT0121265707274265,03631000
    OCT0131543271153342,    OCT0142074147406233,    OCT0152513201307702,03632000
    OCT0163236041571663,    OCT0174105452130240,    OCT0205126764556310,03633000
    OCT0216354561711772,    OCT0231004771627437,    OCT0241206170175346,03634000
    OCT0251447626234640,    OCT0261761573704010,    OCT0272356132665012,03635000
    OCT0303051561442215,    OCT0313664115752660,    OCT0324641141345435,03636000
    OCT0336011371636744,    OCT0347413670206535,    OCT0361131664625026,03637000
    OCT0371360241772234,    OCT0401654312370703,    OCT0412227375067064,03638000
    OCT0422675274304701,    OCT0433454553366061,    OCT0444367706263475,03639000
    OCT0455465667740415,    OCT0467003245730520,    OCT0501060411731664,03640000
    OCT0511274514320241,    OCT0521553637404312,    OCT0532106607305374,03641000
    OCT0542530351166673,    OCT0553256443424452,    OCT0564132154331565,03642000
    OCT0575160607420123,    OCT0606414751324147,    OCT0621012014361120,03643000
    OCT0631214417455344,    OCT0641457523370635,    OCT0651773450267004,03644000
    OCT0662372362344605,    OCT0673071057035747,    OCT0703707272645341,03645000
    OCT0714671151416631,    OCT0726047403722377,    OCT0737461304707077,03646000
    OCT0751137556607071,    OCT0761367512350710,    OCT0771665435043072,03647000
    OCT0000000000000000,    OCT0000000000000000,    OCT0000000000000000,03648000
    OCT0000000000000000,    OCT0000000000000000,    OCT0000000000000000,03649000
    OCT0000000000000000,    OCT0000000000000000,    OCT0000000000000000,03650000
    OCT0000000000000000,    OCT0000000000000000,    OCT0000000000000000,03651000
    OCT0000000000000000,    OCT0000000000000000,    OCT0000000000000000,03652000
    OCT0000000000000000,    OCT0000000000000000,    OCT0004000000000000,03653000
    OCT0001000000000000,    OCT0001720000000000,    OCT0004304000000000,03654000
    OCT0007365000000000,    OCT0005262200000000,    OCT0004536640000000,03655000
    OCT0001666410000000,    OCT0000244112000000,    OCT0000315134400000,03656000
    OCT0000400363500000,    OCT0000450046042000,    OCT0006562057452400,03657000
    OCT0004316473365100,    OCT0005402212262320,    OCT0006702654737004,03658000
    OCT0004463430126605,    OCT0007600336154346,    OCT0001540425607437,03659000
    OCT0004070533151347,    OCT0005106662003641,    OCT0005033043640461,03660000
    OCT0002241654610575,    OCT0002712227752734,    OCT0001474675745524,03661000
    OCT0002014055337051,    OCT0004417070626663,    OCT0007522706774440,03662000
    OCT0003447470573550,    OCT0006361406732502,    OCT0005005571052122,03663000
    OCT0006207127264547,    OCT0001650755141700,    OCT0006223150372260,03664000
    OCT0007670002470733,    OCT0007646003207120,    OCT0005617404050743,03665000
    OCT0001163305063137,    OCT0007420166277771,    OCT0001732422375777,03666000
    OCT0002321127075377,    OCT0003005354714677,    OCT0005606650100057,03667000
    OCT0007150422120072,    OCT0003002526544103,    OCT0001603254275130,03668000
    OCT0004144127354356,    OCT0007175155247451,    OCT0007034410521363,03669000
    OCT0007664351264566,    OCT0003641443541723,    OCT0004611754472310;03670000
FILL INLINEINT[*] WITH % FILLS MUST BE IN ASCENDING ORDER FOR           03671000
                       % BINARY SEARCH IN FUNCTION AND DOITINLINE.      03672000
                       % INLINEINT[I].[1:1] = 1 ONCE CODE FOR INTRINSIC 03673000
                       %                        HAS BEEN EMITTED INLINE.03674000
                       % INLINEINT[I].[2:10]=INDEX INTO 2-ND WORD OF THE03675000
                       %                     CORR ENTRY IN INT.         03676000
                       % INLINEINT[I].[12:36]=NAME OF INTRINSIC.        03677000
%********FIRST FILL MUST BE NUMBER OF INTRINSICS ******************     03678000
34,                                                                     03679000
"00ABS   ",                                                             03680000
"00AIMAG ",                                                             03681000
"00AINT  ",                                                             03682000
"00AMAX0 ",                                                             03683000
"00AMAX1 ",                                                             03684000
"00AMIN0 ",                                                             03685000
"00AMIN1 ",                                                             03686000
"00AMOD  ",                                                             03687000
"00AND   ",                                                             03688000
"00CMPLX ",                                                             03689000
"00COMPL ",                                                             03690000
"00CONJG ",                                                             03691000
"00DABS  ",                                                             03692000
"00DBLE  ",                                                             03693000
"00DIM   ",                                                             03694000
"00DSIGN ",                                                             03695000
"00EQUIV ",                                                             03696000
"00FLOAT ",                                                             03697000
"00IABS  ",                                                             03698000
"00IDIM  ",                                                             03699000
"00IDINT ",                                                             03700000
"00IFIX  ",                                                             03701000
"00INT   ",                                                             03702000
"00ISIGN ",                                                             03703000
"00MAX0  ",                                                             03704000
"00MAX1  ",                                                             03705000
"00MIN0  ",                                                             03706000
"00MIN1  ",                                                             03707000
"00MOD   ",                                                             03708000
"00OR    ",                                                             03709000
"00REAL  ",                                                             03710000
"00SIGN  ",                                                             03711000
"00SNGL  ",                                                             03712000
"00TIME  ",                                                             03713000
 0 ;                                                                    03714000
         FILL INT [*] WITH                                              03715000
COMMENT THESE NAMES (1-ST WORD OF EACH TWO-WORD ENTRY) MUST BE IN       03716000
         ASCENDING ORDER FOR BINARY LOOKUPS.                            03717000
         THE SECOND WORD HAS THE FOLLOWING FORMAT:                      03718000
         .[1:1] = 0 IF THE INTRINSIC DOES NOT HAVE A PERMANENT PRT      03719000
                    LOCATION, OTHERWISE = 1.  MAY BE RESET BY           03720000
                    WRAPUP.  SEE .[18:6] BELOW.                         03721000
         .[2:1] = .INTSEEN = 1 IFF INTRINSICS FUNCTION HAS BEEN SEEN.   03722000
         .[6:3] = .INTCLASS = CLASS OF THE INTRINSIC.                   03723000
         .[9:3] = .INTPARMCLASS = CLASS OF PARAMETERS.                  03724000
         .[12:6] = .INTINLINE = INDEX FOR DOITINLINE IF !0, OTHERWISE   03725000
                                DO IT VIA INTRINSIC CALL.               03726000
         .[24:6] = .INTPRT = FIXED PRT LOCATION. SEE .[1:1] ABOVE.      03727000
         .[30:6] = .INTPARMS = NUMBER OF PARAMETERS REQUIRED BY THE INT.03728000
         .[36:12] = .INTNUM = INTRINSICS NUMBER.                        03729000
         THE FIELDS .[3:3] AND .[18:6] ARE SO FAR UNUSED.               03730000
;                                                                       03731000
%                                                                       03732000
%***********************************************************************03733000
%*********  IF YOU ADD AN INTRINSIC, BE SURE TO CHANGE NUMINTM1  *******03734000
%*********  AT SEQUENCE NUMBER 00155211.......THANK YOU.         *******03735000
%***********************************************************************03736000
%                                                                       03737000
"ABS   ", OCT0033010000010007,                                          03738000
"AIMAG ", OCT0036020000010074,                                          03739000
"AINT  ", OCT0033030000010054,                                          03740000
"ALGAMA", OCT0033000000010127,                                          03741000
"ALOG10", OCT0033000000010103,                                          03742000
"ALOG  ", OCT2033000035010017,                                          03743000
"AMAX0 ", OCT0031250000000031,                                          03744000
"AMAX1 ", OCT0033250000000031,                                          03745000
"AMIN0 ", OCT0031250000000032,                                          03746000
"AMIN1 ", OCT0033250000000032,                                          03747000
"AMOD  ", OCT0033040000020063,                                          03748000
"AND   ", OCT0033050000020130,                                          03749000
"ARCOS ", OCT0033000000010117,                                          03750000
"ARSIN ", OCT2033000032010116,                                          03751000
"ATAN2 ", OCT2033000044020114,                                          03752000
"ATAN  ", OCT2033000037010016,                                          03753000
"CABS  ", OCT2036000045010053,                                          03754000
"CCOS  ", OCT0066000000010110,                                          03755000
"CEXP  ", OCT0066000000010100,                                          03756000
"CLOG  ", OCT0066000000010102,                                          03757000
"CMPLX ", OCT0063060000020075,                                          03758000
"COMPL ", OCT0033070000010132,                                          03759000
"CONCAT", OCT0033000000050140,                                          03760000
"CONJG ", OCT0066110000010076,                                          03761000
"COSH  ", OCT0033000000010121,                                          03762000
"COS   ", OCT0033000000010015,                                          03763000
"COTAN ", OCT0033000000010112,                                          03764000
"CSIN  ", OCT0066000000010106,                                          03765000
"CSQRT ", OCT0066000000010124,                                          03766000
"DABS  ", OCT0055010000010052,                                          03767000
"DATAN2", OCT0055000000020115,                                          03768000
"DATAN ", OCT2055000041010113,                                          03769000
"DBLE  ", OCT0053120000010062,                                          03770000
"DCOS  ", OCT0055000000010107,                                          03771000
"DEXP  ", OCT2055000047010077,                                          03772000
"DIM   ", OCT0033100000020072,                                          03773000
"DLOG10", OCT0055000000010104,                                          03774000
"DLOG  ", OCT2055000042010101,                                          03775000
"DMAX1 ", OCT0055000000000066,                                          03776000
"DMIN1 ", OCT0055000000000067,                                          03777000
"DMOD  ", OCT2055000046020065,                                          03778000
"DSIGN ", OCT0055130000020071,                                          03779000
"DSIN  ", OCT2055000043010105,                                          03780000
"DSQRT ", OCT2055000050010123,                                          03781000
"EQUIV ", OCT0033140000020133,                                          03782000
"ERF   ", OCT0033000000010125,                                          03783000
"EXP   ", OCT2033000033010020,                                          03784000
"FLOAT ", OCT0031150000010060,                                          03785000
"GAMMA ", OCT2033000040010126,                                          03786000
"IABS  ", OCT0011010000010007,                                          03787000
"IDIM  ", OCT0011100000020072,                                          03788000
"IDINT ", OCT0015240000010057,                                          03789000
"IFIX  ", OCT0013030000010054,                                          03790000
"INT   ", OCT0013030000010054,                                          03791000
"ISIGN ", OCT0011160000020070,                                          03792000
".ERR. ", OCT2000000030000134,                                          03793000
".FBINB", OCT0000000000000160,                                          03794000
".FINAM", OCT0000000000000154,                                          03795000
".FONAM", OCT0000000000000155,                                          03796000
".FREFR", OCT0000000000000146,                                          03797000
".FREWR", OCT0000000000000153,                                          03798000
".FTINT", OCT0000000000000050,                                          03799000
".FTNIN", OCT0000000000000156,                                          03800000
".FTNOU", OCT0000000000000157,                                          03801000
".FTOUT", OCT0000000000000051,                                          03802000
".LABEL", OCT0000000000000021,                                          03803000
".MATH ", OCT0000000000000055,                                          03804000
".MEMHR", OCT0000000000000164,                                          03805000
".XTOI ", OCT0000000000000056,                                          03806000
"MAX0  ", OCT0011250000000135,                                          03807000
"MAX1  ", OCT0013250000000135,                                          03808000
"MIN0  ", OCT0011250000000136,                                          03809000
"MIN1  ", OCT0013250000000136,                                          03810000
"MOD   ", OCT0011170000020137,                                          03811000
"OR    ", OCT0033200000020131,                                          03812000
"REAL  ", OCT0036210000010073,                                          03813000
"SIGN  ", OCT0033160000020070,                                          03814000
"SINH  ", OCT0033000000010120,                                          03815000
"SIN   ", OCT2033000034010014,                                          03816000
"SNGL  ", OCT0035230000010061,                                          03817000
"SQRT  ", OCT2033000031010013,                                          03818000
"TANH  ", OCT0033000000010122,                                          03819000
"TAN   ", OCT2033000036010111,                                          03820000
"TIME  ", OCT0031220000010064,                                          03821000
 0;                                                                     03822000
BLANKS~INLINEINT[MAX~0] ;                                               03823000
FOR SCN~1 STEP 1 UNTIL BLANKS DO                                        03824000
    BEGIN                                                               03825000
    EQVID~INLINEINT[SCN];  WHILE INT[MAX]!EQVID DO MAX~MAX+2 ;          03826000
    INLINEINT[SCN].INTX~MAX+1 ;                                         03827000
    END ;                                                               03828000
INTID.SUBCLASS ~ INTYPE;                                                03829000
REALID.SUBCLASS ~ REALTYPE;                                             03830000
EQVID ~ ".EQ000";                                                       03831000
LISTID ~ ".LI000";                                                      03832000
BLANKS ~ "      ";                                                      03833000
ENDSEGTOG ~ TRUE;                                                       03834000
SCN ~ 7;                                                                03835000
MAX ~ REAL(NOT FALSE).[9:39];                                           03836000
SUPERMAXCOM~128|(MAXCOM+1) ;                                            03837000
SEGPTOG ~ FALSE;   %INHIBIT PAGE SKIP AFTER SUBROUTINES           %501- 03838000
END   INITIALIZATION;                                                   03839000
                                                                        03840000
ALPHA PROCEDURE NEED(T, C); VALUE T, C; ALPHA T, C;                     03841000
BEGIN INTEGER N;  REAL ELBAT;                                           03842000
   REAL X;                                                              03843000
   LABEL XIT, CHECK;                                                    03844000
   ALPHA INFA, INFB, INFC;                                              03845000
COMMENT NEED RETURNS THE ELBAT WORD FOR THE IDENTIFIER T.               03846000
IF THIS IS THE FIRST OCCURRENCE OF T THEN AN INFO WORD IS BUILT AND     03847000
GIVEN THEN CLASS C;                                                     03848000
   ELBAT.CLASS ~ C;                                                     03849000
   XTA ~ T;                                                             03850000
   IF C { LABELID THEN                                                  03851000
      BEGIN                                                             03852000
         IF N ~ SEARCH(T) = 0 THEN N ~ ENTER(ELBAT, T) ELSE             03853000
         IF ELBAT ~  GET(N).CLASS = UNKNOWN                             03854000
           THEN PUT(N,GET(N)&C[TOCLASS])                                03855000
         ELSE IF ELBAT ! C THEN FLOG(21);                               03856000
         GO TO XIT;                                                     03857000
     END;                                                               03858000
  IF N ~ SEARCH(T) = 0 THEN                                             03859000
     BEGIN                                                              03860000
        IF N ~ GLOBALSEARCH(T) ! 0 THEN GO TO CHECK;                    03861000
        N ~ GLOBALENTER(ELBAT, T);                                      03862000
        GO TO XIT;                                                      03863000
    END;                                                                03864000
  GETALL(N,INFA,INFB,INFC);                                             03865000
  IF INFA.CLASS = DUMMY THEN BEGIN N ~ INFC.BASE; GO TO CHECK END;      03866000
  IF BOOLEAN(INFA.   FORMAL) THEN GO TO CHECK;                          03867000
  IF INFA.CLASS ! UNKNOWN THEN                                          03868000
  BEGIN                                                                 03869000
     IF N ~ GLOBALSEARCH(T) ! 0 THEN GO TO CHECK;                       03870000
     ELBAT.SUBCLASS ~ INFA.SUBCLASS;                                    03871000
     N ~ GLOBALENTER(ELBAT, T);                                         03872000
     GO TO XIT;                                                         03873000
  END;                                                                  03874000
  PUT(N, INFA & DUMMY[TOCLASS]);                                        03875000
  ELBAT.SUBCLASS ~ INFA   .SUBCLASS;                                    03876000
  IF X ~ GLOBALSEARCH(T) = 0 THEN X ~ GLOBALENTER(ELBAT, T);            03877000
  PUT(N+2, INFC & X[TOBASE]); N ~ X;                                    03878000
  CHECK:                                                                03879000
  INFA ~ GET(N);                                                        03880000
  IF ELBAT ~ INFA   .CLASS = UNKNOWN THEN                               03881000
     BEGIN INFO[N.IR,N.IC].CLASS ~ C; GO TO XIT END;                    03882000
  IF ELBAT ! C THEN                                                     03883000
     IF ELBAT = EXTID AND                                               03884000
        (C = SUBRID OR C = FUNID) THEN                                  03885000
        INFO[N.IR,N.IC].CLASS ~ C                                       03886000
     ELSE IF (ELBAT=SUBRID OR ELBAT= FUNID) AND C = EXTID THEN          03887000
     ELSE FLOG(21);                                                     03888000
  XIT: NEED ~ GETSPACE(N);                                              03889000
  XTA ~ NAME;     % RESTORE XTA FOR DIAGNOSTIC PURPOSES                 03890000
END NEED;                                                               03891000
INTEGER PROCEDURE EXPR(B); VALUE B; BOOLEAN B; FORWARD;                 03892000
PROCEDURE SPLIT(A); VALUE A; REAL A;                                    03893000
BEGIN                                                                   03894000
      EMITPAIR(JUNK, ISN);                                              03895000
      EMITD(40, DIA);                                                   03896000
      EMITD(18, ISO);                                                   03897000
      EMITDESCLIT(A);                                                   03898000
      EMITO(LOD);                                                       03899000
      EMITOPDCLIT(JUNK);                                                03900000
      EMITPAIR(255,CHS);                                                03901000
      EMITO(LND);                                                       03902000
END SPLIT;                                                              03903000
BOOLEAN PROCEDURE SUBSCRIPTS(LINK,FROM); VALUE LINK,FROM;               03904000
INTEGER LINK, FROM;                                                     03905000
BEGIN INTEGER I, NSUBS, BDLINK;                                         03906000
   LABEL CONSTRUCT, XIT;                                                03907000
REAL SUM, PROD, BOUND;                                                  03908000
REAL INFA,INFB,INFC;                                                    03909000
REAL SAVENSEG,SAVEADR ;                                                 03910000
INTEGER INDX;                                                           03911000
REAL INFD;                                                              03912000
BOOLEAN TOG, VARF;                                                      03913000
REAL SAVIT;                                                             03914000
DEFINE SS = LSTT#;                                                      03915000
                                                                        03916000
                                                                        03917000
IF DEBUGTOG THEN FLAGROUTINE(" SUBSC","RIPTS ",TRUE ) ;                 03918000
   SAVIT ~ IT;                                                          03919000
   LINK ~ GETSPACE(LINK);                                               03920000
GETALL(LINK,INFA,INFB,INFC);                                            03921000
   IF INFA.CLASS ! ARRAYID THEN                                         03922000
      BEGIN XTA ~ INFB; FLOG(35); GO TO XIT END;                        03923000
   NSUBS ~ INFC.NEXTRA;                                                 03924000
   IF FROM = 4 THEN                                                     03925000
     BEGIN IF NSUBS GTR SAVESUBS THEN SAVESUBS ~ NSUBS;                 03926000
           IF NSUBS GTR NAMLIST[0] THEN NAMLIST[0] ~ NSUBS;             03927000
           NAMLIST[NAMEIND].[1:8] ~ NSUBS;                              03928000
           INFD ~ GET(NEED(".SUBAR",BLOCKID)).ADDR;                     03929000
     END;                                                               03930000
   BDLINK ~ INFC.ADINFO-NSUBS+1;                                        03931000
   VARF ~ INFC < 0;                                                     03932000
   FOR I ~ 1 STEP 1 UNTIL NSUBS DO                                      03933000
   BEGIN                                                                03934000
      IT~IT+1;  SAVENSEG~NSEG;  SAVEADR~ADR ;                           03935000
      IF EXPR(TRUE) > REALTYPE THEN FLAG(98);                           03936000
      IF ADR=SAVEADR THEN FLAG(36) ;                                    03937000
      IF VARF THEN                                                      03938000
         IF EXPRESULT=NUMCLASS AND NSEG=SAVENSEG THEN                   03939000
         BEGIN                                                          03940000
            ADR~SAVEADR ;                                               03941000
            EMITNUM(EXPVALUE-1);                                        03942000
         END ELSE EMITPAIR(1, SUB)                                      03943000
      ELSE                                                              03944000
      IF EXPRESULT=NUMCLASS AND NSEG = SAVENSEG AND FROM NEQ 4 THEN     03945000
         BEGIN                                                          03946000
         ADR~SAVEADR;   IF SS[IT]~EXPVALUE{0 THEN FLAG(154) ;           03947000
         END                                                            03948000
      ELSE SS[IT] ~ @9;                                                 03949000
      IF FROM = 4 THEN                                                  03950000
         BEGIN IF VARF THEN BEGIN EMITO(DUP); EMITPAIR(1,ADD); END;     03951000
               EMITL(INDX); INDX ~ INDX+1;                              03952000
               EMITDESCLIT(INFD);                                       03953000
               EMITO(IF VARF THEN STD ELSE STN);                        03954000
         END;                                                           03955000
      IF I < NSUBS THEN                                                 03956000
      BEGIN                                                             03957000
         IF GLOBALNEXT ! COMMA THEN                                     03958000
            BEGIN XTA ~ INFB; FLOG(23) END;                             03959000
         SCAN;                                                          03960000
      END;                                                              03961000
   END;                                                                 03962000
   IF GLOBALNEXT ! RPAREN THEN BEGIN XTA ~ INFB; FLOG(24); END          03963000
      ELSE IF FROM < 2 THEN                                             03964000
         BEGIN SCAN; IF PREC > 0 THEN FROM ~ 1; END;                    03965000
   SUM ~ 0;                                                             03966000
   TOG ~ VARF;                                                          03967000
   IF VARF THEN                                                         03968000
   FOR I ~ NSUBS-1 STEP -1 UNTIL 1 DO                                   03969000
   BEGIN                                                                03970000
      IF BOUND ~ EXTRAINFO[(BDLINK~BDLINK+1).IR,BDLINK.IC] < 0 THEN     03971000
         EMITOPDCLIT(BOUND) ELSE EMITNUM(BOUND);                        03972000
      EMITO(MUL);                                                       03973000
      EMITO(ADD);                                                       03974000
   END                                                                  03975000
   ELSE                                                                 03976000
   FOR I ~ NSUBS STEP -1 UNTIL 1 DO                                     03977000
   BEGIN                                                                03978000
      IF I = 1 THEN BOUND ~ 1 ELSE                                      03979000
         BOUND ~ EXTRAINFO[(BDLINK~BDLINK+1).IR,BDLINK.IC];             03980000
      IF T ~ SS[SAVIT+I] < @9 THEN                                      03981000
         BEGIN                                                          03982000
            SUM ~ (SUM+T-1)|BOUND;                                      03983000
            IF TOG THEN PROD ~ PROD|BOUND;                              03984000
         END                                                            03985000
      ELSE                                                              03986000
      BEGIN                                                             03987000
         IF TOG THEN BEGIN EMITNUM(PROD); EMITO(MUL); EMITO(ADD) END    03988000
         ELSE TOG ~ TRUE;                                               03989000
         PROD ~ BOUND;                                                  03990000
         SUM ~ (SUM-1)|BOUND;                                           03991000
      END;                                                              03992000
   END;                                                                 03993000
   IF VARF THEN T ~ @9;                                                 03994000
   IF INFA.SUBCLASS } DOUBTYPE THEN                                     03995000
   BEGIN                                                                03996000
      IF TOG THEN                                                       03997000
      BEGIN                                                             03998000
         IF T < @9 THEN EMITNUM(2|PROD) ELSE EMITL(2);                  03999000
         EMITO(MUL);                                                    04000000
      END;                                                              04001000
      SUM ~ SUM|2;                                                      04002000
   END ELSE                                                             04003000
   IF T < @9 AND TOG THEN BEGIN EMITNUM(PROD); EMITO(MUL) END;          04004000
   IF BOOLEAN(INFA.CE) THEN                                             04005000
      SUM ~ SUM + INFC.BASE ELSE                                        04006000
      IF BOOLEAN(INFA.FORMAL) THEN                                      04007000
         BEGIN EMITOPDCLIT(INFA.ADDR-1);                                04008000
            IF TOG THEN EMITO(ADD) ELSE TOG ~ TRUE;                     04009000
         END;                                                           04010000
   IF BOOLEAN(INFA.TWOD) AND FROM > 0 THEN                              04011000
   BEGIN                                                                04012000
      IF SUM = 0 THEN                                                   04013000
         IF TOG THEN ELSE                                               04014000
         BEGIN                                                          04015000
            EMITL(0);                                                   04016000
            EMITDESCLIT(INFA.ADDR);                                     04017000
            EMITO(LOD);                                                 04018000
            EMITL(0);                                                   04019000
            GO TO CONSTRUCT;                                            04020000
         END                                                            04021000
      ELSE                                                              04022000
         IF TOG THEN                                                    04023000
         BEGIN                                                          04024000
            EMITNUM(ABS(SUM));                                          04025000
            IF SUM < 0 THEN EMITO(SUB) ELSE EMITO(ADD);                 04026000
         END ELSE                                                       04027000
         BEGIN                                                          04028000
            EMITL(SUM.[33:7]);                                          04029000
            EMITDESCLIT(INFA.ADDR);                                     04030000
            EMITO(LOD);                                                 04031000
            EMITL(SUM.[40:8]);                                          04032000
            GO TO CONSTRUCT;                                            04033000
         END;                                                           04034000
      SPLIT(INFA.ADDR);                                                 04035000
      CONSTRUCT:                                                        04036000
      IF BOOLEAN(FROM) THEN                                             04037000
      BEGIN                                                             04038000
         IF INFA.SUBCLASS } DOUBTYPE THEN                               04039000
         BEGIN                                                          04040000
            EMITO(CDC);                                                 04041000
            EMITO(DUP);                                                 04042000
            EMITPAIR(1, XCH);                                           04043000
            EMITO(INX);                                                 04044000
            EMITO(LOD);                                                 04045000
            EMITO(XCH);                                                 04046000
            EMITO(LOD);                                                 04047000
         END ELSE EMITO(COC);                                           04048000
      END ELSE EMITO(CDC);                                              04049000
   END ELSE                                                             04050000
   BEGIN                                                                04051000
   IF SUM = 0 THEN IF NOT TOG THEN EMITL(0) ELSE                        04052000
   ELSE                                                                 04053000
   BEGIN                                                                04054000
      IF TOG THEN                                                       04055000
         BEGIN                                                          04056000
            EMITNUM(ABS(SUM));                                          04057000
            IF SUM < 0 THEN EMITO(SUB) ELSE EMITO(ADD);                 04058000
         END                                                            04059000
      ELSE EMITNUM(SUM);                                                04060000
   END;                                                                 04061000
   IF FROM > 0 THEN                                                     04062000
      IF BOOLEAN (FROM) THEN                                            04063000
         IF INFA.SUBCLASS } DOUBTYPE THEN                               04064000
         BEGIN                                                          04065000
            EMITDESCLIT(INFA.ADDR);                                     04066000
            EMITO(DUP);                                                 04067000
            EMITPAIR(1,XCH);                                            04068000
            EMITO(INX);                                                 04069000
            EMITO(LOD);                                                 04070000
            EMITO(XCH);                                                 04071000
            EMITO(LOD);                                                 04072000
         END ELSE EMITV(LINK) ELSE                                      04073000
   BEGIN DESCREQ ~ TRUE; EMITN(LINK); DESCREQ ~ FALSE END;              04074000
   END;                                                                 04075000
   XIT:                                                                 04076000
   IT ~ SAVIT;                                                          04077000
   SUBSCRIPTS ~ BOOLEAN(FROM);                                          04078000
IF DEBUGTOG THEN FLAGROUTINE(" SUBSC","RIPTS ",FALSE) ;                 04079000
END SUBSCRIPTS;                                                         04080000
BOOLEAN PROCEDURE BOUNDS(LINK); VALUE LINK; REAL LINK;                  04081000
BEGIN                                                                   04082000
    COMMENT CALLED  TO PROCESS ARRAY BOUNDS;                            04083000
    BOOLEAN VARF, SINGLETOG;                                       %109-04084000
   DEFINE FNEW = LINK#;                                                 04085000
    REAL T, NSUBS, INFA, INFB, INFC, FIRSTSS;                           04086000
    LABEL LOOP;                                                         04087000
IF DEBUGTOG THEN FLAGROUTINE("   BOU","NDS   ",TRUE );                  04088000
    GETALL(FNEW, INFA, INFB, INFC);                                     04089000
    FIRSTSS ~ NEXTSS;                                                   04090000
   IF LINK < 0 THEN BEGIN SINGLETOG ~ TRUE; LINK ~ ABS(LINK) END;  %109-04091000
    LOOP:                                                               04092000
    IF NEXT = ID THEN                                                   04093000
    BEGIN                                                               04094000
         T ~ GET(FNEXT ~ GETSPACE(FNEXT));                              04095000
         IF T.CLASS ! VARID OR NOT BOOLEAN(T.FORMAL) THEN FLAG(92) ELSE 04096000
         IF T.SUBCLASS > REALTYPE THEN FLAG(93);                        04097000
         T ~ -T.ADDR;                                                   04098000
         VARF ~ TRUE;                                                   04099000
    END ELSE                                                            04100000
    IF NEXT = NUM THEN                                                  04101000
    BEGIN                                                               04102000
         IF NUMTYPE!INTYPE THEN FLAG(113);                              04103000
         IF T~FNEXT=0 THEN FLAG(122) ;                                  04104000
         IF NOT VARF THEN IF NSUBS = 0 THEN LENGTH ~ FNEXT ELSE         04105000
              LENGTH ~ LENGTH|FNEXT;                                    04106000
    END ELSE FLOG(122);                                                 04107000
    EXTRAINFO[NEXTSS.IR,NEXTSS.IC] ~ T;                                 04108000
    NEXTSS ~ NEXTSS-1;                                                  04109000
    NSUBS ~ NSUBS+1;                                                    04110000
    SCAN;                                                               04111000
    IF NEXT = COMMA THEN BEGIN SCAN; GO TO LOOP END;                    04112000
    IF NEXT ! RPAREN THEN FLOG(94);                                     04113000
    XTA ~ INFB;                                                         04114000
    IF INFA.CLASS = ARRAYID THEN FLAG(95);                              04115000
    INFA.CLASS ~ ARRAYID;                                               04116000
   IF VARF THEN                                                         04117000
   BEGIN                                                                04118000
       IF NOT BOOLEAN(INFA.FORMAL) THEN FLAG(96);                       04119000
      IF NSUBS > 1 OR INFA     .SUBCLASS } DOUBTYPE THEN                04120000
         BEGIN BUMPLOCALS;LENGTH~LOCALS + 1536;BOUNDS~TRUE END ELSE     04121000
         LENGTH    ~-EXTRAINFO[FIRSTSS.IR,FIRSTSS.IC];                  04122000
   END ELSE                                                             04123000
    IF NOT SINGLETOG AND INFA.SUBCLASS > LOGTYPE THEN              %109-04124000
         BEGIN LENGTH ~ 2 | LENGTH; BOUNDS ~ TRUE END;             %109-04125000
    IF LENGTH > 32767 THEN FLAG(99);                                    04126000
    INFC ~ LENGTH & NSUBS[TONEXTRA] & FIRSTSS[TOADINFO];                04127000
   IF VARF THEN INFC ~ -INFC;                                           04128000
    PUT(FNEW, INFA); PUT(FNEW+2, INFC);                                 04129000
    SCAN;                                                               04130000
IF DEBUGTOG THEN FLAGROUTINE("   BOU","NDS   ",FALSE) ;                 04131000
END BOUNDS;                                                             04132000
PROCEDURE PARAMETERS(LINK); VALUE LINK; REAL LINK;                      04133000
BEGIN                                                                   04134000
                                                                        04135000
                                                                        04136000
   LABEL LOOP;                                                          04137000
   REAL NPARMS, EX, INFC, PTYPE;                                        04138000
   ALPHA EXPNAME;                                                       04139000
   BOOLEAN CHECK, INTFID;                                               04140000
   BOOLEAN NOTZEROP;                                                    04141000
   REAL SAVIT;                                                          04142000
   DEFINE PARMTYPE = LSTT#;                                             04143000
   SAVIT ~ IT ~ IT+1;                                                   04144000
IF DEBUGTOG THEN FLAGROUTINE(" PARAM","ETERS ",TRUE ) ;                 04145000
   INFC ~ GET(LINK+2);                                                  04146000
   IF CHECK ~ BOOLEAN(INFC.[1:1]) THEN                                  04147000
   BEGIN                                                                04148000
      EX ~ INFC.ADINFO;                                                 04149000
      NOTZEROP ~ INFC.NEXTRA ! 0;                                       04150000
      INTFID ~ INFC.[36:12] = 1;                                        04151000
   END;                                                                 04152000
   LOOP:                                                                04153000
   BEGIN SCAN;                                                          04154000
      EXPNAME ~ NAME;                                                   04155000
      IF GLOBALNEXT = 0 AND NAME = "$     " THEN                        04156000
         BEGIN EXPRESULT ~ LABELID; SCAN;                               04157000
            IF GLOBALNEXT ! NUM THEN FLAG(44);                          04158000
            EMITLABELDESC(NAME);                                        04159000
            PTYPE ~ 0;                                                  04160000
            SCAN;                                                       04161000
         END                                                            04162000
      ELSE PTYPE ~ EXPR(CHECK AND EXTRAINFO[EX.IR,EX.IC].CLASS          04163000
         = EXPCLASS AND INTFID);                                        04164000
      IF EXPRESULT = NUMCLASS THEN                                      04165000
         IF PTYPE = STRINGTYPE THEN                                     04166000
         BEGIN                                                          04167000
            ADR ~ ADR - 1;                                              04168000
            PTYPE ~ INTYPE;                                             04169000
            EXPRESULT ~ SUBSVAR;                                        04170000
            IF STRINGSIZE = 1 AND                                       04171000
               (T ~ EXTRAINFO[EX.IR,EX.IC].CLASS = VARID OR             04172000
               T = EXPCLASS) THEN                                       04173000
            BEGIN                                                       04174000
               EXPRESULT ~ EXPCLASS;                                    04175000
               EMITNUM(STRINGARRAY[0]);                                 04176000
            END ELSE                                                    04177000
            BEGIN                                                       04178000
            EXPRESULT~ARRAYID;                                          04179000
            EMITPAIR(PRGDESCBLDR(1,0,0,NXAVIL~NXAVIL+1), LOD);          04180000
            EMITL(0);                                                   04181000
            WRITEDATA(STRINGSIZE, NXAVIL, STRINGARRAY);                 04182000
            END;                                                        04183000
         END ELSE EXPRESULT ~ EXPCLASS;                                 04184000
      PARMTYPE[IT] ~ 0 & EXPRESULT[TOCLASS] & PTYPE[TOSUBCL];           04185000
      XTA ~ EXPNAME;                                                    04186000
      IF TSSEDITOG THEN IF (EXPRESULT=FUNID OR EXPRESULT=SUBRID OR      04187000
      EXPRESULT=EXTID) AND NOT DCINPUT THEN TSSED(XTA,2);               04188000
      IF DCINPUT THEN IF EXPRESULT=FUNID OR EXPRESULT=SUBRID            04189000
      OR EXPRESULT=EXTID THEN FLAG(151) ;                               04190000
      IF CHECK THEN                                                     04191000
         BEGIN                                                          04192000
         IF T ~ EXTRAINFO[EX.IR,EX.IC].CLASS ! EXPRESULT THEN           04193000
         CASE T OF                                                      04194000
         BEGIN                                                          04195000
         EXTRAINFO[EX.IR,EX.IC] ~ 0 & EXPRESULT[TOCLASS]                04196000
            & PTYPE[TOSUBCL];                                           04197000
         IF EXPRESULT ! SUBSVAR THEN FLAG(66);                          04198000
         IF EXPRESULT = SUBSVAR THEN                                    04199000
            IF NOT INTFID THEN                                          04200000
            BEGIN  EMITO(CDC);                                          04201000
               IF PTYPE } DOUBTYPE THEN EMITL(0);                       04202000
               END ELSE                                                 04203000
          ELSE                                                          04204000
            IF EXPRESULT = EXPCLASS THEN                                04205000
               BEGIN IF PTYPE } DOUBTYPE THEN EMITO(XCH);               04206000
                     EXTRAINFO[EX.IR,EX.IC].CLASS ~ EXPCLASS            04207000
               END ELSE FLAG(67);                                       04208000
         ; ; ;                                                          04209000
         FLAG(68);                                                      04210000
         IF EXPRESULT = EXTID THEN                                      04211000
            PUT(EXPLINK,GET(EXPLINK)&FUNID[TOCLASS]) ELSE               04212000
            FLAG(69);                                                   04213000
         ;                                                              04214000
         IF EXPRESULT = FUNID OR EXPRESULT = SUBRID THEN                04215000
            EXTRAINFO[EX.IR,EX.IC] ~ EXPRESULT ELSE FLAG(70);           04216000
         IF EXPRESULT = EXTID THEN                                      04217000
            PUT(EXPLINK,GET(EXPLINK)&SUBRID[TOCLASS]) ELSE              04218000
            FLAG(71);                                                   04219000
         ; ;                                                            04220000
         IF EXPRESULT = ARRAYID THEN EXTRAINFO[EX.IR,EX.IC].CLASS       04221000
            ~ ARRAYID ELSE                                              04222000
            IF EXPRESULT = VARID THEN                                   04223000
            BEGIN                                                       04224000
               EXTRAINFO[EX.IR,EX.IC].CLASS ~ SBVEXP;                   04225000
               EMITL(0)                                                 04226000
            END ELSE                                                    04227000
            IF EXPRESULT = EXPCLASS THEN                                04228000
            BEGIN                                                       04229000
               EXTRAINFO[EX.IR,EX.IC].CLASS ~ SBVEXP;                   04230000
               IF PTYPE } DOUBTYPE THEN EMITO(XCH) ELSE EMITL(0);       04231000
            END ELSE FLAG(72);                                          04232000
         IF EXPRESULT = SUBSVAR THEN                                    04233000
            IF NOT INTFID THEN                                          04234000
               BEGIN EMITO(CDC);                                        04235000
                     IF PTYPE } DOUBTYPE THEN EMITL(0)                  04236000
               END                                                      04237000
            ELSE                                                        04238000
           ELSE IF EXPRESULT = VARID THEN                               04239000
                IF NOT INTFID THEN                                      04240000
               IF PTYPE } DOUBTYPE THEN EMITL(0)  ELSE  ELSE            04241000
               ELSE FLAG(67);                                           04242000
         IF EXPRESULT = VARID THEN                                      04243000
            EMITL(0) ELSE                                               04244000
         IF EXPRESULT = EXPCLASS THEN                                   04245000
            IF PTYPE } DOUBTYPE THEN EMITO(XCH) ELSE EMITL(0)           04246000
         ELSE IF EXPRESULT ! SUBSVAR THEN FLAG(67);                     04247000
         END OF CASE STATEMENT                                          04248000
         ELSE IF PTYPE } DOUBTYPE THEN                                  04249000
              IF EXPRESULT = VARID THEN EMITL(0)                        04250000
              ELSE IF EXPRESULT = EXPCLASS AND NOT INTFID               04251000
                   THEN EMITO(XCH);                                     04252000
      IF T ~ EXTRAINFO[EX.IR,EX.IC].SUBCLASS = 0 OR                     04253000
         (T = INTYPE AND PTYPE = REALTYPE AND                           04254000
         GET(LINK).SEGNO = 0) THEN                                      04255000
            EXTRAINFO[EX.IR,EX.IC].SUBCLASS ~ PTYPE ELSE                04256000
         IF NOT(T = PTYPE OR T = REALTYPE AND PTYPE = INTYPE ) THEN     04257000
            FLAG(88);                                                   04258000
         END OF CHECK                                                   04259000
         ELSE IF PTYPE } DOUBTYPE THEN                                  04260000
              IF EXPRESULT = VARID THEN EMITL(0)                        04261000
              ELSE IF EXPRESULT = EXPCLASS THEN EMITO(XCH);             04262000
   IF NOTZEROP THEN EX ~ EX+1;                                          04263000
      IT ~ IT+1;                                                        04264000
   END;                                                                 04265000
   IF GLOBALNEXT = COMMA THEN GO TO  LOOP;                              04266000
   NPARMS ~ IT - SAVIT;                                                 04267000
   IF GLOBALNEXT ! RPAREN THEN FLOG(108);                               04268000
   IF NOT CHECK THEN                                                    04269000
   BEGIN                                                                04270000
   INFC ~ GET(LINK+2);                                                  04271000
   INFC ~ -(INFC & NPARMS[TONEXTRA]                                     04272000
          & NEXTEXTRA[TOADINFO]);                                       04273000
   PUT(LINK+2,INFC);                                                    04274000
      FOR I ~ SAVIT STEP 1 UNTIL IT-1 DO                                04275000
      BEGIN                                                             04276000
         EXTRAINFO[NEXTEXTRA.IR,NEXTEXTRA.IC] ~ PARMTYPE[I];            04277000
         NEXTEXTRA ~ NEXTEXTRA+1;                                       04278000
      END;                                                              04279000
   END                                                                  04280000
   ELSE                                                                 04281000
   IF T ~ GET(LINK+2).NEXTRA > 0 AND T ! NPARMS OR                      04282000
      T=0 AND INTFID AND NPARMS < 2 OR                                  04283000
      T = 0 AND  NOT INTFID THEN                                        04284000
   BEGIN XTA ~ GET(LINK+1); FLAG(28) END;                               04285000
IF DEBUGTOG THEN FLAGROUTINE(" PARAM","ETERS ",FALSE) ;                 04286000
   IT ~ SAVIT-1;                                                        04287000
END PARAMETERS;                                                         04288000
PROCEDURE STMTFUNREF(LINK); VALUE LINK; REAL LINK;                      04289000
BEGIN                                                                   04290000
         REAL I, PARMLINK, NPARMS, SEG;                                 04291000
IF DEBUGTOG THEN FLAGROUTINE(" STMTF","UNREF ",TRUE);                   04292000
         PARMLINK ~ GET(LINK+2).[36:12];                                04293000
         DO                                                             04294000
    BEGIN                                                               04295000
         SCAN;                                                          04296000
         IF A~EXPR(TRUE) ! B~GET(PARMLINK).SUBCLASS THEN                04297000
     IF A > REALTYPE OR B > REALTYPE THEN                          %108-04298000
         BEGIN XTA ~ NNEW; FLAG(88) END;                                04299000
         PARMLINK ~ PARMLINK-3;                                         04300000
         NPARMS ~ NPARMS+1;                                             04301000
    END  UNTIL NEXT ! COMMA;                                            04302000
         IF NEXT ! RPAREN THEN FLAG(108);                               04303000
         SCAN;                                                          04304000
         GETALL(LINK, INFA, XTA, INFC);                                 04305000
         IF NPARMS ! INFC.NEXTRA THEN FLAG(28);                         04306000
         SEG ~ INFA.SEGNO;                                              04307000
         BRANCHLIT(INFC.BASE&SEG[TOSEGNO],FALSE);                       04308000
         EMITB(INFA.ADDR & SEG[TOSEGNO], FALSE);                        04309000
         ADJUST;                                                        04310000
 IF DEBUGTOG THEN FLAGROUTINE(" STMTF","UNREF ",FALSE);                 04311000
 END STMTFUNREF;                                                        04312000
 BOOLEAN PROCEDURE DOITINLINE(LNK);  VALUE LNK;  REAL LNK ;             04313000
     BEGIN                                                              04314000
     REAL C,I,C1,C2,C3,C4,C5 ;                                          04315000
     LABEL HUNT,FOUND,XIT,AIMAG,AINT,CMPLX,LOOP,DDT111,SNGL ;           04316000
     DEFINE OPTYPE=LSTT#,  E0=EMITO#,  EP=EMITPAIR#,  EOL=EMITOPDCLIT# ;04317000
     IF DEBUGTOG THEN FLAGROUTINE("DOITIN","LINE  ",TRUE);              04318000
     C1~1;  C2~INLINEINT[0];  C3~GET(ABS(LNK)+1) ;                      04319000
 HUNT:                                                                  04320000
     IF (C~INLINEINT[I~(C1+C2).[36:11]].INAM)<C3 THEN C1~I+1            04321000
     ELSE IF C>C3 THEN C2~I-1 ELSE GO FOUND ;                           04322000
     IF C1<C2 THEN GO HUNT ;                                            04323000
     IF INLINEINT[C1].INAM!C3 THEN                                      04324000
          BEGIN                                                         04325000
          IF LNK<0 THEN DOITINLINE~BOOLEAN(LOOKFORINTRINSIC(-LNK)) ;    04326000
          GO XIT ;                                                      04327000
          END ;                                                         04328000
     I~C1 ;                                                             04329000
 FOUND:                                                                 04330000
     C1~(C~INT[C2~(C4~INLINEINT[I]).INTX]).INTPARMCLASS ;               04331000
     IF LNK<0 THEN                                                      04332000
          BEGIN                                                         04333000
          I~-LNK;  DOITINLINE~BOOLEAN(LNK~NEED(C3,FUNID)) ;             04334000
          IF (C2~GET(LNK+2))<0 THEN GO XIT ;                            04335000
          PUT(LNK+2,-(C2&(I~C.INTPARMS)[TONEXTRA]&NEXTEXTRA[TOADINFO]));04336000
          FOR I~I STEP -1 UNTIL 1 DO                                    04337000
               BEGIN                                                    04338000
               EXTRAINFO[NEXTEXTRA.IR,NEXTEXTRA.IC]~0&EXPCLASS[TOCLASS] 04339000
                                                      &C1[TOSUBCL] ;    04340000
               NEXTEXTRA~NEXTEXTRA+1 ;                                  04341000
               END ;                                                    04342000
          INFO[LNK.IR,LNK.IC].SUBCLASS~C.INTCLASS ;                     04343000
          GO XIT ;                                                      04344000
          END ;                                                         04345000
     IF BOOLEAN(LNK.[2:1]) THEN                                         04346000
     STACKHEAD[GET((NEXTINFO~NEXTINFO-3)+1) MOD SHX]~GET(NEXTINFO).LINK;04347000
     LNK~C.INTINLINE;  INT[C2].INTSEEN~1;  DOITINLINE~TRUE ;            04348000
     IF C4>0 THEN INLINEINT[I]~-C4;  I~0 ;                              04349000
     IF XREF THEN ENTERX(C3,0&FUNID[TOCLASS]&C[21:6:3]);                04350000
     IF GLOBALNEXT!LPAREN THEN BEGIN FLOG(106); GO XIT END ;            04351000
 LOOP:    SCAN;  C5~XTA ;                                               04352000
     IF I=0 THEN                                                        04353000
          IF LNK=10 THEN EMITL(0) ELSE IF LNK=21 THEN EMITDESCLIT(2) ;  04354000
     IF (C4~EXPR(TRUE))!C1 AND (C1!REALTYPE OR C4!INTYPE) THEN          04355000
          BEGIN XTA~C5; FLAG(88); C2~-2 END ;                           04356000
     I~I+1;  IF GLOBALNEXT=COMMA THEN GO LOOP ;                         04357000
     IF GLOBALNEXT!RPAREN THEN BEGIN FLOG(108); C2~-2 END;  SCAN ;      04358000
     IF I!C.INTPARMS THEN IF C.INTPARMS!0 OR I<2 THEN                   04359000
          BEGIN XTA~C3;  FLAG(28);  C2~-2 END ;                         04360000
     OPTYPE[IT]~C.INTCLASS;  IF C2<0 THEN GO XIT ;                      04361000
     CASE (LNK-1) OF                                                    04362000
          BEGIN                                                         04363000
          E0(SSP) ; % @1: ABS, DABS, IABS.                              04364000
 AIMAG:   E0(DEL) ; % @2: AIMAG.                                        04365000
 AINT:    EP(1,IDV) ; % @3: AINT, IFIX, INT.                            04366000
          E0(RDV) ; % @4: AMOD.                                         04367000
          E0(LND) ; % @5: LOGICAL AND.                                  04368000
 CMPLX:   E0(XCH) ; % @6: CMPLX.                                        04369000
          E0(LNG) ; % @7: LOGICAL COMPLIMENT (NEGATION).                04370000
                                                                        04371000
          BEGIN % @10: DIM, IDIM.                                       04372000
          E0(SUB);  E0(DUP);  EP(0,LESS) ;                              04373000
          IF ADR>4082 THEN BEGIN ADR~ADR+1; SEGOVF END ;                04374000
          EP(2,BFC);  E0(DEL);  EMITL(0) ;                              04375000
          END ;                                                         04376000
                                                                        04377000
          BEGIN E0(XCH); E0(CHS); GO CMPLX END ; % @11: CONJG.          04378000
          ; % @12: DBLE (SOME CODE ALREADY EMITTED ABOVE).              04379000
                                                                        04380000
          BEGIN E0(XCH); E0(DEL) ; % @13: DSIGN.                        04381000
 DDT111:  EMITDDT(1,1,1) ;                                              04382000
          END;                                                          04383000
                                                                        04384000
          E0(LQV) ; % @14: LOGICAL EQUIVALENCE.                         04385000
          ; % @15: FLOAT.                                               04386000
          GO DDT111 ; % @16: ISIGN, SIGN.                               04387000
          BEGIN E0(RDV); GO AINT END ; % @17: MOD.                      04388000
          E0(LOR) ; % @20: LOGICAL OR.                                  04389000
          BEGIN E0(XCH); GO AIMAG END ; % @21: REAL.                    04390000
          EP(1,KOM) ; % @22: TIME.                                      04391000
                                                                        04392000
          BEGIN % @23: SNGL.                                            04393000
 SNGL:    EP(9,SND);  E0(XCH);  EMITDDT(47,9,1);  EMITL(0) ;            04394000
          EMITDDT(9,9,38); EOL(9); EMITO(ADD); IF LNK=20 THEN GO AINT ; 04395000
          END ;                                                         04396000
                                                                        04397000
          GO SNGL ; % @24: IDINT.                                       04398000
                                                                        04399000
          BEGIN % @25: AMAX0,AMAX1,AMIN0,AMIN1,MAX0,MAX1,MIN0,MIN1.     04400000
                %      SOME CODE ALREADY EMITTED ABOVE.                 04401000
          IF ADR>4068 THEN BEGIN ADR~ADR+1; SEGOVF END ;                04402000
          EP(9,STD); E0(DUP); EOL(9) ;                                  04403000
          E0(IF C3.[24:6]="A" OR C3.[24:6]="X" THEN LESS ELSE GRTR) ;   04404000
          EP(2,BFC); E0(DEL); EOL(9); E0(XCH); E0(TOP); E0(LNG) ;       04405000
         EP(14,BBC); E0(DEL); IF C3="MIN1  " OR C3="MAX1  " THEN GO AINT04406000
          END ;                                                         04407000
                                                                        04408000
          END OF CASE STATEMENT ;                                       04409000
 XIT:                                                                   04410000
     IF DEBUGTOG THEN FLAGROUTINE("DOITIN","LINE  ",FALSE) ;            04411000
     END OF DOITINLINE ;                                                04412000
REAL PROCEDURE LOOKFORINTRINSIC(L); VALUE L; REAL L;                    04413000
BEGIN                                                                   04414000
   ALPHA ID, I, X, NPARMS;                                              04415000
   REAL T;                                                              04416000
   LABEL FOUND, XIT;                                                    04417000
IF DEBUGTOG THEN FLAGROUTINE("LOOKFO","RINTRN",TRUE);                   04418000
   LOOKFORINTRINSIC ~ L ~ NEED(ID ~ GET(L+1),FUNID);                    04419000
   IF GET(L+2) < 0 THEN GO TO XIT; % PARAMETER INFO KNOWN               04420000
   COMMENT B MUST BE SET TO K/2, WHERE K IS THE INDEX OF THE LAST       04421000
   INTRINSIC NAME IN THE ARRAY INT;                                     04422000
         A~0;  B~NUMINTM1 ;                                             04423000
         WHILE A+1 < B DO                                               04424000
         BEGIN                                                          04425000
            I ~ REAL(BOOLEAN(A+B) AND BOOLEAN(1022));                   04426000
            IF Z ~ INT[I] = ID THEN GO TO FOUND;                        04427000
            IF ID < Z THEN B ~ I.[36:11] ELSE A ~ I.[36:11];            04428000
         END;                                                           04429000
         IF ID = INT[I~(A+B)|2-I] THEN GO TO FOUND;                     04430000
   GO TO XIT;                                                           04431000
   FOUND:                                                               04432000
    NPARMS~(X~INT[I+1]).INTPARMS;  INT[I+1].INTSEEN~1 ;                 04433000
    INFO[L.IR,L.IC].SUBCLASS~X.INTCLASS ;                               04434000
   PUT(L+2,-(1&NEXTEXTRA[TOADINFO]&NPARMS[TONEXTRA]));                  04435000
   IF NPARMS = 0 THEN NPARMS ~ 1;                                       04436000
    T~X.INTPARMCLASS ;                                                  04437000
   FOR I ~ 1 STEP 1 UNTIL NPARMS DO                                     04438000
   BEGIN                                                                04439000
      EXTRAINFO[NEXTEXTRA.IR,NEXTEXTRA.IC] ~                            04440000
         0 & EXPCLASS[TOCLASS] & T[TOSUBCL];                            04441000
      NEXTEXTRA ~ NEXTEXTRA + 1;                                        04442000
   END;                                                                 04443000
   XIT:                                                                 04444000
IF DEBUGTOG THEN FLAGROUTINE("LOOKFO","RINTRN",FALSE ) ;                04445000
END LOOKFORINTRINSIC;                                                   04446000
INTEGER PROCEDURE EXPR(VALREQ); VALUE VALREQ; BOOLEAN VALREQ;           04447000
BEGIN LABEL LOOP, STACK, XIT, NOSCAN; REAL T;                           04448000
   LABEL ARRY;                                                          04449000
LABEL HERE ;                                                            04450000
                                                                        04451000
                                                                        04452000
   REAL SAVIT, SAVIP;                                                   04453000
   BOOLEAN CNSTSEENLAST;       %FOR HANDLING CONSTANT              %113-04454000
   REAL SAVEADR;               %EXPONENTS                          %113-04455000
   DEFINE OPTYPE = LSTT#;                                               04456000
REAL EXPRESLT,EXPLNK;                                                   04457000
   REAL EXPV;                                                           04458000
    REAL TM ;                                                           04459000
    DEFINE E0=EMITO#, EP=EMITPAIR#, EOL=EMITOPDCLIT#,                   04460000
           ES1(OP)=BEGIN E0(XCH); EP(9,STD); E0(OP) END #,              04461000
           ES2=BEGIN  EP(9,STD); E0(XCH);  EP(17,SND); E0(MUL) END # ;  04462000
    LABEL CTYP, DTYP, RLESSC, DLESSC, CLESSD, CLESSC, RPLUSD, DTIMESC,  04463000
          CTIMESR, CDIVBYD, CTIMESR1, CTIMESR2, DLESSC1 ;               04464000
    LABEL SPECCHAR, RELATION;                                           04465000
   REAL LINK;                                                           04466000
   DEFINE T1 = EXPT1#, T2 = EXPT2#, CODE = EXPT3#;                      04467000
COMMENT THE FOLLOWING TABLE GIVES THE PRECEDENCE (PREC) AND             04468000
OPERATOR NUMBER (OP) OF THE ARITHMETIC AND LOGICAL OPERATORS.           04469000
         OPERATOR            PREC      OP                               04470000
         **                  9         15                               04471000
         UNARY -             8         12                               04472000
         /                   7         14                               04473000
         *                   7         13                               04474000
         -                   5         11                               04475000
         +                   5         10                               04476000
         .NE.                4         9                                04477000
         .GE.                4         8                                04478000
         .GT.                4         7                                04479000
         .EQ.                4         6                                04480000
         .LE.                4         5                                04481000
         .LT.                4         4                                04482000
         .NOT.               3         3                                04483000
         .AND.               2         2                                04484000
         .OR.                1         1                                04485000
         THE UNARY PLUS IS IGNORED;                                     04486000
PROCEDURE MATH(D, C, T); VALUE D, C, T; REAL D, C, T;                   04487000
BEGIN                                                                   04488000
   EMITO(MKS);                                                          04489000
   EMITL(C);                                                            04490000
   EMITV(NEED(".MATH ", INTRFUNID));                                    04491000
   EMITO(DEL);                                                          04492000
   IF D = 2 THEN EMITO(DEL);                                            04493000
   OPTYPE[IT~IT-1] ~ T;                                                 04494000
END MATH;                                                               04495000
   NNEW ~ NAME;                                                         04496000
IF DEBUGTOG THEN FLAGROUTINE(" EXPRE","SSION ",TRUE ) ;                 04497000
   OPTYPE[SAVIT ~IT ~ IT+1] ~                                           04498000
   PR[SAVIP~IP~IP+1] ~ OPST[IP] ~ 0;                                    04499000
   IF GLOBALNEXT = PLUS THEN GO TO LOOP;                                04500000
   IF GLOBALNEXT = MINUS THEN                                           04501000
   BEGIN PREC ~ 8; OP ~ 12; GO TO STACK END;                            04502000
   IF PREC > 0 THEN GO TO STACK;                                        04503000
   LINK~(EXPLNK~FNEXT)&REAL(SCANENTER)[2:47:1] ;                        04504000
   GO TO NOSCAN;                                                        04505000
   LOOP: SCAN;                                                          04506000
   LINK ~ FNEXT;                                                        04507000
   NOSCAN:                                                              04508000
   CNSTSEENLAST~FALSE;                                             %113-04509000
   IF GLOBALNEXT = ID THEN                                              04510000
   BEGIN                                                                04511000
      IF IP ! SAVIP THEN EXPRESLT ~ EXPCLASS;                           04512000
      OPTYPE[IT~IT+1] ~ (A~GET(LINK)).SUBCLASS;                         04513000
      SCAN;                                                             04514000
      IF NOT RANDOMTOG THEN                                             04515000
      IF NEXT=EQUAL THEN BEGIN NEXT~0; OP~6; PREC~4 END ;               04516000
      IF GLOBALNEXT = ID OR GLOBALNEXT = NUM THEN                       04517000
         BEGIN FLOG(1); GO TO XIT END;                                  04518000
      IF NOT VALREQ AND PREC > 0 THEN VALREQ ~ TRUE;                    04519000
      IF GLOBALNEXT ! LPAREN THEN                                       04520000
      BEGIN                                                             04521000
         LINK ~ GETSPACE(LINK);                                         04522000
         T ~ (A~GET(LINK)).CLASS;                                       04523000
         IF XREF THEN ENTERX(GET(LINK+1),0&A[15:15:9]);                 04524000
         IF EXPRESLT = 0 THEN EXPRESLT ~ T;                             04525000
         IF VALREQ THEN                                                 04526000
            IF T = VARID THEN EMITV(LINK) ELSE                          04527000
               BEGIN XTA ~ GET(LINK+1); FLAG(50) END                    04528000
         ELSE                                                           04529000
         BEGIN                                                          04530000
            IF T = VARID THEN                                           04531000
               IF GLOBALNEXT > SLASH AND EXPRESLT = VARID THEN          04532000
               BEGIN                                                    04533000
                  DESCREQ~TRUE; EMITN(LINK); DESCREQ ~ FALSE;           04534000
                  GO TO XIT;                                            04535000
               END ELSE EMITV(LINK)                                     04536000
            ELSE                                                        04537000
            BEGIN                                                       04538000
               IF T = ARRAYID THEN                                      04539000
               BEGIN                                                    04540000
                  IF BOOLEAN(A.CE) THEN                                 04541000
                     EMITNUM(GET(LINK+2).BASE) ELSE                     04542000
                     IF BOOLEAN(A.FORMAL) THEN                          04543000
                       EMITOPDCLIT(A.ADDR-1) ELSE                       04544000
                      EMITL(0);                                         04545000
                  GO TO ARRY;                                           04546000
               END ELSE EMITPAIR(A.ADDR,LOD);                           04547000
               GO TO XIT;                                               04548000
            END;                                                        04549000
         END;                                                           04550000
         GO TO SPECCHAR;                                                04551000
      END;                                                              04552000
      IF A.CLASS ! ARRAYID THEN                                         04553000
      BEGIN COMMENT FUNCTION REFERENCE;                                 04554000
         EXPRESLT ~ EXPCLASS;                                           04555000
         IF A.CLASS = STMTFUNID THEN                                    04556000
              BEGIN                                                     04557000
              IF XREF THEN ENTERX(GET(LINK+1),0&A[15:15:9]);            04558000
              STMTFUNREF(LINK) ;                                        04559000
              IF NEXT=EQUAL THEN IF NOT RANDOMTOG THEN                  04560000
                   BEGIN NEXT~0; OP~6; PREC~4 END ;                     04561000
              GO TO SPECCHAR ;                                          04562000
              END ;                                                     04563000
            IF A.CLASS=EXTID OR GET(TM~GLOBALSEARCH(GET(LINK+1))).CLASS=04564000
              EXTID THEN LINK~REAL(DOITINLINE(-LINK)) ELSE              04565000
            IF A.CLASS<FUNID AND TM=0 THEN                              04566000
              IF DOITINLINE(LINK) THEN GO HERE ELSE                     04567000
                LINK ~ LOOKFORINTRINSIC(LINK) ELSE                      04568000
                LINK ~ NEED(GET(LINK+1),FUNID);                         04569000
              IF XREF THEN ENTERX(GET(LINK+1),0&GET(LINK)[15:15:9]);    04570000
             EMITO(MKS);                                                04571000
                                                                        04572000
          PARAMETERS(LINK);                                             04573000
          IF ERRORTOG THEN GO TO XIT ELSE SCAN;                         04574000
          EMITV(LINK );                                                 04575000
          IF OPTYPE[IT] ~ GET(LINK).SUBCLASS } DOUBTYPE THEN            04576000
             EMITOPDCLIT(JUNK);                                         04577000
HERE:     IF NEXT=EQUAL THEN                                            04578000
               IF NOT RANDOMTOG THEN BEGIN NEXT~0; PREC~4; OP~6 END ;   04579000
       END ELSE                                                         04580000
       BEGIN COMMENT ARRAY REFERENCE;                                   04581000
          IF XREF THEN ENTERX(GET(LINK+1),0&A[15:15:9]);                04582000
          SCAN;                                                         04583000
          VALREQ ~ SUBSCRIPTS(LINK,REAL(VALREQ));                       04584000
          IF ERRORTOG THEN GO TO XIT;                                   04585000
          IF NEXT=EQUAL THEN IF NOT RANDOMTOG THEN                      04586000
               BEGIN NEXT~0; OP~6; PREC~4 END ;                         04587000
          IF EXPRESLT = 0 THEN EXPRESLT  ~ SUBSVAR;                     04588000
          IF NOT VALREQ THEN                                            04589000
          BEGIN                                                         04590000
             IF GLOBALNEXT > SLASH AND EXPRESLT = SUBSVAR THEN          04591000
             BEGIN                                                      04592000
                ARRY:                                                   04593000
                IF BOOLEAN((A~GET(LINK)).TWOD) THEN                     04594000
                BEGIN                                                   04595000
                   EMITPAIR(TWODPRT, LOD);                              04596000
                   T ~ A.ADDR;                                          04597000
                   IF T { 1023 THEN                                     04598000
                   BEGIN                                                04599000
                      EMITL(T.[38:10]);                                 04600000
                      EMITDESCLIT(10);                                  04601000
                   END ELSE                                             04602000
                   BEGIN                                                04603000
                      EMITL(T.[40:8]);                                  04604000
                      EMITDESCLIT(1536);                                04605000
                      EMITO(INX);                                       04606000
                   END;                                                 04607000
                   EMITO(CTF);                                          04608000
                END ELSE EMITPAIR(A.ADDR,LOD);                          04609000
                EMITO(XCH);                                             04610000
                GO TO XIT;                                              04611000
             END;                                                       04612000
             IF BOOLEAN((A~GET(LINK)).TWOD) THEN                        04613000
             BEGIN                                                      04614000
                SPLIT(A.ADDR);                                          04615000
                IF A.SUBCLASS } DOUBTYPE THEN                           04616000
                BEGIN                                                   04617000
                   EMITO(CDC);                                          04618000
                   EMITO(DUP);                                          04619000
                   EMITPAIR(1, XCH);                                    04620000
                   EMITO(INX);                                          04621000
                   EMITO(LOD);                                          04622000
                   EMITO(XCH);                                          04623000
                   EMITO(LOD);                                          04624000
                END ELSE EMITO(COC);                                    04625000
             END ELSE                                                   04626000
             EMITV(LINK);                                               04627000
          END;                                                          04628000
       END ARRAY REFERENCE;                                             04629000
       GO TO SPECCHAR;                                                  04630000
    END;                                                                04631000
    IF GLOBALNEXT = NUM THEN                                            04632000
    BEGIN                                                               04633000
       IF NUMTYPE = STRINGTYPE THEN                                     04634000
          IF VALREQ THEN                                                04635000
          BEGIN                                                         04636000
          NUMTYPE~INTYPE ;                                              04637000
          IF STRINGSIZE=1 THEN FNEXT~STRINGARRAY[0]                     04638000
          ELSE BEGIN                                                    04639000
              IF STRINGSIZE>2 OR STRINGARRAY[1].[18:30]!"      " THEN   04640000
                 FLAG(162) ;                                            04641000
              IF (FNEXT~STRINGARRAY[1].[12:6]&STRINGARRAY[0][6:12:36])  04642000
                .[6:6]>7 THEN NUMTYPE~REALTYPE ;                        04643000
              END ;                                                     04644000
         END;                                                           04645000
   SAVEADR~ADR; CNSTSEENLAST~TRUE;                                 %113-04646000
      IF NUMTYPE = DOUBTYPE THEN                                        04647000
         EMITNUM2(FNEXT,DBLOW) ELSE EMITNUM (FNEXT);                    04648000
      OPTYPE[IT~IT+1] ~ NUMTYPE;                                        04649000
      IF EXPRESLT  = 0 THEN                                             04650000
      BEGIN EXPRESLT  ~ NUMCLASS; EXPV    ~ FNEXT END;                  04651000
      SCAN;                                                             04652000
      IF NOT RANDOMTOG THEN                                             04653000
      IF NEXT=EQUAL THEN BEGIN NEXT~0; OP~6; PREC~4 END;                04654000
      IF NOT VALREQ AND PREC > 0 THEN VALREQ ~ TRUE;                    04655000
      IF GLOBALNEXT = ID OR GLOBALNEXT = NUM THEN                       04656000
         BEGIN FLOG(1); GO TO XIT END;                                  04657000
   END;                                                                 04658000
   SPECCHAR:                                                            04659000
   IF GLOBALNEXT = LPAREN THEN                                          04660000
   BEGIN                                                                04661000
      SCAN;                                                             04662000
      OPTYPE[IT~IT+1] ~ EXPR(TRUE);                                     04663000
                                                                        04664000
      IF GLOBALNEXT = COMMA AND EXPRESULT = NUMCLASS THEN               04665000
         BEGIN                                                          04666000
            IF OPTYPE[IT] > REALTYPE THEN FLAG(85);                     04667000
            SCAN;                                                       04668000
            IF EXPR(TRUE) > REALTYPE                                    04669000
               OR EXPRESULT ! NUMCLASS THEN FLAG(85);                   04670000
            EMITO(XCH);                                                 04671000
            OPTYPE[IT] ~ COMPTYPE;                                      04672000
            IF EXPRESLT = 0 THEN EXPRESLT ~ NUMCLASS;                   04673000
         END ELSE EXPRESLT ~ EXPCLASS;                                  04674000
      IF GLOBALNEXT ! RPAREN THEN                                       04675000
      BEGIN FLOG(108); GO TO XIT END;                                   04676000
      GO TO LOOP;                                                       04677000
    END;                                                                04678000
    WHILE PR[IP] } PREC DO                                              04679000
 BEGIN                                                                  04680000
    IF IT { SAVIT THEN GO TO XIT;                                       04681000
    CODE ~ MAP[T1~OPTYPE[IT-1]]|3 + MAP[T2~OPTYPE[IT]];                 04682000
    CASE OPST[IP] OF                                                    04683000
 BEGIN                                                                  04684000
    GO TO XIT;                                                          04685000
    BEGIN                                                               04686000
       IF T1 = LOGTYPE AND T2 = LOGTYPE THEN EMITO(LOR)                 04687000
          ELSE FLAG(51);                                                04688000
       IT ~ IT-1;                                                       04689000
    END;                                                                04690000
    BEGIN                                                               04691000
       IF T1 = LOGTYPE AND T2 = LOGTYPE THEN EMITO(LND)                 04692000
          ELSE FLAG(52);                                                04693000
       IT ~ IT-1;                                                       04694000
    END;                                                                04695000
    IF T2 = LOGTYPE THEN EMITO(LNG) ELSE FLAG(53);                      04696000
    BEGIN T ~ LESS; GO TO RELATION END;                                 04697000
    BEGIN T ~ LEQL; GO TO RELATION END;                                 04698000
    BEGIN T ~ EQUL; GO TO RELATION END;                                 04699000
    BEGIN T ~ GRTR; GO TO RELATION END;                                 04700000
    BEGIN T ~ GEQL; GO TO RELATION END;                                 04701000
    BEGIN T ~ NEQL;                                                     04702000
       RELATION:                                                        04703000
       IF CODE < 0 THEN FLAG(54) ELSE                                   04704000
       CASE CODE OF                                                     04705000
       BEGIN   ;                                                        04706000
          BEGIN                                                         04707000
               E0(CHS); EP(9,STD); E0(XCH); EOL(9); E0(XCH); EP(0,XCH) ;04708000
               E0(AD2) ;                                                04709000
          END;                                                          04710000
          FLAG(90);                                                     04711000
          BEGIN EMITPAIR(0, XCH); EMITO(SB2) END;                       04712000
          EMITO(SB2);                                                   04713000
          FLAG(90);                                                     04714000
          FLAG(90);                                                     04715000
          FLAG(90);                                                     04716000
          IF T! EQUL AND T! NEQL THEN FLAG(54)                     %103-04717000
          ELSE                                                     %103-04718000
              BEGIN                                                %103-04719000
              EP(9,STD); E0(XCH); EOL(9); E0(T);                   %103-04720000
              EP(9,STD ); E0(T); EOL(9);                           %103-04721000
              T~(IF T=EQUL THEN LND ELSE LOR); CODE~0;             %103-04722000
              END;                                                 %103-04723000
       END RELATION CASE STATEMENT;                                     04724000
       IF CODE > 0 THEN                                                 04725000
       BEGIN EMITO(XCH); EMITO(DEL); EMITL(0) END;                      04726000
       EMITO(T);                                                        04727000
       OPTYPE[IT~IT-1] ~ LOGTYPE;                                       04728000
    END;                                                                04729000
    IF CODE < 0 THEN BEGIN FLAG(53); IT ~ IT-1 END ELSE                 04730000
    CASE CODE OF                                                        04731000
    BEGIN                                                               04732000
       BEGIN                                                            04733000
          EMITO(ADD);                                                   04734000
          IF T1 = INTYPE AND T2 = INTYPE THEN IT ~ IT-1 ELSE            04735000
             OPTYPE[IT~IT-1] ~ REALTYPE;                                04736000
       END;                                                             04737000
       BEGIN TM~AD2 ;                                                   04738000
 RPLUSD: EP(9,STD); E0(XCH); EOL(9); E0(XCH); EP(0,XCH); E0(TM) ;       04739000
 DTYP:   OPTYPE[IT~IT-1]~DOUBTYPE ;                                     04740000
       END ;                                                            04741000
       BEGIN TM~ADD; GO RLESSC END ;                                    04742000
       BEGIN                                                            04743000
          EMITPAIR(0, XCH);                                             04744000
          EMITO(AD2);                                                   04745000
          IT ~ IT-1;                                                    04746000
       END;                                                             04747000
       BEGIN EMITO(AD2); IT ~ IT-1 END;                                 04748000
       BEGIN TM~ADD; GO DLESSC END ;                                    04749000
       BEGIN EMITO(ADD); IT ~ IT-1 END;                                 04750000
       BEGIN TM~ADD; GO CLESSD END ;                                    04751000
       BEGIN TM~ADD; GO CLESSC END ;                                    04752000
    END ADD CASE STATEMENT;                                             04753000
    IF CODE < 0 THEN BEGIN FLAG(55); IT ~ IT-1 END ELSE                 04754000
    CASE CODE OF                                                        04755000
    BEGIN                                                               04756000
       BEGIN                                                            04757000
          EMITO(SUB);                                                   04758000
          IF T1 = INTYPE AND T2 = INTYPE THEN IT ~ IT-1 ELSE            04759000
             OPTYPE[IT~IT-1] ~ REALTYPE;                                04760000
       END;                                                             04761000
       BEGIN E0(CHS); TM~AD2; GO RPLUSD END;                            04762000
       BEGIN TM~SUB ;                                                   04763000
 RLESSC:  ES1(TM); GO DLESSC1 ;                                         04764000
       END ;                                                            04765000
       BEGIN                                                            04766000
          EMITPAIR(0, XCH);                                             04767000
          EMITO(SB2);                                                   04768000
          IT ~ IT-1;                                                    04769000
       END;                                                             04770000
       BEGIN EMITO(SB2); IT ~ IT-1 END;                                 04771000
       BEGIN TM~SUB ;                                                   04772000
 DLESSC:  ES1(TM); E0(XCH); E0(DEL) ;                                   04773000
 DLESSC1: EOL(9); IF TM=SUB THEN E0(CHS); GO CTIMESR2 ;                 04774000
       END ;                                                            04775000
       BEGIN EMITO(SUB); IT ~ IT-1 END;                                 04776000
       BEGIN TM~SUB ;                                                   04777000
 CLESSD:  E0(XCH); E0(DEL); E0(TM) ;                                    04778000
 CTYP:    OPTYPE[IT~IT-1]~COMPTYPE ;                                    04779000
       END ;                                                            04780000
       BEGIN TM~SUB ;                                                   04781000
 CLESSC:  ES1(TM); GO CTIMESR1 ;                                        04782000
       END ;                                                            04783000
    END SUBTRACT CASE STATEMENT;                                        04784000
    BEGIN % HANDLE NEGATIVE NUMBERS CASE STATEMENT.                     04785000
    EXPV~-EXPV ;                                                        04786000
    IF T2 { REALTYPE THEN EMITO(CHS) ELSE                               04787000
    IF T2 = LOGTYPE THEN FLAG(55) ELSE                                  04788000
    IF T2 = DOUBTYPE THEN EMITO(CHS) ELSE                               04789000
    IF T2 = COMPTYPE THEN                                               04790000
    BEGIN                                                               04791000
       EMITO(CHS); EMITO(XCH);                                          04792000
       EMITO(CHS); EMITO(XCH);                                          04793000
    END ELSE FLAG(55);                                                  04794000
    END OF NEG NUMBERS CASE STATEMNT ;                                  04795000
    IF CODE < 0 THEN BEGIN FLAG(55); IT ~ IT-1 END ELSE                 04796000
    CASE CODE OF                                                        04797000
    BEGIN                                                               04798000
       BEGIN                                                            04799000
          EMITO(MUL);                                                   04800000
          IF T1 = INTYPE AND T2 = INTYPE THEN IT ~ IT-1 ELSE            04801000
             OPTYPE[IT~IT-1] ~ REALTYPE;                                04802000
       END;                                                             04803000
       BEGIN TM~ML2; GO RPLUSD END ;                                    04804000
       BEGIN ES2; GO DTIMESC END ;                                      04805000
       BEGIN                                                            04806000
          EMITPAIR(0, XCH);                                             04807000
          EMITO(ML2);                                                   04808000
          IT ~ IT-1;                                                    04809000
       END;                                                             04810000
       BEGIN EMITO(ML2); IT ~ IT-1 END;                                 04811000
       BEGIN ES2; E0(XCH); E0(DEL) ;                                    04812000
 DTIMESC: EOL(9); EOL(17); E0(MUL); GO CTYP ;                           04813000
       END ;                                                            04814000
       BEGIN TM~MUL ;                                                   04815000
 CTIMESR: EP(9,SND); E0(TM) ;                                           04816000
 CTIMESR1:E0(XCH); EOL(9); E0(TM) ;                                     04817000
 CTIMESR2:E0(XCH); GO CTYP ;                                            04818000
       END ;                                                            04819000
       BEGIN TM~MUL; GO CDIVBYD END ;                                   04820000
       MATH(2, 26, COMPTYPE);                                           04821000
    END MULTIPLY CASE STATEMENT;                                        04822000
                                                                        04823000
    IF CODE < 0 THEN BEGIN FLAG(55); IT ~ IT-1 END ELSE                 04824000
    CASE CODE OF                                                        04825000
    BEGIN                                                               04826000
       IF T1 = INTYPE AND T2 = INTYPE THEN                              04827000
       BEGIN EMITO(IDV); IT ~ IT-1 END ELSE                             04828000
       BEGIN EMITO(DIU); OPTYPE[IT~IT-1] ~ REALTYPE END;                04829000
       BEGIN                                                            04830000
       EP(9,STD); EP(17,STD); EP(0,XCH); EOL(17); EOL(9); E0(DV2) ;     04831000
       GO DTYP ;                                                        04832000
       END ;                                                            04833000
       MATH(1, 29, COMPTYPE);                                           04834000
       BEGIN                                                            04835000
          EMITPAIR(0, XCH);                                             04836000
          EMITO(DV2);                                                   04837000
          IT ~ IT-1;                                                    04838000
       END;                                                             04839000
       BEGIN EMITO(DV2); IT ~ IT-1 END;                                 04840000
       MATH(2, 32, COMPTYPE);                                           04841000
       BEGIN TM~DIU; GO CTIMESR END ;                                   04842000
       BEGIN TM~DIU ;                                                   04843000
 CDIVBYD: E0(XCH); E0(DEL); GO CTIMESR ;                                04844000
       END ;                                                            04845000
       MATH(2, 35, COMPTYPE);                                           04846000
    END OF DIVIDE CASE STATEMENT;                                       04847000
    IF CODE < 0 THEN BEGIN FLAG(55); IT ~ IT-1 END ELSE                 04848000
    BEGIN                                                               04849000
    IF CODE = 0 AND T2 = INTYPE AND                                     04850000
       CNSTSEENLAST THEN                                           %113-04851000
    BEGIN                                                               04852000
       IF T1 = INTYPE AND T2 = INTYPE THEN IT ~ IT-1 ELSE               04853000
       OPTYPE[IT~IT-1] ~ REALTYPE;                                      04854000
       EXPV~LINK;                                                 %113- 04855000
       A~1; ADR~SAVEADR;                                          %113- 04856000
       WHILE EXPV  DIV 2 ! 0 DO                                         04857000
       BEGIN                                                            04858000
          EMITO(DUP);                                                   04859000
          IF BOOLEAN(EXPV) THEN BEGIN A~A+1; EMITO(DUP) END;            04860000
          EMITO(MUL);                                                   04861000
          EXPV ~ EXPV DIV 2;                                            04862000
       END;                                                             04863000
       IF EXPV = 0 THEN BEGIN EMITO(DEL); EMITL(1) END ELSE             04864000
       WHILE A ~ A-1 ! 0 DO EMITO(MUL);                                 04865000
    END ELSE                                                            04866000
    BEGIN                                                               04867000
       EMITO(MKS);                                                      04868000
       EMITL(CODE);                                                     04869000
       EMITV(NEED(".XTOI ", INTRFUNID));                                04870000
       CASE CODE OF                                                     04871000
       BEGIN                                                            04872000
          BEGIN EMITO(DEL); OPTYPE[IT~IT-1]~IF (T1=INTYPE AND T2=INTYPE)04873000
                                 THEN INTYPE ELSE REALTYPE END;         04874000
          BEGIN EMITO(DEL); OPTYPE[IT~IT-1] ~ DOUBTYPE END;             04875000
          BEGIN EMITO(DEL); OPTYPE[IT~IT-1]~COMPTYPE END ;              04876000
          BEGIN EMITO(DEL); IT ~ IT-1 END;                              04877000
          BEGIN EMITO(DEL); EMITO(DEL); IT ~ IT-1 END;                  04878000
          BEGIN EMITO(DEL); EMITO(DEL); OPTYPE[IT~IT-1]~COMPTYPE END ;  04879000
          BEGIN EMITO(DEL); IT ~ IT-1 END;                              04880000
          BEGIN EMITO(DEL); EMITO(DEL); IT ~ IT-1 END;                  04881000
          BEGIN EMITO(DEL); EMITO(DEL); IT~IT-1 END ;                   04882000
       END OF POWER CASE STATEMENT;                                     04883000
    END;                                                                04884000
 END;                                                                   04885000
       END;                                                             04886000
       IP ~ IP-1;                                                       04887000
    END;                                                                04888000
    EXPRESLT ~ EXPCLASS;                                                04889000
    STACK:                                                              04890000
    PR[IP~IP+1] ~ PREC;                                                 04891000
    OPST[IP] ~ OP;                                                      04892000
    IF PREC > 0 AND PREC { 4 THEN                                       04893000
    BEGIN                                                               04894000
       SCAN; LINK ~ FNEXT;                                              04895000
       IF NEXT = PLUS THEN GO TO LOOP;                                  04896000
       IF NEXT ! MINUS THEN GO TO NOSCAN;                               04897000
       PREC ~ 8; OP ~ 12;                                               04898000
       GO TO STACK;                                                     04899000
    END;                                                                04900000
    GO TO LOOP;                                                         04901000
    XIT: IF IP ! SAVIP THEN FLOG(56);                                   04902000
    IP ~ SAVIP-1;                                                       04903000
    EXPR ~ OPTYPE[IT];                                                  04904000
    IF OPTYPE[IT-1] ! 0 THEN FLOG(56);                                  04905000
    IT ~ SAVIT-1;                                                       04906000
    EXPRESULT ~ EXPRESLT;                                               04907000
    EXPVALUE ~ EXPV;                                                    04908000
    EXPLINK ~ EXPLNK;                                                   04909000
 IF DEBUGTOG THEN FLAGROUTINE(" EXPRE","SSION ",FALSE) ;                04910000
 END EXPR;                                                              04911000
                                                                        04912000
PROCEDURE FAULT (X);                                                    04913000
    VALUE X;                                                            04914000
    REAL X;                                                             04915000
    BEGIN REAL LINK; LABEL XIT;                                         04916000
         SCAN; IF GLOBALNEXT ! LPAREN THEN BEGIN FLAG(106); GO XIT END; 04917000
         SCAN; IF GLOBALNEXT ! ID THEN BEGIN FLAG(66); GO TO XIT END;   04918000
         IF X = 1 THEN PDPRT[0,0] ~ PDPRT[0,0] & 1[44:47:1] ELSE        04919000
         PDPRT[0,0] ~ PDPRT [0,0] & 1[43  :47:1];                       04920000
         EMITOPDCLIT(41);   EMITO(DUP);                                 04921000
         IF X = 1 THEN BEGIN EMITL(2); EMITO(XCH); EMITL(1) END         04922000
                       ELSE EMITL(6);                                   04923000
         EMITO(LND);                                                    04924000
         IF X = 2 THEN EMITL(3);                                        04925000
         EMITO(SUB);                                                    04926000
         IF X = 2 THEN                                                  04927000
           BEGIN EMITO(DUP); EMITL(3); EMITO(SSN) ;EMITO(EQUL); EMITL(2)04928000
                ;EMITO(BFC) ; EMITO(DEL);EMITL(2);                      04929000
           END;                                                         04930000
         LINK ~ GET(GETSPACE(FNEXT)); EMITPAIR(LINK.ADDR,ISD);          04931000
         IF X = 1 THEN EMITL(30) ELSE EMITL(25);                        04932000
         EMITO(LND); EMITL(41);EMITO(STD);                              04933000
         SCAN; IF GLOBALNEXT ! RPAREN THEN FLAG(108);                   04934000
         SCAN;                                                          04935000
    XIT:                                                                04936000
    END FAULT;                                                          04937000
PROCEDURE SUBREF;                                                       04938000
BEGIN REAL LINK,INFC;                                                   04939000
    REAL ACCIDENT;                                                      04940000
    LABEL XIT;                                                          04941000
IF DEBUGTOG THEN FLAGROUTINE("   SUB","REF   ",TRUE ) ;                 04942000
IF TSSEDITOG THEN IF NAME="ZIP   " AND NOT DCINPUT THEN TSSED(NAME,3) ; 04943000
   IF NAME = "EXIT  " THEN                                              04944000
   BEGIN                                                                04945000
      RETURNFOUND ~ TRUE;                                               04946000
      EMITL(1);                                                         04947000
      EMITPAIR(16,STD);                                                 04948000
      EMITPAIR(10,KOM);                                                 04949000
      EMITPAIR( 5, KOM);                                                04950000
      PUT(FNEXT+1, "......");                                           04951000
      SCAN;                                                             04952000
   END ELSE IF NAME="ZIP   " AND NOT DCINPUT THEN                       04953000
   BEGIN                                                                04954000
      EMITO(MKS);                                                       04955000
      EMITL(0); EMITL(0); % DUMMY FILE AND FORMAT                       04956000
      EMITPAIR(-1,SSN);                                                 04957000
      EMITB(-1,FALSE); LADR1~LAX; ADJUST; DESCREQ~FALSE;                04958000
    IF ADR } 4085 THEN BEGIN ADR~ADR+1; SEGOVF END;                     04959000
      ACCIDENT~PRGDESCBLDR(0,0,ADR.[36:10]+1,NSEG);                     04960000
      EMITOPDCLIT(19);                                                  04961000
      EMITO(GFW);                                                       04962000
      LISTART ~ ADR&NSEG[TOSEGNO]; ADJUST;SCAN;                         04963000
      IF GLOBALNEXT!LPAREN THEN BEGIN FLAG(106);GO TO XIT END;          04964000
      SCAN; IF GLOBALNEXT!ID THEN BEGIN FLAG(66); GO TO XIT END;        04965000
      LINDX ~ FNEXT; SCAN; XTA ~ GET(LINDX+1);                          04966000
      IF GLOBALNEXT!RPAREN THEN BEGIN FLAG(108); GO TO XIT END;         04967000
      LINDX ~ GETSPACE(LINDX);                                          04968000
      IF T~(LINFA~GET(LINDX)).CLASS!ARRAYID THEN                        04969000
                  BEGIN FLAG(66); GO TO XIT END;                        04970000
      IF XREF THEN ENTERX(XTA,0&LINFA[15:15:9]);                        04971000
      EMITPAIR(LADDR~LINFA.ADDR,LOD);                                   04972000
      IF BOOLEAN(LINFA.FORMAL) THEN                                     04973000
         BEGIN                                                          04974000
         IF T ~ GET(LINDX+2)<0 THEN EMITOPDCLIT(T.SIZE)                 04975000
         ELSE EMITNUM(T.SIZE); EMITOPDCLIT(LADDR-1); EMITO(CTF) END     04976000
      ELSE EMITNUM(GET(LINDX+2).BASENSIZE); EMITL(18); EMITO(STD);;     04977000
      EMITL(LINFA.CLASNSUB&0[44:47:1]); EMITL(19); EMITO(STD);          04978000
      BRANCHLIT(LISTART,TRUE); EMITL(19); EMITO(STD);                   04979000
      EMITO(RTS); ADJUST;                                               04980000
      EMITL(1); EMITO(CHS); EMITL(19); EMITO(STD);                      04981000
      EMITDESCLIT(19); EMITO(RTS); FIXB(LADR1); DESCREQ~FALSE;          04982000
      EMITPAIR(ACCIDENT,LOD); EMITOPDCLIT(7); EMITO(FTF);               04983000
      EMITL(6);      %  EDITCODE 6 FOR ZIP                              04984000
      EMITV(NEED(".FTOUT",INTRFUNID));  SCAN                            04985000
    END ELSE IF NAME = "OVERFL" THEN FAULT(2)                           04986000
    ELSE IF NAME = "DVCHK " THEN FAULT(1)                               04987000
    ELSE                                                                04988000
   BEGIN                                                                04989000
   LINK ~ NEED(NAME, SUBRID);                                           04990000
   IF XREF THEN ENTERX(XTA,0&GET(LINK)[15:15:5]);                       04991000
   EMITO(MKS);                                                          04992000
   SCAN;                                                                04993000
   IF GLOBALNEXT = LPAREN THEN                                          04994000
      BEGIN PARAMETERS(LINK); SCAN END ELSE                             04995000
         IF NOT BOOLEAN((INFC~GET(LINK+2)).[1:1]) THEN                  04996000
      PUT(LINK+2,-INFC) ELSE                                            04997000
   IF INFC.NEXTRA ! 0 THEN                                              04998000
      BEGIN XTA ~ GET(LINK+1); FLAG(28) END;                            04999000
   EMITV(LINK);                                                         05000000
   END;                                                                 05001000
    XIT:                                                                05002000
IF DEBUGTOG THEN FLAGROUTINE("   SUB","REF   ",FALSE) ;                 05003000
END SUBREF;                                                             05004000
                                                                        05005000
PROCEDURE DECLAREPARMS(FNEW); VALUE FNEW; REAL FNEW;                    05006000
BEGIN                                                                   05007000
   REAL I, T, NLABELS, INFA, INFB, INFC;                                05008000
IF DEBUGTOG THEN FLAGROUTINE("DECLAR","EPARMS",TRUE ) ;                 05009000
   INFA ~ GET(FNEW);                                                    05010000
   IF INFA.SEGNO ! 0 THEN BEGIN XTA ~ NNEW; FLAG(25) END;               05011000
   INFA.SEGNO ~ NSEG; PUT(FNEW,INFA);                                   05012000
   ENTRYLINK[ELX] ~ 0 & FNEW[TOLINK] & NEXTSS[TOADDR];                  05013000
   FOR I ~ 1 STEP 1 UNTIL PARMS DO                                      05014000
   BEGIN                                                                05015000
   EXTRAINFO[NEXTSS.IR,NEXTSS.IC] ~ PARMLINK[I];                        05016000
   NEXTSS ~ NEXTSS-1;                                                   05017000
   IF T ~ PARMLINK[I] ! 0 THEN                                          05018000
      BEGIN                                                             05019000
         GETALL(T,INFA,INFB,INFC);                                      05020000
         IF BOOLEAN(INFA   .FORMAL) THEN                                05021000
         BEGIN                                                          05022000
            IF INFA.SEGNO = ELX THEN                                    05023000
            BEGIN XTA ~ INFB   ; FLAG(26) END;                          05024000
         END ELSE IF (INFA < 0 AND INFA.ADDR < 1024) OR BOOLEAN(INFA.CE)05025000
                  THEN BEGIN XTA ~ INFB; FLAG(107) END;                 05026000
         INFA    ~ INFA   & 1[TOFORMAL] & ELX[TOSEGNO];                 05027000
         INFC   .BASE ~ I;                                              05028000
         PUT(T,INFA); PUT(T+2,INFC);                                    05029000
      END ELSE NLABELS ~ NLABELS+1;                                     05030000
   END;                                                                 05031000
   IF NLABELS > 0 THEN                                                  05032000
   BEGIN ENTRYLINK[ELX  ].CLASS ~ NLABELS;                              05033000
      IF LABELMOM=0 THEN BEGIN BUMPLOCALS; LABELMOM~LOCALS+1536 END;    05034000
   END;                                                                 05035000
   GETALL(FNEW,INFA,INFB,INFC);                                         05036000
   IF BOOLEAN(INFC.[1:1]) THEN                                          05037000
      BEGIN                                                             05038000
         IF INFC.NEXTRA ! PARMS THEN                                    05039000
            BEGIN XTA ~ INFB; FLOG(41);                                 05040000
               PARMS ~ INFC.NEXTRA;                                     05041000
            END;                                                        05042000
         T ~ INFC.ADINFO;                                               05043000
         FOR I ~ 1 STEP 1 UNTIL PARMS DO                                05044000
         IF NOT(PARMLINK[I] = 0 EQV                                     05045000
            EXTRAINFO[(T+I-1).IR,(T+I-1).IC].CLASS = LABELID) THEN      05046000
            BEGIN IF PARMLINK[I] = 0 THEN XTA ~ "*     "                05047000
               ELSE XTA ~ GET(PARMLINK[I]+1);                           05048000
               FLAG(40);                                                05049000
            END;                                                        05050000
      END                                                               05051000
      ELSE                                                              05052000
      BEGIN                                                             05053000
         IF PARMS = 0 THEN INFC ~ -INFC ELSE                            05054000
         INFC ~ -(INFC & PARMS[TONEXTRA]                                05055000
            & NEXTEXTRA[TOADINFO]);                                     05056000
         PUT(FNEW+2,INFC);                                              05057000
         FOR I ~ 1 STEP 1 UNTIL PARMS DO                                05058000
         BEGIN                                                          05059000
            EXTRAINFO[NEXTEXTRA.IR,NEXTEXTRA.IC] ~ 0 &                  05060000
               (IF PARMLINK[I] = 0 THEN LABELID ELSE 0)[TOCLASS];       05061000
            NEXTEXTRA ~ NEXTEXTRA+1;                                    05062000
         END;                                                           05063000
      END;                                                              05064000
   IF ELX ~ ELX+1 > MAXEL THEN BEGIN FLAG(128); ELX ~ 0 END;            05065000
IF DEBUGTOG THEN FLAGROUTINE("DECLAR","EPARMS",FALSE) ;                 05066000
END DECLAREPARMS;                                                       05067000
PROCEDURE IOLIST(LEVEL);   REAL LEVEL;                                  05068000
BEGIN ALPHA LADR2,T;                                                    05069000
BOOLEAN A;                                                              05070000
INTEGER INDX,I,BDLINK,NSUBS;                                            05071000
      LABEL ROUND,XIT,ERROR,LOOP,SCRAM;                                 05072000
INTEGER STREAM PROCEDURE CNTNAM(IDEN); VALUE IDEN;                      05073000
BEGIN  LABEL  XIT;                                                      05074000
       SI ~ LOC IDEN; SI ~ SI +  3; TALLY ~ 1;                          05075000
       5(IF SC = " " THEN JUMP OUT TO XIT;SI ~ SI+1;TALLY ~ TALLY+1);   05076000
       XIT:  CNTNAM ~ TALLY;                                            05077000
END CNTNAM;                                                             05078000
IF DEBUGTOG THEN FLAGROUTINE("   IOL","IST   ",TRUE ) ;                 05079000
ROUND:  DESCREQ ~ TRUE;                                                 05080000
        LOCALNAME ~ FALSE;                                              05081000
IF GLOBALNEXT = SEMI THEN GO TO XIT;                                    05082000
IF GLOBALNEXT = STAR THEN                                               05083000
    BEGIN IF NOT NAMEDESC THEN                                          05084000
              TV ~ ENTER(0&LISTSID[TOCLASS],LISTID~LISTID+1);           05085000
         LOCALNAME ~ TRUE; NAMEDESC ~ TRUE; SCAN;                       05086000
    END;                                                                05087000
IF GLOBALNEXT = ID THEN                                                 05088000
BEGIN LINDX ~ FNEXT;                                                    05089000
      SCAN; XTA ~ GET(LINDX+1);                                         05090000
      IF GLOBALNEXT = EQUAL THEN       %RETURN TO CALLER                05091000
      BEGIN IF (LINFA~GET(GETSPACE(LINDX))).CLASS ! VARID THEN FLAG(50);05092000
            SCRAM: IF (LEVEL ~ LEVEL-1) < 0 THEN FLOG(97);              05093000
            GO TO XIT;                                                  05094000
      END;                                                              05095000
                                                                        05096000
      IF DATASTMTFLAG AND SPLINK } 0 THEN        %DECLARE OWN           05097000
      BEGIN                                                             05098000
         IF BOOLEAN(GET(LINDX).FORMAL) THEN FLAG(147);                  05099000
         IF SPLINK>1 THEN                                               05100000
              IF GET(LINDX).ADDR>1023 THEN       FLAG(174);             05101000
         LINDX ~ GETSPACE(-LINDX);                                      05102000
         IF BOOLEAN(GET(LINDX).EQ) THEN FLAG(168);                      05103000
      END ELSE LINDX ~ GETSPACE(LINDX);                                 05104000
      IF T ~ (LINFA~GET(LINDX)).CLASS > VARID THEN FLAG(50);            05105000
      IF XREF THEN ENTERX(XTA,C2&LINFA[15:15:9]);                       05106000
      IF GLOBALNAME OR LOCALNAME THEN                                   05107000
         IF NAMEIND~ NAMEIND+1 GTR LSTMAX THEN FLOG(161)                05108000
         ELSE NAMLIST[NAMEIND] ~ XTA & CNTNAM(XTA)[9:45:3];             05109000
      IF T = ARRAYID THEN                                               05110000
        IF GLOBALNEXT ! LPAREN THEN                                     05111000
        BEGIN IF SPLINK ! 1 THEN                                        05112000
              BEGIN                                                     05113000
              EMITL(0);                                                 05114000
              EMITPAIR(LADDR ~ LINFA.ADDR,LOD);                         05115000
              EMITO(FTC);                                               05116000
              EMITDESCLIT(2);                                           05117000
              EMITO(INX);                                               05118000
              EMITO(LOD);                                               05119000
              END ELSE EMITPAIR(LADDR-LINFA.ADDR,LOD);                  05120000
            NSUBS ~ (T ~ GET (LINDX+2)).NEXTRA;                         05121000
            IF GLOBALNAME OR LOCALNAME THEN                             05122000
            BEGIN                                                       05123000
           IF NSUBS GTR SAVESUBS THEN SAVESUBS ~ NSUBS;                 05124000
           IF NSUBS GTR NAMLIST[0] THEN NAMLIST[0] ~ NSUBS;             05125000
                   NAMLIST[NAMEIND].[1:8] ~ NSUBS;                      05126000
            INDX ~ -1;                                                  05127000
            INFA ~ GET(NEED(".SUBAR",BLOCKID)).ADDR;                    05128000
            BDLINK ~ T.ADINFO+1;                                        05129000
            END;                                                        05130000
            IF BOOLEAN (LINFA.FORMAL) THEN                              05131000
            BEGIN                                                       05132000
                  IF T LSS 0 THEN EMITOPDCLIT(T.SIZE)                   05133000
                  ELSE EMITNUM(T.SIZE);                                 05134000
                  EMITOPDCLIT(LADDR-1);                                 05135000
                  EMITO(CTF);                                           05136000
            END ELSE EMITNUM(T.BASENSIZE);                              05137000
            IF GLOBALNAME OR LOCALNAME THEN                             05138000
              FOR I ~ 1 STEP 1 UNTIL NSUBS DO                           05139000
              BEGIN IF T ~ EXTRAINFO[(BDLINK~BDLINK-1).IR,              05140000
                    BDLINK.IC] LSS 0 THEN EMITOPDCLIT(T)                05141000
                    ELSE EMITNUM(T);                                    05142000
                    EMITNUM(INDX ~ INDX+1);                             05143000
                    EMITDESCLIT(INFA);                                  05144000
                    EMITO(STD);                                         05145000
              END;                                                      05146000
            EMITL(18);  EMITO(STD);                                     05147000
        END ELSE                                                        05148000
            BEGIN SCAN;                                                 05149000
                  A ~(IF GLOBALNAME OR LOCALNAME                        05150000
                  THEN SUBSCRIPTS(LINDX,4) ELSE SUBSCRIPTS(LINDX,2));   05151000
                  SCAN;                                                 05152000
            END                                                         05153000
      ELSE EMITN(LINDX);                                                05154000
      IF GLOBALNAME OR LOCALNAME THEN                                   05155000
      BEGIN EMITOPDCLIT(18); EMITNUM(NAMEIND);                          05156000
            EMITD(43,DIA); EMITD(3,DIB); EMITD(15,TRB);                 05157000
            EMITL(18); EMITO(STD);                                      05158000
      END;                                                              05159000
      EMITL(LINFA.CLASNSUB&0[44:47:1]);                                 05160000
      EMITL(20);  EMITO(STD);                                           05161000
    IF ADR > 4083 THEN                                                  05162000
         BEGIN ADR~ADR+1;  SEGOVF END ;                                 05163000
      BRANCHLIT(LISTART,TRUE);                                          05164000
      EMITL(19);  EMITO(STD);                                           05165000
      EMITO(RTS); ADJUST;                                               05166000
      GO TO LOOP;                                                       05167000
END;                                                                    05168000
IF GLOBALNEXT = LPAREN THEN   %  RECURSE ON (                           05169000
BEGIN EMITB(-1,FALSE);                                                  05170000
      ADJUST;                                                           05171000
      LADR2 ~ (ADR + 1)&LAX[TOADDR]&NSEG[TOSEGNO];                      05172000
      SCAN;  LEVEL ~ LEVEL + 1;                                         05173000
      IOLIST(LEVEL);                                                    05174000
      IF GLOBALNEXT ! EQUAL THEN  %  PHONY IMP DO                       05175000
      BEGIN BRANCHES[T ~ LADR2.ADDR] ~ BRANCHX;                         05176000
            BRANCHX ~ T;                                                05177000
            IF GLOBALNEXT ! RPAREN THEN GO TO ERROR;                    05178000
            SCAN;  GO TO LOOP;                                          05179000
      END;                                                              05180000
      IF XREF THEN ENTERX(GET(LINDX+1),1&LINFA[15:15:9]);               05181000
      IF LINFA.SUBCLASS > REALTYPE THEN                                 05182000
      BEGIN XTA ~ GET(LINDX + 1);                                       05183000
            FLAG(84);                                                   05184000
      END;                                                              05185000
      EMITB(-1,FALSE);                                                  05186000
      LADR3 ~ LAX;                                                      05187000
      FIXB(LADR2.ADDR);                                                 05188000
      DESCREQ ~ FALSE;                                                  05189000
      SCAN;  IF EXPR(TRUE) > REALTYPE THEN FLAG(102);  % INITIAL VALUE  05190000
      EMITN(LINDX);      EMITO(STD);                                    05191000
      EMITB(LADR2,FALSE);                                               05192000
      IF GLOBALNEXT ! COMMA THEN GO TO ERROR;                           05193000
      ADJUST;                                                           05194000
      LADR4 ~ (ADR + 1)&NSEG[TOSEGNO];                                  05195000
      SCAN;  IF EXPR(TRUE) > REALTYPE THEN FLAG(102) ELSE EMITO(GRTR);  05196000
      EMITB(LADR2,TRUE);                                                05197000
      EMITB(-1,FALSE);                                                  05198000
      LADR5 ~ LAX;                                                      05199000
      FIXB(LADR3);                                                      05200000
      IF GLOBALNEXT ! COMMA THEN EMITL(1)                               05201000
      ELSE BEGIN SCAN; IF EXPR(TRUE) > REALTYPE THEN FLAG(102); END;    05202000
      EMITV(LINDX);  EMITO(ADD);                                        05203000
      EMITN(LINDX);      EMITO(SND);                                    05204000
      EMITB(LADR4,FALSE);                                               05205000
      FIXB(LADR5);                                                      05206000
      IF GLOBALNEXT = RPAREN THEN SCAN ELSE GO TO ERROR;                05207000
 LOOP:  IF GLOBALNEXT = SEMI OR GLOBALNEXT = SLASH THEN GO TO XIT;      05208000
           IF GLOBALNEXT = RPAREN THEN GO TO SCRAM;                     05209000
             IF GLOBALNEXT = COMMA THEN                                 05210000
             BEGIN SCAN;                                                05211000
                   IF GLOBALNEXT = SEMI THEN GO TO ERROR;               05212000
                   GO TO ROUND;                                         05213000
             END;                                                       05214000
 ERROR: XTA ~ NAME;                                                     05215000
        FLAG(94);                                                       05216000
        IF GLOBALNEXT = SEMI THEN GO TO XIT;                            05217000
        SCAN;                                                           05218000
        IF GLOBALNEXT = ID THEN GO TO ROUND;                            05219000
        ERRORTOG ~ TRUE; GO TO XIT;                                     05220000
 END;                                                                   05221000
 IF GLOBALNEXT = RPAREN THEN GO TO SCRAM ELSE                           05222000
   IF GLOBALNEXT ! SLASH THEN GO TO ERROR;                              05223000
 XIT: IF DEBUGTOG THEN FLAGROUTINE("   IOL","IST   ",FALSE) ;           05224000
 END IOLIST;                                                            05225000
 INTEGER PROCEDURE FILECHECK(FILENAME,FILETYPE);                        05226000
 VALUE FILENAME,FILETYPE;   ALPHA FILENAME;   INTEGER FILETYPE;         05227000
 BEGIN COMMENT  THIS PROCEDURE RETURNS THE PRT CELL ALLOCATED TO        05228000
 THE FILE FILENAME... A CELL IS CREATED IF NONE EXISTS;                 05229000
 IF DEBUGTOG THEN FLAGROUTINE(" FILEC","HECK  ",TRUE);                  05230000
 EMITL(IF NOTOPIO THEN 2 ELSE 5);   %  FOR IO DESCRIPTOR                05231000
 IF T ~ GLOBALSEARCH(FILENAME) = 0 THEN   %  FILE UNDECLARED            05232000
 BEGIN  MAXFILES ~ MAXFILES + 1;                                        05233000
 BUMPPRT;                                                               05234000
 I ~ GLOBALENTER(-0&(FILECHECK~PRTS)[TOADDR]                            05235000
                    &FILEID[TOCLASS],FILENAME)+2;                       05236000
 INFO[I.IR,I.IC]. LINK ~ FILETYPE;                                      05237000
 END ELSE    %  FILE ALREADY EXISTS                                     05238000
 FILECHECK ~  GET(T).ADDR;                                              05239000
 IF DEBUGTOG THEN FLAGROUTINE(" FILEC","HECK  ",FALSE) ;                05240000
 END FILECHECK;                                                         05241000
 PROCEDURE INLINEFILE;                                                  05242000
 BEGIN COMMENT THIS PROCEDURE GENERATES THE CODE TO BRING UP THE FILE...05243000
   IF THE FILE IS AN INTEGER THEN FILECHECK IS CALLED, IF THE FILE      05244000
   IS NOT AN INTEGER THEN IN-LINE CODE IS GENERATED FOR OBJECT TIME     05245000
   ANALYSIS;                                                            05246000
 REAL TEST;                                                             05247000
 COMMENT IF LAST INSTRUCTION WAS A LIT CALL THEN WE HAVE SEEN REFERENCE 05248000
 TO AN INTEGER FILE ID;                                                 05249000
 IF DEBUGTOG THEN FLAGROUTINE(" INLIN","EFILE ",TRUE ) ;                05250000
 TEST~ADR ;                                                             05251000
 IF EXPR(TRUE)>REALTYPE THEN FLAG(102)                                  05252000
 ELSE IF EXPRESULT=NUMCLASS THEN                                        05253000
          BEGIN XTA~NNEW ;                                              05254000
          IF EXPVALUE}1.0@5 OR EXPVALUE{0.5 THEN FLAG(33)               05255000
          ELSE BEGIN                                                    05256000
               IF ADR<TEST THEN % EXPR GOT SEGOVFL--ASSUME NO WRAPAROUND05257000
                    EMITO(DEL)                                          05258000
               ELSE ADR~TEST;                                           05259000
               TEST~SPCLBIN2DEC(C1~EXPVALUE);                           05260000
               IF XREF THEN ENTERX(TEST&1[TOCE],0&FILEID[TOCLASS]) ;    05261000
               EMITDESCLIT(FILECHECK(0&"."[12:42:6]&TEST[18:12:30],     05262000
                           IF DCINPUT THEN 12 ELSE 2)) ;                05263000
               END ;                                                    05264000
           END ELSE                                                     05265000
COMMENT  NOT INTEGER FILE... GENERATE OBJECT TIME CODE;                 05266000
     BEGIN EMITPAIR(17,ISN) ;                                           05267000
     IF FILEARRAYPRT=0 THEN BEGIN BUMPPRT;FILEARRAYPRT~PRTS END;        05268000
     EMITOPDCLIT(FILEARRAYPRT);                                         05269000
     EMITO(DUP);   EMITL(0);   EMITO(EQUL);                             05270000
       COMMENT NEED 7 CONSECUTIVE SYLLABLES;                            05271000
   IF ADR } 4082 THEN                                                   05272000
     BEGIN ADR ~ ADR + 1;                                               05273000
           SEGOVF;                                                      05274000
     END;                                                               05275000
     EMITL(3+FILEARRAYPRT.[38:1]);%CONSIDER POSSIBLE XRT                05276000
     EMITO(BFC);                  % BRANCH AROUND TERMINATION CODE      05277000
     EMITL(1);   EMITO(CHS);   EMITOPDCLIT(FILEARRAYPRT);  %  INV INDEX 05278000
     EMITO(LOD);   EMITL(IF NOTOPIO THEN 2 ELSE 5);   EMITO(CDC);       05279000
END;                                                                    05280000
IF DEBUGTOG THEN FLAGROUTINE(" INLIN","EFILE ",FALSE) ;                 05281000
END INLINEFILE;                                                         05282000
PROCEDURE FILECONTROL(N); VALUE N; REAL N;                              05283000
BEGIN    COMMENT COMPILES ALL CALLS ON ALGOL FILE CONTROL;              05284000
         EODS~TRUE ;                                                    05285000
         EXECUTABLE ;                                                   05286000
         SCAN; EMITO(MKS);                                              05287000
         EMITL(N); EMITL(0);                                            05288000
         NOTOPIO ~ TRUE;                                                05289000
         INLINEFILE ;                                                   05290000
         EMITL(4); EMITOPDCLIT(14);                                     05291000
         NOTOPIO ~ FALSE;                                               05292000
END FILECONTROL;                                                        05293000
PROCEDURE FORMATER;                                                     05294000
BEGIN                                                                   05295000
COMMENT FORMATER COMPILES A PSEUDO CODE USED BY THE OBJECT TIME         05296000
         FORMATING ROUTINES TO PRODUCE DESIRED I/O. USUALLY, THERE IS   05297000
         ONE WORD OF PSEUDO CODE PRODUCED FOR EACH EDITING PHRASE. IN   05298000
         ADDITION ONE WORD IS PRODUCED FOR EACH RIGHT PARENTHESIS AND   05299000
         SLASH GROUP.                                                   05300000
         THE 47TH BIT OF THE FIRST WORD IS SET IF THERE ARE LIST        05301000
         ELEMENT PHRASES IN THE FORMAT STATEMENT.                       05302000
         THERE ARE FOUR GROUPS OF PHRASES:                              05303000
         GROUP 1 = F, E, D, G           = REPEAT WIDTH DECIMAL          05304000
         GROUP 2 = I, J, A, O, L, T, C, = REPEAT WIDTH                  05305000
                   X, P                                                 05306000
         GROUP 3 = H                    = REPEAT SPECIAL PURPOSE        05307000
         GROUP 4 = ), /                 = CONTROL REPEAT LINK           05308000
         WORD FOR GROUP 1:                                              05309000
              CODE    =  [ 1: 5]                                        05310000
              REPEAT  =  [ 6:12]                                        05311000
              WIDTH   =  [18:12]                                        05312000
              DEDIMAL =  [30:12]                                        05313000
         WORD FOR GROUP 2:                                              05314000
              CODE    =  [ 1: 5]                                        05315000
              REPEAT  =  [ 6:12]                                        05316000
              WIDTH   =  [18:12]                                        05317000
              SIGN    = [41: 1]                                         05318000
              FOR P, X AND T REPEAT = 1                                 05319000
              P: SIGN = SIGN OF SCALE                                   05320000
         WORD FOR GROUP 3:                                              05321000
              CODE    =  [ 1: 5]                                        05322000
              REPEAT  =  [ 6:12]                                        05323000
              H: STRING STARTS AT BIT 18 AND CONTINUES TO END OF STRING 05324000
                 REPEAT = NUMBER OF STRING CHARACTERS                   05325000
         WORD FOR GROUP 4:                                              05326000
              CODE    =  [ 1: 5]                                        05327000
              REPEAT  =  [ 6:12]                                        05328000
              LINK    =  [18:12]                                        05329000
              DECIMAL =  [30:12]                                        05330000
              CNTROL  =  [47: 1]                                        05331000
              ): LINK NUMBER OF WORD - 1 BACK TO 1ST PHRASE AFTER       05332000
                     LEFT PAREN                                         05333000
                 REPEAT = REPEAT OF ASSOCIATED LEFT PAREN               05334000
                 OUTER MOST RIGHT PAREN                                 05335000
                   A. DECIMAL ! 0                                       05336000
                   B. LINKS TO LEFT PAREN OF LAST PREVIOUS RIGHT PAREN  05337000
              /: REPEAT = NUMBER OF SLASHES.                            05338000
         ;                                                              05339000
DEFINE   APHASE =  6 #,                                                 05340000
         VPHRASE = 30 #,                                                05341000
         LPPHRASE = 29 #,                                               05342000
         CPHASE = 15 #,                                                 05343000
         DPHASE = 14 #,                                                 05344000
         EPHASE = 13 #,                                                 05345000
         FPHASE = 12 #,                                                 05346000
         GPHASE = 11 #,                                                 05347000
         HPHASE =  2 #,                                                 05348000
         IPHASE = 10 #,                                                 05349000
         JPHASE =  9 #,                                                 05350000
         LPHASE =  8 #,                                                 05351000
         OPHASE =  7 #,                                                 05352000
         PPHASE =  3 #,                                                 05353000
         TPHASE =  5 #,                                                 05354000
         XPHASE =  4 #,                                                 05355000
         RTPARN =  0 #,                                                 05356000
         SLASH  =  1 #,                                                 05357000
         TOCODE    =  1:43: 5 #,                                        05358000
         TOREPEAT  =  6:36:12 #,                                        05359000
         TOWIDTH   = 18:36:12 #,                                        05360000
         TOLINK    = 18:36:12 #,                                        05361000
         TODECIMAL = 30:36:12 #,                                        05362000
         TOCNTRL   = 47:47: 1 #,                                        05363000
         TONUM     = 42:43: 1 #,                                        05364000
         TOSIGN    = 41:47: 1 #,                                        05365000
         WSA       = LSTT #;                                            05366000
REAL J, T;                                                              05367000
LABEL KK,SL,FL ;                                                        05368000
FORMAT FM(//"PHRASE#     CODE   REPEAT    WIDTH  DECIMAL",X2,           05369000
          ".[41:1]  .[42:4]  .[42:5]  .[44:1]  .[45:1]",X2,             05370000
          ".[46.1],  .[46:2]  .[47:1]"/) ;                              05371000
INTEGER D,I,  CODE,REPEAT,WIDTH,DECIMAL,TOTAL,SLCNT,SAVLASTLP,          05372000
        PARENCT,SAVTOTAL;                                               05373000
BOOLEAN VRB,ASK ;                                                       05374000
BOOLEAN LISTEL, HF, ZF, QF, PF, MINUSP, FEELD, STRINGF;                 05375000
BOOLEAN COMMAS, DOLLARS, PLUSP, STR;                                    05376000
LABEL ROUND,NOPLACE,NUM,NUL,LP,RP,ENDER,NOEND,FALL,SEMIC,NUL1;          05377000
LABEL NEWWD, ROUND1;                                                    05378000
ALPHA STREAM PROCEDURE GETCHAR(NCRV, T); VALUE NCRV;                    05379000
BEGIN SI ~ NCRV; DI ~ T; DI ~ DI+7; DS ~ CHR; GETCHAR ~ SI;             05380000
END GETCHAR;                                                            05381000
BOOLEAN PROCEDURE CONTINUE;                                             05382000
BEGIN                                                                   05383000
LABEL LOOP;                                                             05384000
BOOLEAN STREAM PROCEDURE CONTIN(CD);                                    05385000
BEGIN SI~CD; IF SC ! "C" THEN IF SC ! "$" THEN BEGIN SI~SI+5;           05386000
      IF SC ! " " THEN IF SC ! "0" THEN BEGIN TALLY~1;                  05387000
      CONTIN ~ TALLY END END                                            05388000
END OF CONTIN;                                                          05389000
BOOLEAN STREAM PROCEDURE COMNT(CD,T); VALUE T;                          05390000
BEGIN LABEL L;                                                          05391000
   SI~CD; IF SC = "C" THEN BEGIN T(SI~SI+1; IF SC="-" THEN              05392000
   TALLY~1 ELSE JUMP OUT TO L); TALLY~1; L: END; COMNT~TALLY;           05393000
END COMNT;                                                              05394000
BOOLEAN STREAM PROCEDURE DCCONTIN(CD);                                  05395000
BEGIN SI~CD; IF SC = "-" THEN TALLY ~ 1; DCCONTIN~TALLY;                05396000
END DCCONTIN;                                                           05397000
LOOP:   IF NOT(CONTINUE ~                                               05398000
         IF DCINPUT AND NOT TSSEDITOG OR FREEFTOG THEN                  05399000
              IF NEXTCARD<4 THEN DCCONTIN(CB)                           05400000
              ELSE IF NEXTCARD=7 THEN DCCONTIN(DB) ELSE CONTIN(TB)      05401000
         ELSE IF NEXTCARD<4 THEN CONTIN(CB)                             05402000
              ELSE IF NEXTCARD=7 THEN CONTIN(DB) ELSE CONTIN(TB))       05403000
         THEN IF(IF NEXTCARD < 4 THEN                                   05404000
                COMNT(CB,DCINPUT AND NOT TSSEDITOG OR FREEFTOG)         05405000
                ELSE IF NEXTCARD = 7 THEN                               05406000
                COMNT(DB,DCINPUT AND NOT TSSEDITOG OR FREEFTOG)         05407000
         ELSE COMNT(TB,0) AND NEXTCARD!6) THEN                          05408000
         BEGIN                                                          05409000
           IF READACARD THEN IF LISTOG THEN PRINTCARD;                  05410000
           GO TO LOOP;                                                  05411000
         END;                                                           05412000
END CONTINUE;                                                           05413000
STREAM PROCEDURE STORECHAR(ARY,POSIT,CHAR);VALUE POSIT;                 05414000
BEGIN SI ~CHAR; SI ~ SI + 7;                                            05415000
      DI ~ ARY; DI ~ DI + POSIT;                                        05416000
      DS ~ CHR;                                                         05417000
END STORECHAR;                                                          05418000
ALPHA STREAM PROCEDURE BACKNCR(NCRV); VALUE NCRV;                       05419000
BEGIN SI~NCRV; SI ~ SI-1; BACKNCR ~ SI; END BACKNCR;                    05420000
COMMENT ******** START OF CODE **************;                          05421000
IF XTA ~ LABL = BLANKS THEN FLAG(18) ELSE                               05422000
IF D~ SEARCH(LABL) = 0 THEN                                             05423000
   D~ ENTER(0 & FORMATID[TOCLASS], LABL) ELSE                           05424000
   IF GET(D).CLASS ! FORMATID THEN BEGIN D~0;FLAG(143) END;             05425000
IF XREF THEN ENTERX(LABL,1&FORMATID[TOCLASS]);                          05426000
LABL ~ BLANKS;                                                          05427000
NCR ~ BACKNCR(NCR);                                                     05428000
WSA[0] ~ TOTAL ~ 1;                                                     05429000
ROUND1: XTA ~ BLANKS;                                                   05430000
ROUND: NCR ~ GETCHAR(NCR,T);                                            05431000
       IF T = "]" THEN GO TO NOPLACE;                                   05432000
       XTA ~ T & XTA[12:18:30];                                         05433000
       T~IF (T="&" OR T="<") AND                                        05434000
          (HOLTOG OR NOT(HF OR STRINGF)) THEN "+" ELSE                  05435000
       IF (T="@" OR T=":") AND (HOLTOG OR NOT HF) THEN """              05436000
                ELSE T;                                                 05437000
       IF NOT (HF OR STRINGF) THEN                                      05438000
          IF T = " " THEN GO TO ROUND                                   05439000
          ELSE IF T="," THEN GO SL ;                                    05440000
       IF HF THEN                                                       05441000
       BEGIN                                                            05442000
           STORECHAR(WSA[TOTAL],I,T);                                   05443000
           IF HF ~ REPEAT ~ REPEAT - 1 ! 0 THEN                         05444000
           IF I ~ I+1 = 8 THEN                                          05445000
           BEGIN IF TOTAL ~ TOTAL +1 > LSTMAX THEN GO TO NUL;           05446000
                 WSA[TOTAL] ~ I ~ 0; GO TO ROUND;                       05447000
           END ELSE GO TO ROUND ELSE GO TO NUL1;                        05448000
       END;                                                             05449000
      IF NOT STRINGF THEN                                               05450000
      IF SLCNT > 0 THEN                                                 05451000
      IF T = "/" THEN BEGIN SLCNT ~ SLCNT+1; GO TO ROUND; END           05452000
      ELSE                                                              05453000
      BEGIN WSA[TOTAL] ~ 0 & SLCNT[TOREPEAT] & SLASH[TOCODE];           05454000
            IF NOT STR THEN                                             05455000
            IF REPEAT < 16 AND WSA[TOTAL-1].[42:6] = 0 THEN             05456000
              WSA[TOTAL~TOTAL-1] ~ WSA[TOTAL] & SLCNT[42:44:4]          05457000
                        & 1[46:47:1];                                   05458000
             COMMAS~DOLLARS~BOOLEAN(SLCNT~0);  NCR~BACKNCR(NCR) ;       05459000
            GO TO NUL1;                                                 05460000
      END;                                                              05461000
       IF NOT QF THEN IF T = """ THEN IF STRINGF ~ NOT STRINGF THEN     05462000
        BEGIN IF CODE > 4 THEN BEGIN STRINGF ~ FALSE;                   05463000
           NCR ~ BACKNCR(NCR); GO TO ENDER END;                         05464000
          SAVTOTAL ~ TOTAL; J~0; I~3; QF ~ TRUE;                        05465000
          WSA[TOTAL] ~ 0 & HPHASE[TOCODE];                              05466000
          GO TO ROUND;                                                  05467000
        END ELSE                                                        05468000
         BEGIN                                                          05469000
           WSA[SAVTOTAL] ~ WSA[SAVTOTAL] & J[TOREPEAT];                 05470000
            IF  I = 0 THEN TOTAL ~ TOTAL - 1;                           05471000
           CODE ~ HPHASE;                                               05472000
           GO TO ENDER;                                                 05473000
         END;                                                           05474000
       IF STRINGF THEN                                                  05475000
        BEGIN                                                           05476000
          STORECHAR(WSA[TOTAL],I,T);                                    05477000
          J ~ J + 1; QF ~ FALSE;                                        05478000
          IF I ~ I+1 = 8 THEN                                           05479000
        BEGIN                                                           05480000
          IF TOTAL ~ TOTAL +1> LSTMAX THEN GO TO NUL;                   05481000
          I ~ WSA[TOTAL] ~ 0;                                           05482000
        END;                                                            05483000
         GO TO ROUND;                                                   05484000
        END;                                                            05485000
CASE T OF                                                               05486000
BEGIN                                                                   05487000
     BEGIN ZF ~ TRUE;                              % 0                  05488000
      NUM: DECIMAL ~ 10 | DECIMAL + T;                                  05489000
           IF ASK THEN                                                  05490000
              BEGIN FLAG(183);                                     %111-05491000
FL:           DO BEGIN NCR~GETCHAR(NCR,T); XTA~T&XTA[12:18:30] END      05492000
              UNTIL T!"*" AND T>9 AND T!" " ;                           05493000
              NCR~BACKNCR(NCR);  XTA~BLANKS&XTA[18:12:30] ;             05494000
              END                                                       05495000
           ELSE                                                         05496000
           IF DECIMAL>4090 THEN BEGIN FLAG(172); DECIMAL~1 END ;        05497000
           IF CODE = 0 THEN REPEAT ~ DECIMAL                            05498000
           ELSE IF PF THEN BEGIN IF DECIMAL>WIDTH AND WIDTH!0 AND CODE! 05499000
                   VPHRASE THEN FLAG(129) END ELSE WIDTH~DECIMAL ;      05500000
           GO TO ROUND;                                                 05501000
     END;                                                               05502000
     GO TO NUM; GO TO NUM; GO TO NUM;               % 1 2 3             05503000
     GO TO NUM; GO TO NUM; GO TO NUM;               % 4 5 6             05504000
     GO TO NUM; GO TO NUM; GO TO NUM;               % 7 8 9             05505000
     ; ; ; ; ; ;                                    % # @ Q : > }       05506000
     BEGIN PLUSP ~ TRUE; GO TO ROUND; END;          % +                 05507000
     BEGIN CODE ~ APHASE; GO TO NOEND END;          % A                 05508000
     ;                                              % B                 05509000
     BEGIN CODE ~ CPHASE; GO TO NOEND END;          % C                 05510000
     BEGIN CODE ~ DPHASE; GO TO NOEND END;          % D                 05511000
     BEGIN CODE ~ EPHASE; GO TO NOEND END;          % E                 05512000
     BEGIN CODE ~ FPHASE; GO TO NOEND END;          % F                 05513000
     BEGIN CODE ~ GPHASE; GO TO NOEND END;          % G                 05514000
     BEGIN IF REPEAT = 0 THEN FLOG(130);            % H                 05515000
           IF ASK THEN BEGIN FLOG(32 ); GO SEMIC END ;                  05516000
           HF ~ TRUE; I ~ 3; CODE ~ HPHASE;                             05517000
           WSA[TOTAL] ~ 0 & HPHASE[TOCODE] & REPEAT[TOREPEAT];          05518000
           GO TO ROUND;                                                 05519000
     END;                                                               05520000
     BEGIN CODE ~ IPHASE; GO TO NOEND END;          % I                 05521000
     BEGIN IF CODE < 11 OR CODE=15 THEN FLOG(134);  % .                 05522000
           IF CODE=0 OR PF THEN FLOG(32) ;                              05523000
           PF~TRUE;  DECIMAL~0;  ASK~ZF~FALSE ;                         05524000
           GO TO ROUND;                                                 05525000
     END;                                                               05526000
     GO TO RP;                                      % [                 05527000
     ;                                              % &                 05528000
     LP:                                                                05529000
     BEGIN IF CODE ! 0 THEN FLOG(32);               % (                 05530000
           IF ASK THEN REPEAT~4095;  IF REPEAT=0 AND ZF THEN FLAG(173) ;05531000
           NAMLIST[SAVLASTLP ~ PARENCT ~ PARENCT+1] ~ 0 & TOTAL[TOWIDTH]05532000
           &(IF REPEAT{0 AND PARENCT>1 THEN 1 ELSE REPEAT)[TOREPEAT] ;  05533000
           IF ASK THEN                                                  05534000
              BEGIN ASK~VRB~FALSE ;                                     05535000
              WSA[TOTAL]~32&LPPHRASE[TOCODE]&4095[TOREPEAT] ;           05536000
              IF (TOTAL~TOTAL+1)>LSTMAX THEN GO NUL ;                   05537000
              END ;                                                     05538000
           ZF~BOOLEAN(REPEAT~DECIMAL~0) ;                               05539000
           STR ~ TRUE;                                                  05540000
           GO TO ROUND1;                                                05541000
     END;                                                               05542000
     ; ; ;                                          % < ~ |             05543000
     BEGIN CODE~JPHASE; WIDTH~-1; GO NOEND END ;    % J                 05544000
     BEGIN                                          % K                 05545000
     IF COMMAS OR CODE!0 THEN BEGIN FLAG(32); COMMAS~TRUE END           05546000
     ELSE BEGIN COMMAS~TRUE ;                                           05547000
KK:       DO BEGIN NCR~GETCHAR(NCR,T); XTA~T&XTA[12:18:30] END          05548000
          UNTIL T!" " ;                                                 05549000
          IF (T<17 OR (T>25 AND T<33) OR (T>42 AND T<50) OR T>57)       05550000
          THEN BEGIN FLAG(32) ;                                         05551000
               IF T="*" OR T<10 THEN BEGIN DECIMAL~1; GO FL END ;       05552000
               END ;                                                    05553000
          NCR~BACKNCR(NCR);  XTA~BLANKS&XTA[18:12:30] ;                 05554000
          END ;                                                         05555000
     GO ROUND ;                                                         05556000
     END OF K ;                                                         05557000
     BEGIN CODE ~ LPHASE; GO TO NOEND; END;         % L                 05558000
     ; ;                                            % M N               05559000
     BEGIN CODE ~ OPHASE; GO TO NOEND; END;         % O                 05560000
     BEGIN WSA[TOTAL] ~ 0 & PPHASE[TOCODE]          % P                 05561000
            & REAL(VRB)[42:47:1]                                        05562000
            & REAL(MINUSP)[TOSIGN] & REPEAT[TOWIDTH]&1[TOREPEAT];       05563000
            MINUSP ~ PLUSP ~ FALSE;                                     05564000
            IF (DECIMAL = 0 AND NOT ZF) THEN FLOG(131);                 05565000
            GO TO NUL1;                                                 05566000
     END;                                                               05567000
     ; ;                                            % Q R               05568000
     BEGIN IF DOLLARS OR CODE!0 THEN FLAG(32)       % $                 05569000
     ELSE BEGIN DOLLARS~TRUE; GO KK END ;                               05570000
     DOLLARS~TRUE;  GO ROUND ;                                          05571000
     END OF DOLLAR SIGN ;                                               05572000
     IF NOT ASK THEN                                % *                 05573000
         BEGIN                                                          05574000
          IF ZF OR DECIMAL NEQ 0 THEN FLAG(183); DECIMAL:=4095;    %111-05575000
         IF CODE=0 THEN REPEAT~DECIMAL                                  05576000
         ELSE IF NOT PF THEN WIDTH~DECIMAL ;                            05577000
         VRB := ASK := LISTEL := TRUE; GO ROUND;                   %101-05578000
          END ELSE BEGIN DECIMAL:=4095; FLAG(183); GO FL END ;     %111-05579000
     BEGIN MINUSP ~ TRUE; GO TO ROUND; END;         % -                 05580000
     RP:                                                                05581000
     BEGIN IF FEELD THEN BEGIN NCR ~ BACKNCR(NCR);  % )                 05582000
              GO TO ENDER; END;                                         05583000
          IF DECIMAL ! 0 THEN FLAG(32);                                 05584000
           I ~ IF PARENCT = 1 THEN IF SAVLASTLP > 1 THEN 2 ELSE 1       05585000
                ELSE PARENCT;                                           05586000
           WSA[TOTAL]~(J~NAMLIST[I])&(TOTAL+1-J~J.[18:12])[TOLINK]      05587000
              & (IF PARENCT ~ PARENCT-1 = 0 THEN 77 ELSE 0)[TODECIMAL]; 05588000
           IF WSA[J].[1:5]=LPPHRASE AND PARENCT!0 THEN                  05589000
              BEGIN WSA[J].[18:12]~TOTAL-J; WSA[TOTAL].[18:12]~TOTAL-J ;05590000
              END ;                                                     05591000
           NAMLIST[I].[6:12] ~ 0;                                       05592000
           CODE ~ HPHASE;                                               05593000
           GO TO NUL1;                                                  05594000
     END;                                                               05595000
     ; ;                                            % ; LEQ             05596000
     GO TO ROUND;                                   % BLANKS            05597000
     BEGIN SLCNT ~ 1;                               % /                 05598000
SL:        IF CODE=0 THEN IF ASK OR ZF OR DECIMAL!0 THEN                05599000
              BEGIN FLAG(32);  ASK~ZF~BOOLEAN(DECIMAL~0) END ;          05600000
           IF CODE<5 THEN IF T="," THEN GO ROUND1 ELSE GO ROUND ELSE GO 05601000
                                                         ENDER ;        05602000
     END;                                                               05603000
     ;                                              % S                 05604000
     BEGIN IF REPEAT ! 0 THEN FLAG(32);             % T                 05605000
           CODE ~ TPHASE;                                               05606000
           GO TO NOEND;                                                 05607000
     END;                                                               05608000
     ;                                              % U                 05609000
     BEGIN VRB~TRUE; CODE~VPHRASE; WIDTH~-1; GO NOEND END ; % V         05610000
     ;                                              % W                 05611000
     BEGIN IF REPEAT = 0 THEN FLOG(130);            % X                 05612000
           IF STR THEN                                                  05613000
    NEWWD:    WSA[TOTAL] ~ 0 & XPHASE[TOCODE] & REPEAT[TOWIDTH]         05614000
                             & 1[TOREPEAT]                              05615000
                              & REAL(VRB)[42:47:1]                      05616000
           ELSE                                                         05617000
              BEGIN                                                     05618000
                   IF (J~WSA[TOTAL-1]).[42:6]>0 OR (I~J.[1:5])=RTPARN   05619000
                      OR (REPEAT}32 AND I!XPHASE) THEN GO NEWWD ;       05620000
                   IF I=XPHASE AND (I~J.[18:12]+REPEAT){4090 THEN       05621000
                         WSA[TOTAL~TOTAL-1] ~ J & I[TOWIDTH]            05622000
                      ELSE IF REPEAT } 32 THEN GO TO NEWWD              05623000
                 ELSE WSA[TOTAL~TOTAL-1] ~ J & REPEAT[TONUM]            05624000
                                             & 1[TOCNTRL];              05625000
           END;                                                         05626000
           GO TO NUL1;                                                  05627000
     END;                                                               05628000
     ; ;                                            % Y Z               05629000
     GO SL ;                                        % ,                 05630000
     GO TO LP;                                      % %                 05631000
     ; ; ;                                          % ! = ] "           05632000
END OF CASE STATEMENT;                                                  05633000
FLOG(132);   %  ILLEGAL CHARACTER;                                      05634000
GO TO FALL;                                                             05635000
ENDER: IF CODE > 4 THEN                                                 05636000
       BEGIN IF WIDTH=0 THEN FLAG(130) ;                                05637000
             IF CODE=VPHRASE THEN                                       05638000
                   BEGIN                                                05639000
                   IF WIDTH=-1 THEN IF PF THEN FLAG(130)ELSE WIDTH~     05640000
                   DECIMAL~4094 ELSE                                    05641000
                   IF NOT PF THEN DECIMAL~4094 ;                        05642000
                   END                                                  05643000
             ELSE                                                       05644000
             IF CODE > 10 AND CODE ! 15 THEN                            05645000
               IF (DECIMAL = 0 AND NOT ZF) OR NOT PF THEN FLAG(133)     05646000
             ELSE ELSE DECIMAL ~ 0;                                     05647000
             IF REPEAT=0 THEN REPEAT~1 ;                                05648000
             IF WIDTH=-1 THEN WIDTH~0 ;                                 05649000
             WSA[TOTAL] ~ 0 & CODE[TOCODE] & WIDTH[TOWIDTH]             05650000
                            & REPEAT[TOREPEAT] & DECIMAL[TODECIMAL]     05651000
                            & REAL(COMMAS) [44:47:1]                    05652000
                            & REAL(VRB)[42:47:1]                        05653000
                            & REAL(DOLLARS)[45:47:1];                   05654000
       END ELSE IF DECIMAL ! 0 THEN FLAG(32);                           05655000
NUL1:  IF PLUSP THEN FLAG(164);                                         05656000
       IF CODE!VPHRASE THEN                                             05657000
       BEGIN                                                            05658000
       IF DOLLARS AND(CODE < 9 OR CODE > 14) THEN FLAG(166);            05659000
       IF COMMAS AND NOT(CODE = 10 OR CODE = 12 OR CODE = 9)            05660000
          THEN FLAG(165);                                               05661000
       END;                                                             05662000
       VRB~                                                             05663000
       ERRORTOG ~ FEELD ~ PF ~ PLUSP ~ DOLLARS ~ COMMAS ~ STR ~ FALSE;  05664000
       IF CODE = HPHASE THEN STR ~ TRUE;                                05665000
       CODE ~ REPEAT ~ WIDTH ~ 0;                                       05666000
       XTA ~ BLANKS;                                                    05667000
       GO TO FALL;                                                      05668000
NOEND: IF FEELD THEN FLAG(32);                                          05669000
       IF CODE ! TPHASE THEN LISTEL ~ TRUE ELSE REPEAT ~ 1;             05670000
       IF REPEAT=0 AND ZF THEN FLAG(173) ;                              05671000
       FEELD ~ TRUE;                                                    05672000
FALL: IF MINUSP THEN BEGIN FLAG(32); MINUSP ~ FALSE END;                05673000
       ASK~ZF~FALSE ;                                                   05674000
NUL:  DECIMAL ~ 0;                                                      05675000
      IF PARENCT = 0 THEN BEGIN SCN ~ 1; GO TO SEMIC END;               05676000
       IF CODE < 5 THEN                                                 05677000
      IF TOTAL ~ TOTAL+1 > LSTMAX THEN                                  05678000
           BEGIN FLOG(78);TOTAL ~ TOTAL-2; GO TO SEMIC; END;            05679000
GO TO ROUND;                                                            05680000
NOPLACE: IF(DCINPUT OR FREEFTOG) AND (STRINGF OR HF) THEN FLOG(150);    05681000
         IF TSSEDITOG THEN IF (STRINGF OR HF) AND NOT DCINPUT           05682000
         THEN TSSED(XTA,1);                                             05683000
         IF CONTINUE THEN IF READACARD THEN                             05684000
            BEGIN IF LISTOG THEN PRINTCARD; GO TO ROUND; END;           05685000
SCN ~ 0; NEXT ~ SEMI;                                                   05686000
SEMIC:                                                                  05687000
IF SCN = 1 THEN SCAN;                                                   05688000
IF STRINGF THEN FLAG(22);                                               05689000
IF NOT LISTEL THEN WSA[0] ~ 0;                                          05690000
IF PARENCT ! 0 THEN FLAG(IF PARENCT < 0 THEN 9 ELSE 8);                 05691000
IF D ! 0 THEN PRTSAVER(D,TOTAL+1,WSA);                                  05692000
IF DEBUGTOG THEN BEGIN                                                  05693000
     WRITE(LINE,FM) ;                                                   05694000
      FOR I~0 STEP 1 UNTIL TOTAL DO BEGIN                               05695000
    WRITE(LINE,[13]//,I,(J~WSA[I]).[1:5],J.[6:12],J.[18:12],J.[30:12],  05696000
                      J.[41:1],J.[42:4],J.[42:5],J.[44:1],J.[45:1],     05697000
                      J.[46:1],J.[46:2],J.[47:1]) ;                     05698000
    IF J.[1:5]=2 THEN I~I+(J.[6:12]+2).[36:9] ;                         05699000
     END ;                                                              05700000
    WRITE(LINE[DBL]) ;                                                  05701000
    END OF DEBUGSTUFF ;                                                 05702000
END FORMATER;                                                           05703000
                                                                        05704000
PROCEDURE EXECUTABLE;                                                   05705000
BEGIN LABEL XIT; REAL T, J, TS, P;                                      05706000
         IF SPLINK < 0 THEN FLAG(12);                                   05707000
         IF LABL =  BLANKS THEN GO TO XIT;                              05708000
         IF T ~ SEARCH(XTA ~ LABL) = 0 THEN                             05709000
         T ~ ENTER(-0 & LABELID[TOCLASS] & (ADR+1)[TOADDR] &            05710000
            NSEG[TOSEGNO], LABL) ELSE                                   05711000
    BEGIN  IF (P ~ GET(T)).CLASS ! LABELID THEN                         05712000
          BEGIN FLAG(144); GO TO XIT END;                               05713000
         IF P < 0 THEN BEGIN FLAG(20); GO TO XIT END;                   05714000
         TS ~ P.ADDR;                                                   05715000
         WHILE TS ! 0 DO                                                05716000
         BEGIN J ~ GIT(TS); FIXB(TS+10000); TS ~ J END;                 05717000
         PUT(T, P~-P & (ADR+1)[TOADDR] & NSEG[TOSEGNO]);                05718000
         IF (T ~ GET(T+2)).BASE ! 0 THEN                                05719000
         T ~ PRGDESCBLDR(2, T.BASE, (ADR+1).[36:10], NSEG);             05720000
    END;                                                                05721000
         IF XREF THEN ENTERX(LABL,1&LABELID[TOCLASS]);                  05722000
    XIT:                                                                05723000
END EXECUTABLE;                                                         05724000
                                                                        05725000
PROCEDURE IOCOMMAND(N);   VALUE N;   REAL N;                            05726000
COMMENT  N    COMMAND                                                   05727000
         0    READ                                                      05728000
         1    WRITE                                                     05729000
         2    PRINT                                                     05730000
         3    PUNCH                                                     05731000
         4    BACKSPACE                                                 05732000
         7    DATA;                                                     05733000
BEGIN LABEL XIT,SUCH,LISTER,NOFORM,FORMER,WRAP,DAAT,NF;                 05734000
LABEL LISTER1;                                                          05735000
    BOOLEAN SUCHTOG, RDTRIN, FREEREAD;                                  05736000
      BOOLEAN FORMARY, NOFORMT;                                         05737000
    BOOLEAN NAMETOG;                                                    05738000
DEFINE DATATOG = DATASTMTFLAG#;                                         05739000
REAL T, ACCIDENT, EDITCODE;                                             05740000
REAL DATAB;                                                             05741000
PROCEDURE ACTIONLABELS(UNSEEN);   VALUE UNSEEN;   BOOLEAN UNSEEN;       05742000
BEGIN LABEL EOF,ERR,RATA,XIT,ACTION,MULTI;                              05743000
      BOOLEAN BACK,GOTERR,GOTEOF;                                       05744000
IF UNSEEN THEN SCAN;                                                    05745000
EOF:  IF GOTEOF THEN GO TO MULTI;                                       05746000
      IF BACK ~ NAME = "END   " THEN GO TO ACTION;                      05747000
ERR:  IF GOTERR THEN GO TO MULTI;                                       05748000
      IF NAME ! "ERR   " THEN IF GOTEOF THEN                            05749000
      BEGIN MULTI: XTA ~ NAME;  FLOG(137);                              05750000
                   GO TO XIT;                                           05751000
      END ELSE GO TO RATA;                                              05752000
ACTION: SCAN;                                                           05753000
      IF NEXT = EQUAL THEN SCAN ELSE GO TO RATA;                        05754000
      IF NEXT ! NUM THEN GO TO RATA;                                    05755000
      IF XREF THEN ENTERX(NAME,0&LABELID[TOCLASS]);                     05756000
      IF BACK THEN NX1 ~ NAME ELSE NX2 ~ NAME;                          05757000
      SCAN; IF NEXT = RPAREN THEN GO TO XIT;                            05758000
            IF NEXT = COMMA THEN SCAN ELSE GO TO RATA;                  05759000
      IF BACK THEN                                                      05760000
      BEGIN BACK ~ NOT ( GOTEOF ~ TRUE);                                05761000
            GO TO ERR;                                                  05762000
      END;                                                              05763000
      GOTERR ~ TRUE;                                                    05764000
      GO TO EOF;                                                        05765000
RATA: XTA ~ NAME;  FLOG(0);                                             05766000
XIT:                                                                    05767000
END ACTIONLABELS;                                                       05768000
IF DEBUGTOG THEN FLAGROUTINE(" IOCOM","MAND  ",TRUE );                  05769000
EODS~N!7 ;                                                              05770000
C2 ~ IF N = 0 OR N = 7 THEN 1 ELSE 0;                                   05771000
SCAN; IF NEXT = SEMI THEN BEGIN FLOG(0); GO TO XIT END;                 05772000
IF N = 7 THEN                                                           05773000
BEGIN DATATOG ~ TRUE;                                                   05774000
      IF LOGIFTOG THEN FLAG(101);                                       05775000
         LABL ~ BLANKS;                                                 05776000
      IF SPLINK } 0 THEN     %NOT BLOCK DATA STMT                       05777000
      BEGIN                                                             05778000
         IF DATAPRT=0 THEN BEGIN                                        05779000
              DATAPRT~PRTS~PRTS+1; ADJUST;                              05780000
              DATASTRT~(ADR+1)&NSEG[TOSEGNO] END                        05781000
         ELSE FIXB(DATALINK);                                           05782000
         EMITOPDCLIT(DATAPRT); EMITO(LNG);                              05783000
         EMITB(-1, TRUE); DATAB ~ LAX;                                  05784000
      END;                                                              05785000
      GO TO DAAT;                                                       05786000
END;                                                                    05787000
         EXECUTABLE;                                                    05788000
EMITO(MKS);                                                             05789000
IF N = 4 THEN                                                           05790000
BEGIN                                                                   05791000
      INLINEFILE;                                                       05792000
      BEGIN EMITL(0);  EMITL(0);  EMITL(0);  EMITL(0);                  05793000
            EMITL(5);  EMITL(0);  EMITL(0);                             05794000
            EMITV(NEED(".FBINB",INTRFUNID));                            05795000
      END;                                                              05796000
      GO TO XIT;                                                        05797000
END;                                                                    05798000
EDITCODE ~ NX1 ~ NX1 ~ 0;                                               05799000
IF RDTRIN ~                                                             05800000
        N = 0 THEN IF NEXT = LPAREN THEN GO TO SUCH                     05801000
   ELSE EMITDESCLIT(FILECHECK(".5    ",2+17|REAL                   %503-05802000
                                                       (REMOTETOG)))    05803000
ELSE IF N = 1 THEN IF NEXT ! LPAREN THEN FLAG(33)                       05804000
                   ELSE GO TO SUCH                                      05805000
     ELSE IF N = 2 THEN                                            %503-05806000
        EMITDESCLIT(FILECHECK(".6    ",2+17|REAL                   %503-05807000
                                                       (REMOTETOG)))    05808000
                   ELSE EMITDESCLIT(FILECHECK(".PUNCH",0));             05809000
IF RDTRIN THEN EMITL(0) ELSE EMITPAIR(1,SSN);                           05810000
GO TO FORMER;                                                           05811000
SUCH:    SCAN;  RANDOMTOG~SUCHTOG~TRUE;  INLINEFILE ;                   05812000
         RANDOMTOG~FREEREAD~FALSE ;                                     05813000
      IF NEXT = EQUAL THEN   %  RANDOM KEY                              05814000
      BEGIN SCAN;                                                       05815000
            IF EXPR(TRUE) > REALTYPE THEN FLAG(102);                    05816000
            IF RDTRIN THEN EMITPAIR(1,ADD);                             05817000
      END ELSE IF RDTRIN THEN EMITL(0) ELSE EMITPAIR(1,SSN);            05818000
      IF NEXT = RPAREN THEN GO TO NF;                                   05819000
      IF NEXT ! COMMA THEN BEGIN FLOG(114); GO TO XIT END;              05820000
      SCAN;                                                             05821000
      IF NEXT = ID THEN                                                 05822000
            IF NAME = "ERR   " OR NAME = "END   " THEN                  05823000
            BEGIN ACTIONLABELS(FALSE);                                  05824000
              NF: IF RDTRIN THEN EMITL(0) ELSE EMITPAIR(1,SSN);         05825000
                  EMITL(0);                                             05826000
                  NOFORMT ~ TRUE;                                       05827000
                  SCAN;  GO TO NOFORM;                                  05828000
            END;                                                        05829000
FORMER: IF ADR } 4085 THEN                                              05830000
    BEGIN ADR ~ ADR+1; SEGOVF END;                                      05831000
    IF NEXT = NUM THEN     % FORMAT NUMBER                              05832000
    BEGIN EDITCODE ~ 1;                                                 05833000
          IF TEST ~ LBLSHFT(NAME) { 0 THEN                              05834000
          BEGIN FLAG(135); GO TO LISTER END;                            05835000
          IF I ~ SEARCH(TEST) = 0 THEN  %  NEVER SEEN                   05836000
          OFLOWHANGERS(I~ENTER(0&FORMATID[TOCLASS], TEST)) ELSE         05837000
          IF GET(I).CLASS ! FORMATID THEN                               05838000
          BEGIN FLAG(143); GO TO LISTER END;                            05839000
          IF XREF THEN ENTERX(TEST,0&FORMATID[TOCLASS]);                05840000
          IF GET(I).ADDR = 0 THEN                                       05841000
          BEGIN EMITLINK((INFC ~ GET(I + 2)).BASE);                     05842000
                PUT(I + 2,INFC&ADR[TOBASE]);                            05843000
                EMITL(0); EMITL(0); EMITO(NOP);                         05844000
          END ELSE                                                      05845000
          BEGIN EMITL(GET(I+ 2).BASE);                                  05846000
                EMITPAIR(GET(I).ADDR,LOD);                              05847000
          END;                                                          05848000
          GO TO LISTER;                                                 05849000
END ELSE IF RDTRIN THEN IF(FREEREAD := NEXT=SLASH) THEN GO TO LISTER    05850000
ELSE BEGIN IF NEXT NEQ ID THEN BEGIN FLOG(116);GO TO XIT; END;END       05851000
 ELSE IF NEXT NEQ ID THEN                                               05852000
  BEGIN IF NEXT = STAR THEN                                             05853000
        BEGIN NAMEDESC := TRUE; GLOBALNAME := TRUE;                     05854000
              TV := ENTER(0&LISTSID[TOCLASS],LISTID:=LISTID+1);         05855000
              SCAN;                                                     05856000
        END;                                                            05857000
        IF NEXT = LPAREN THEN                                           05858000
        BEGIN SCAN; IF EXPR(TRUE) GTR REALTYPE THEN FLAG(120) ;         05859000
              SCAN; END ELSE EMITL(0);                                  05860000
        IF GLOBALNAME AND (FREEREAD := NEXT = SLASH) OR FREEREAD THEN   05861000
             GO TO LISTER ELSE BEGIN FLOG(110); GO TO XIT; END;         05862000
  END;                                                                  05863000
      GETALL(I ~ FNEXT,INFA,INFB,INFC);                                 05864000
      IF T ~ INFA.CLASS = ARRAYID THEN  %  FORMAT ARRAY                 05865000
      BEGIN EDITCODE ~ 1;                                               05866000
         FORMARY ~ TRUE;                                                05867000
         T ~ EXPR(FALSE);                                               05868000
         ADR ~ ADR-1; % ELIMINATE XCH EMITTED BY EXPR                   05869000
         IF EXPRESULT ! ARRAYID THEN FLOG(116);                         05870000
         GO TO LISTER1; % SCAN ALREADY DONE IN EXPR                     05871000
      END ELSE                                                          05872000
      IF T = NAMELIST THEN                                              05873000
       BEGIN NAMETOG := TRUE;                                           05874000
        IF INFA.ADDR = 0 THEN   %  REFERENCED, NOT DEF                  05875000
        BEGIN EMITLINK(INFC.BASE);                                      05876000
              PUT(I+ 2,(INFC ~ INFC&ADR[TOBASE]));                      05877000
              EMITL(0); EMITL(0); EMITO(NOP);                           05878000
        END ELSE                                                        05879000
        BEGIN EMITL(INFC.BASE);                                         05880000
              EMITPAIR(INFA.ADDR,LOD);                                  05881000
        END                                                             05882000
       END                                                              05883000
      ELSE IF T = UNKNOWN THEN   %  ASSUME NAMELIST                     05884000
      BEGIN PUT(I,(INFA ~ INFA&NAMELIST[TOCLASS]));                     05885000
            NAMETOG := TRUE;                                            05886000
            OFLOWHANGERS(I);                                            05887000
            EMITLINK(0);  PUT(I + 2,INFC&ADR[TOBASE]);                  05888000
            EMITL(0); EMITL(0); EMITO(NOP);                             05889000
      END ELSE BEGIN XTA ~ INFB; FLOG(116); GO TO XIT END;              05890000
      SCAN;                                                             05891000
      IF NEXT = COMMA THEN ACTIONLABELS(TRUE);                          05892000
      IF SUCHTOG THEN                                                   05893000
         IF NEXT ! RPAREN THEN FLOG(108) ELSE SCAN;                     05894000
      IF NEXT ! SEMI THEN BEGIN FLOG(118); GO TO XIT END;               05895000
      EMITL(0);   EDITCODE ~ 4;   EMITOPDCLIT(7);   EMITO(FTC);         05896000
      GO TO WRAP;                                                       05897000
LISTER:  SCAN;                                                          05898000
         IF FREEREAD THEN IF NOT RDTRIN THEN                            05899000
         BEGIN IF NEXT ! SLASH THEN EMITO(SSN) ELSE SCAN;               05900000
               IF NEXT = LPAREN THEN                                    05901000
         BEGIN SCAN; IF EXPR(TRUE) > REALTYPE THEN FLAG(120);SCAN       05902000
               END ELSE EMITL(0);                                       05903000
         END;                                                           05904000
LISTER1:                                                                05905000
      IF SUCHTOG THEN                                                   05906000
      BEGIN IF NEXT = COMMA THEN ACTIONLABELS(TRUE);                    05907000
      IF NEXT = RPAREN THEN SCAN ELSE BEGIN FLOG(108); GO TO XIT END;   05908000
      END ELSE IF NEXT=COMMA THEN SCAN ELSE IF RDTRIN THEN              05909000
         IF NEXT!SEMI THEN FLOG(114);                                   05910000
NOFORM: IF NEXT=SEMI THEN                                               05911000
      BEGIN IF FREEREAD THEN FLOG(061) ELSE EMITL(0); GO TO WRAP END;   05912000
      IF (NEXT NEQ LPAREN) AND (NEXT NEQ ID) AND (NEXT NEQ STAR) THEN   05913000
                 GO TO XIT;                                             05914000
      EDITCODE ~ EDITCODE + 2;                                          05915000
DAAT: EMITB(-1,FALSE);  LADR1 ~ LAX;  ADJUST;  DESCREQ ~ TRUE;          05916000
    IF ADR } 4085 THEN                                                  05917000
      BEGIN ADR ~ ADR+1; SEGOVF; ADJUST END;                            05918000
      ACCIDENT ~ PRGDESCBLDR(0,0,ADR.[36:10] + 1,NSEG);                 05919000
      EMITOPDCLIT(19);   EMITO(GFW);                                    05920000
      LISTART ~ ADR&NSEG[TOSEGNO];    ADJUST;                           05921000
      LA ~ 0;   IOLIST(LA);                                             05922000
      EMITL(1);   EMITO(CHS);   EMITL(19);   EMITO(STD);                05923000
      EMITDESCLIT(19);   EMITO(RTS);                                     5924000
      FIXB(LADR1);   DESCREQ ~ FALSE;                                   05925000
      IF DATATOG THEN                                                   05926000
      BEGIN DATASET;                                                    05927000
            IF NEXT = SLASH THEN SCAN ELSE                              05928000
            BEGIN FLOG(110); GO TO XIT END;                             05929000
      IF LSTA = 0 THEN BEGIN BUMPPRT; LSTA~PRTS END;                    05930000
            IF (LSTMAX - LSTI) { LSTS THEN                              05931000
            BEGIN WRITEDATA(LSTI,NXAVIL ~ NXAVIL + 1,LSTP);             05932000
                  LSTA ~ PRGDESCBLDR(1,LSTA,0,NXAVIL);                  05933000
         LSTI ~ 0; BUMPPRT; LSTA~PRTS;                                  05934000
            END;                                                        05935000
            MOVEW(LSTT,LSTP[LSTI],(LSTS ~ LSTS + 1).[36:6],LSTS);       05936000
            EMITO(MKS);   EMITL(LSTI);   EMITPAIR(LSTA,LOD);            05937000
            LSTI ~ LSTI + LSTS;                                         05938000
            EMITPAIR(ACCIDENT,LOD);  EMITOPDCLIT(7);  EMITO(FTF);       05939000
            EMITL(6);  EMITL(0);  EMITL(0);                             05940000
            EMITV(NEED(".FBINB",INTRFUNID));                            05941000
            IF NEXT = COMMA THEN                                        05942000
            BEGIN SCAN; GO TO DAAT END;                                 05943000
            IF SPLINK } 0 THEN BEGIN                                    05944000
            EMITB(-1,FALSE); DATALINK~LAX;                              05945000
                  FIXB(DATAB) END;                                      05946000
            GO TO XIT;                                                  05947000
      END;                                                              05948000
      EMITPAIR(ACCIDENT,LOD);  EMITOPDCLIT(7);  EMITO(FTF);             05949000
WRAP: IF NOT FREEREAD AND NOT NAMETOG THEN EMITL(EDITCODE);             05950000
IF RDTRIN THEN                                                          05951000
BEGIN IF NX1 = 0 THEN EMITL(0) ELSE EMITLABELDESC(NX1);                 05952000
      IF NX2 = 0 THEN EMITL(0) ELSE EMITLABELDESC(NX2);                 05953000
      IF FREEREAD THEN EMITV(NEED(".FREFR", INTRFUNID))                 05954000
        ELSE IF NAMETOG THEN EMITV(NEED(".FINAM",INTRFUNID))            05955000
        ELSE IF FORMARY THEN EMITV(NEED(".FTINT",INTRFUNID))            05956000
        ELSE IF NOFORMT THEN EMITV(NEED(".FBINB",INTRFUNID))            05957000
              ELSE EMITV(NEED(".FTNIN",INTRFUNID));                     05958000
END ELSE                                                                05959000
IF FREEREAD THEN                                                        05960000
    BEGIN                                                               05961000
    IF NAMEDESC THEN                                                    05962000
         BEGIN                                                          05963000
              PRTSAVER(TV,NAMEIND+1,NAMLIST);                           05964000
              EMITL(GET(TV+2).BASE);                                    05965000
              EMITPAIR(GET(TV).ADDR,LOD);                               05966000
              IF NAMLIST[0] = 0 THEN EMITL(0)                           05967000
              ELSE EMITPAIR(GET(GLOBALSEARCH(".SUBAR")).ADDR,LOD);      05968000
              NAMLIST[0] := NAMEIND := 0;                               05969000
         END ELSE BEGIN EMITL(0);EMITL(0);EMITL(0);END;                 05970000
     EMITV(NEED(".FREWR",INTRFUNID))                                    05971000
     END ELSE IF NAMETOG THEN EMITV(NEED(".FONAM",INTRFUNID))           05972000
              ELSE IF FORMARY THEN EMITV(NEED(".FTOUT",INTRFUNID))      05973000
                   ELSE BEGIN                                           05974000
                        IF NX1=0 THEN EMITL(0) ELSE EMITLABELDESC(NX1); 05975000
                        IF NX2=0 THEN EMITL(0) ELSE EMITLABELDESC(NX2); 05976000
                   IF NOFORMT THEN EMITV(NEED(".FBINB",INTRFUNID)) ELSE 05977000
                        EMITV(NEED(".FTNOU",INTRFUNID));                05978000
                        END;                                            05979000
XIT:                                                                    05980000
    IF NAMEDESC THEN IF RDTRIN THEN FLAG(159)                           05981000
                    ELSE IF NOT FREEREAD THEN FLAG(160);                05982000
    DATATOG := FALSE;  NAMEDESC := FALSE; GLOBALNAME := FALSE;          05983000
IF DEBUGTOG THEN FLAGROUTINE(" IOCOM","MAND  ",FALSE);                  05984000
END IOCOMMAND;                                                          05985000
PROCEDURE STMTFUN(LINK); VALUE LINK; REAL LINK;                         05986000
BEGIN                                                                   05987000
         DEFINE PARAM = LSTT#;                                          05988000
         REAL SAVEBRAD, I;                                              05989000
         REAL INFA, INFC, NPARMS, TYPE, PARMLINK, BEGINSUB, RETURN;     05990000
         LABEL XIT,TIX ;                                                05991000
         IF SPLINK < 0 THEN FLAG(12);                                   05992000
         LABL ~ BLANKS;                                                 05993000
         FILETOG ~ TRUE; % PREVENTS SCANNER FROM ENTERING IDS IN INFO   05994000
         IF XREF THEN ENTERX(GET(LINK+1),0&STMTFUNID[TOCLASS]           05995000
              &(GET(LINK))[21:21:3]);                                   05996000
         DO                                                             05997000
    BEGIN                                                               05998000
         SCAN;                                                          05999000
         IF NEXT ! ID THEN BEGIN FLOG(107); GO TO XIT END;              06000000
         PARAM[NPARMS~NPARMS+1] ~ NAME;                                 06001000
         SCAN;                                                          06002000
    END  UNTIL NEXT ! COMMA;                                            06003000
         IF NEXT ! RPAREN THEN FLOG(108) ELSE SCAN;                     06004000
         IF NEXT ! EQUAL THEN BEGIN FLOG(104); GO TO XIT END;           06005000
         EMITB(-1,FALSE); SAVEBRAD ~ LAX; % BRANCH AROUND ST FUN        06006000
         ADJUST;                                                        06007000
         BEGINSUB ~ ADR+1;                                              06008000
         BUMPLOCALS; EMITPAIR(RETURN~LOCALS+1536,STD);                  06009000
         FOR I ~ NPARMS STEP -1 UNTIL 1 DO                              06010000
    BEGIN                                                               06011000
         IF T ~ SEARCH(PARAM[I]) ! 0 THEN                               06012000
              TYPE ~ GET(T).SUBCLASS ELSE                               06013000
              IF T~PARAM[I].[12:6] < "I" OR T > "N" THEN                06014000
              TYPE ~ REALTYPE ELSE TYPE ~ INTYPE;                       06015000
         EMITSTORE(          ENTER(0&VARID[TOCLASS]&1[TOTYPE]           06016000
              &TYPE[TOSUBCL], PARAM[I]), TYPE);                         06017000
         IF XREF THEN ENTERX(NAME,0&VARID[TOCLASS]&TYPE[TOSUBCL]);      06018000
    END;                                                                06019000
         PARMLINK ~ NEXTINFO-3;                                         06020000
         GETALL(LINK, INFA, XTA, INFC);                                 06021000
         FILETOG ~ FALSE;                                               06022000
         SCAN;                                                          06023000
         IF (TYPE~(INFA~GET(LINK)).SUBCLASS)=LOGTYPE OR TYPE=COMPTYPE OR06024000
            (I~EXPR(TRUE))=LOGTYPE OR I=COMPTYPE THEN                   06025000
              BEGIN IF I!TYPE THEN FLAG(139); GO TIX END ;              06026000
         IF TYPE=REALTYPE OR TYPE=INTYPE THEN                           06027000
              BEGIN                                                     06028000
              IF I=DOUBTYPE THEN BEGIN EMITO(XCH); EMITO(DEL) END;      06029000
              IF TYPE=INTYPE THEN IF I!INTYPE THEN EMITPAIR(1,IDV) ;    06030000
              GO TIX ;                                                  06031000
              END ;                                                     06032000
         IF I!DOUBTYPE THEN EMITPAIR(0,XCH) ;                           06033000
TIX:                                                                    06034000
         EMITOPDCLIT(RETURN) ;                                          06035000
         EMITO(GFW);                                                    06036000
         FIXB(SAVEBRAD);                                                06037000
         IF INFA.CLASS ! UNKNOWN THEN FLAG(140);                        06038000
         PUT(LINK, -INFA & 1[TOTYPE] & NSEG[TOSEGNO]                    06039000
         & STMTFUNID[TOCLASS] & BEGINSUB[TOADDR]);                      06040000
         PUT(LINK+2, -(0 & NPARMS[TONEXTRA] & ADR[TOBASE]               06041000
              & PARMLINK[36:36:12]));                                   06042000
         PARMLINK ~ PARMLINK+4;                                         06043000
         FOR I ~ 1 STEP 1 UNTIL NPARMS DO                               06044000
              PUT(PARMLINK ~ PARMLINK-3, "......");                     06045000
    XIT:                                                                06046000
         FILETOG ~ FALSE;                                               06047000
END STMTFUN;                                                            06048000
PROCEDURE ASSIGNMENT;                                                   06049000
BEGIN                                                                   06050000
         LABEL XIT;                                                     06051000
BOOLEAN CHCK;                                                           06052000
BOOLEAN I;                                                              06053000
IF DEBUGTOG THEN FLAGROUTINE(" ASSIG","NMENT ",TRUE ) ;                 06054000
         FX1 ~ FNEXT;                                                   06055000
         SCAN;                                                          06056000
         IF NEXT = LPAREN THEN                                          06057000
    BEGIN                                                               06058000
CHCK~TRUE;                                                              06059000
         IF GET(FX1).CLASS = UNKNOWN THEN                               06060000
         IF EODS THEN                                                   06061000
            BEGIN  XTA ~ GET(FX1+1);  FLOG(035) ;                       06062000
            PUT(FX1,GET(FX1) & ARRAYID[TOCLASS]) ;                      06063000
            PUT(FX1+2,GET(FX1+2) & 1[TONEXTRA]) ;                       06064000
            END                                                         06065000
         ELSE BEGIN STMTFUN(FX1);  GO TO XIT END ;                      06066000
         IF XREF THEN ENTERX(GET(FX1+1),1&GET(FX1) [15:15:9]);          06067000
         EODS ~ TRUE ;                                                  06068000
         EXECUTABLE;                                                    06069000
         SCAN;                                                          06070000
         I ~ SUBSCRIPTS(FX1,2);                                         06071000
         SCAN;                                                          06072000
    END ELSE                                                            06073000
    BEGIN                                                               06074000
         EODS~TRUE ;                                                    06075000
         EXECUTABLE;                                                    06076000
         IF T ~ GET(FX1).CLASS = ARRAYID THEN                           06077000
         BEGIN XTA ~ GET(FX1+1); FLAG(74) END;                          06078000
         MOVEW(ACCUM[1],HOLDID[0],0,3);                                 06079000
         IF XREF THEN IF HOLDID[0].[12:12] ! "DO" THEN                  06080000
           ENTERX(GET(FX1+1),1&GET(FX1)[21:21:3]&VARID[TOCLASS]);       06081000
    END;                                                                06082000
         IF NEXT ! EQUAL THEN BEGIN FLAG(104); GO TO XIT END;           06083000
         SCAN;                                                          06084000
         IF NEXT=SEMI OR NEXT=COMMA THEN BEGIN FLOG(0); GO TO XIT; END; 06085000
         FX2 ~ EXPR(TRUE);                                              06086000
         IF NEXT NEQ COMMA THEN IF HOLDID[0] = "DO" THEN IF XREF THEN   06087000
           ENTERX(HOLDID[0] ,1&GET(FX1)[21:21:3]&VARID[TOCLASS]);       06088000
         IF NEXT = COMMA THEN IF CHCK THEN FLOG(56) ELSE                06089000
         IF HOLDID[0].[12:12] ! "DO" THEN FLOG(56) ELSE                 06090000
    BEGIN                                                               06091000
         IF LOGIFTOG THEN FLAG(101);                                    06092000
         IF FX2 > REALTYPE THEN FLAG(102);                              06093000
         IF DT ~ DT+1 > MAXDOS THEN BEGIN DT ~ 1; FLAG(138) END;        06094000
         EMITN(FX1~ CHECKDO);                                           06095000
         EMITO(STD);                                                    06096000
          SCAN;                                                         06097000
          IF NEXT=SEMI THEN BEGIN FLAG(36); GO TO XIT END;              06098000
          IF (ACCUM[0] = ",     " OR ACCUM[0] = ";     ") AND           06099000
          GLOBALNEXT=NUM AND ABS(FNEXT) > 1023 THEN                     06100000
              BEGIN                                                     06101000
              IF EXPR(TRUE) > REALTYPE THEN FLAG(102);                  06102000
              IDINFO:=REALID;FNEXT:=ENTER(IDINFO,"2FNV00"&DT[36:36:12]);06103000
              EMITN(FNEXT:=GETSPACE(FNEXT)); EMITO(STD);                06104000
              EMITB(-1,FALSE); LADR1:=LAX; ADJUST;                      06105000
              LADR2 ~ (ADR+1) & NSEG[TOSEGNO]; EMITV(FNEXT);            06106000
              END                                                       06107000
         ELSE BEGIN                                                     06108000
              EMITB(-1,FALSE); LADR1:=LAX; ADJUST;                      06109000
              LADR2:=(ADR+1)&NSEG[TOSEGNO];                             06110000
              IF EXPR(TRUE) > REALTYPE THEN FLAG(102) ;                 06111000
              END ;                                                     06112000
         EMITO(GRTR);                                                   06113000
         EMITB(-1, TRUE);                                               06114000
         LADR3 ~ LAX;                                                   06115000
         EMITB(-1, FALSE);                                              06116000
         ADJUST;                                                        06117000
         DOTEST[DT] ~ (ADR+1) & LAX[TOADDR] & NSEG[TOSEGNO];            06118000
         IF NEXT ! COMMA THEN EMITL(1) ELSE                             06119000
    BEGIN                                                               06120000
         SCAN;                                                          06121000
         IF NEXT=SEMI THEN BEGIN FLAG(36);  GO TO XIT END ;             06122000
         IF EXPR(TRUE) > REALTYPE THEN FLAG(102);                       06123000
    END;                                                                06124000
         EMITV(FX1);                                                    06125000
         EMITO(ADD);                                                    06126000
         EMITN(FX1);                                                    06127000
         EMITO(STN);                                                    06128000
         EMITB(LADR2, FALSE);                                           06129000
         FIXB(LADR1);                                                   06130000
         FIXB(LADR3);                                                   06131000
    END ELSE EMITSTORE(FX1, FX2);                                       06132000
    XIT:                                                                06133000
IF DEBUGTOG THEN FLAGROUTINE(" ASSIG","NMENT ",FALSE ) ;                06134000
END ASSIGNMENT;                                                         06135000
BOOLEAN PROCEDURE RINGCHECK;                                            06136000
COMMENT  THIS PROCEDURE PREVENTS THE POSSIBILITY OF DELINKING A         06137000
           HEADER FROM THE HEADER RING;                                 06138000
    BEGIN                                                               06139000
         INTEGER I;                                                     06140000
         I~A;                                                           06141000
         DO                                                             06142000
         IF I ~ GETC(I).ADDR = ROOT THEN RINGCHECK ~ TRUE               06143000
         UNTIL I = A;                                                   06144000
    END RINGCHECK;                                                      06145000
PROCEDURE SETLINK(INFADDR); VALUE INFADDR; INTEGER INFADDR;             06146000
COMMENT  THIS PROCEDURE LINKS AN ELEMENT TO ITS PREVIOUS HEADER;        06147000
BEGIN                                                                   06148000
    INTEGER LAST,I; REAL COML; LABEL XIT;                               06149000
XIT:                                                                    06150000
    LAST ~(GETC(INFADDR).LASTC)-1;                                      06151000
    FOR I ~ INFADDR+2 STEP 1 UNTIL LAST                                 06152000
    DO BEGIN IF GETC(I).CLASS = ENDCOM THEN I~GETC(I).LINK;             06153000
             IF FX1 = (COML~GETC(I)).LINK THEN                          06154000
                   IF INFADDR~COML.LASTC=A THEN COM[PWI].LASTC~ROOT     06155000
                   ELSE GO XIT ;                                        06156000
       END;                                                             06157000
END SETLINK;                                                            06158000
PROCEDURE DIMENSION;                                                    06159000
BEGIN                                                                   06160000
    LABEL L, LOOP, ERROR ;                                              06161000
    BOOLEAN DOUBLED, SINGLETOG;                                    %109-06162000
IF DEBUGTOG THEN FLAGROUTINE(" DIMEN","SION  ",TRUE ) ;                 06163000
         IF LOGIFTOG THEN FLAG(101);                                    06164000
         LABL ~ BLANKS;                                                 06165000
         IF NEXT=STAR THEN IF TYPE!DOUBTYPE THEN                        06166000
              BEGIN                                                     06167000
              SCAN ;                                                    06168000
              IF NEXT=NUM AND NUMTYPE=INTYPE THEN                       06169000
                   BEGIN                                                06170000
                   IF FNEXT=4 THEN                                      06171000
                        BEGIN                                           06172000
                        SINGLETOG ~ TRUE;                          %109-06173000
                        IF TYPE=COMPTYPE THEN FLAG(176);  GO L ;        06174000
                        END ;                                           06175000
                   IF FNEXT=8 THEN                                      06176000
                        BEGIN                                           06177000
                        IF TYPE=REALTYPE THEN TYPE~DOUBTYPE             06178000
                        ELSE IF TYPE!COMPTYPE THEN FLAG(177) ;          06179000
                        GO L ;                                          06180000
                        END ;                                           06181000
                   END ;                                                06182000
              FLAG(IF TYPE=REALTYPE THEN 178                            06183000
                   ELSE 177-REAL(TYPE=COMPTYPE)) ;                      06184000
L:            NCR~REAL(NCR.[30:3]!0)+3"677777"+NCR;  SCN~1;  SCAN ;     06185000
              END ;                                                     06186000
     LOOP:     DOUBLED~FALSE;                                           06187000
         IF NEXT ! ID THEN  BEGIN FLOG(105); GO TO ERROR END;           06188000
         FX1 ~ IF SINGLETOG THEN -FNEXT ELSE FNEXT;                %109-06189000
         IF TYPE } DOUBTYPE THEN   %  FIX ARRAY TYPE OFR                06190000
          PUT(FX1,GET(FX1)&TYPE[TOSUBCL]); % BOUNDS ROUTINE             06191000
         IF XREF THEN BEGIN INFA ~ 0&GET(FX1)[15:15:9];                 06192000
                            IF TYPE>0 THEN INFA.SUBCLASS~TYPE;          06193000
                      END;                                              06194000
         XTA ~ INFB ~ NAME;                                             06195000
         SCAN;                                                          06196000
         IF  XREF THEN                                                  06197000
         BEGIN IF INFA.CLASS = UNKNOWN THEN                             06198000
                  INFA.CLASS~IF NEXT=LPAREN THEN ARRAYID ELSE VARID;    06199000
               ENTERX(INFB,INFA);                                       06200000
         END;                                                           06201000
         IF NEXT=LPAREN THEN BEGIN SCAN; DOUBLED~BOUNDS(FX1) END ELSE   06202000
         IF TYPE = -1 THEN FLOG(103);                                   06203000
         GETALL(FX1, INFA, XTA, INFC);                                  06204000
         IF TYPE > 0 THEN                                               06205000
         IF BOOLEAN(INFA.TYPEFIXED) THEN FLAG(31) ELSE                  06206000
    BEGIN                                                               06207000
         IF TYPE > LOGTYPE THEN                                         06208000
         IF GET(FX1+2) <0 THEN                                          06209000
         BEGIN                                                          06210000
         IF NOT DOUBLED AND INFA.CLASS=1 THEN                           06211000
              BEGIN                                                     06212000
              BUMPLOCALS;                                               06213000
              LENGTH~LOCALS + 1536;                                     06214000
              PUT(FX1+2,INFC & LENGTH[TOSIZE]);                         06215000
              END                                                       06216000
         END ELSE IF NOT DOUBLED THEN                                   06217000
              BEGIN IF INFC.SIZE > 16383 THEN FLAG(99);                 06218000
              PUT(FX1+2,INFC & (2 | INFC.SIZE)[TOSIZE]);                06219000
              END;                                                      06220000
         PUT (FX1,INFA & 1[TOTYPE] & TYPE[TOSUBCL]);                    06221000
    END;                                                                06222000
         IF INFA < 0 THEN FLAG(39) ELSE                                 06223000
         IF TYPE = -2 THEN                                              06224000
    BEGIN                                                               06225000
         BAPC(INFA&FX1[TOLINK]&1[TOCE]&ROOT[TOLASTC]);                  06226000
         IF BOOLEAN(INFA.CE) THEN FLAG(2);                              06227000
         IF BOOLEAN(INFA.EQ) THEN                                       06228000
    BEGIN                                                               06229000
         COM[NEXTCOM.IR,NEXTCOM.IC].LASTC ~ A ~ INFA.ADDR;              06230000
         B~GETC(ROOT).ADDR ;                                            06231000
         SETLINK(A);                                                    06232000
         IF NOT RINGCHECK THEN                                          06233000
    BEGIN                                                               06234000
         COM[PWROOT].ADDR~GETC(A).ADDR ;                                06235000
         PUTC(A,GETC(A)&B[TOADDR]&7[TOSUBCL]) ;                         06236000
    END                                                                 06237000
    END  ELSE                                                           06238000
         PUT(FX1, INFA & 1[TOCE] & ROOT[TOADDR]);                       06239000
         IF BOOLEAN(INFA.FORMAL) THEN FLAG(10);                         06240000
    END;                                                                06241000
         IF ERRORTOG THEN                                               06242000
    ERROR:                                                              06243000
         WHILE NEXT ! COMMA AND NEXT ! SEMI AND NEXT ! SLASH DO SCAN;   06244000
         IF NEXT = COMMA THEN BEGIN SCAN; GO TO LOOP END;               06245000
IF DEBUGTOG THEN FLAGROUTINE(" DIMEN","SION  ",FALSE );                 06246000
END DIMENSION;                                                          06247000
PROCEDURE FORMALPP(PARMSREQ, CLASS); VALUE PARMSREQ, CLASS;             06248000
         BOOLEAN PARMSREQ; REAL CLASS;                                  06249000
BEGIN                                                                   06250000
    LABEL LOOP, XIT;                                                    06251000
IF DEBUGTOG THEN FLAGROUTINE("  FORM","ALPP  ",TRUE ) ;                 06252000
         PARMS ~ 0;                                                     06253000
         SCAN;                                                          06254000
         IF NEXT ! ID THEN BEGIN FLOG(105); GO TO XIT END;              06255000
         IF CLASS = FUNID THEN                                          06256000
         IF FUNVAR = 0 THEN                                             06257000
         BEGIN                                                          06258000
         IF TYPE > 0 THEN                                               06259000
         IF FUNVAR ~ GLOBALSEARCH(NAME) ! 0 THEN                        06260000
         IF BOOLEAN((T ~ GET(FUNVAR)).TYPEFIXED) AND TYPE ! T.SUBCLASS  06261000
              THEN FLAG(31);                                            06262000
         PUT(FUNVAR ~ FNEXT,GET(FNEXT) & VARID[TOCLASS]);               06263000
         END;                                                           06264000
         FNEW ~ NEED(NNEW ~ NAME, CLASS);                               06265000
         ENTERX(NAME,IF CLASS = FUNID THEN                              06266000
              1&GET(FNEW)[15:15:9] ELSE 1&GET(FNEW)[15:15:5]);          06267000
         SCAN;                                                          06268000
         IF NEXT ! LPAREN THEN                                          06269000
              IF PARMSREQ THEN FLOG(106) ELSE ELSE                      06270000
    BEGIN                                                               06271000
    LOOP:                                                               06272000
         SCAN;                                                          06273000
         IF NEXT = ID THEN PARMLINK[PARMS ~ PARMS+1] ~ FNEXT ELSE       06274000
         IF NEXT=STAR AND CLASS!FUNID THEN PARMLINK[PARMS~PARMS+1]~0ELSE06275000
             FLOG(107);                                                 06276000
         IF XREF THEN ENTERX(NAME,IF NEXT = STAR THEN 0 ELSE            06277000
                 0&GET(FNEXT)[15:15:9]);                                06278000
         SCAN;                                                          06279000
         IF NEXT = COMMA THEN GO TO LOOP;                               06280000
         IF NEXT ! RPAREN THEN FLOG(108);                               06281000
         SCAN;                                                          06282000
    END;                                                                06283000
         IF NOT ERRORTOG THEN DECLAREPARMS(FNEW);                       06284000
    XIT:                                                                06285000
IF DEBUGTOG THEN FLAGROUTINE("  FORM","ALPP  ",FALSE) ;                 06286000
END FORMALPP;                                                           06287000
                                                                        06288000
PROCEDURE ENDS; FORWARD;                                                06289000
                                                                        06290000
PROCEDURE FUNCTION ;                                                    06291000
BEGIN                                                                   06292000
         REAL A,B,C,I;  LABEL FOUND ;                                   06293000
         IF SPLINK NEQ 0 THEN BEGIN FLAG(5); ENDS; SEGMENTSTART; END;   06294000
         LABL ~ BLANKS;                                                 06295000
         FORMALPP(TRUE, FUNID);                                         06296000
         GETALL(FNEW, INFA, INFB, INFC);                                06297000
         B~NUMINTM1 ;                                                   06298000
         WHILE A+1<B DO                                                 06299000
              BEGIN                                                     06300000
              IF C~INT[I~REAL(BOOLEAN(A+B) AND BOOLEAN(1022))]=INFB     06301000
              THEN GO FOUND ;                                           06302000
              IF INFB<C THEN B~I.[36:11] ELSE A~I.[36:11] ;             06303000
              END ;                                                     06304000
         IF INFB=INT[I~(A+B)|2-I] THEN GO FOUND ;                       06305000
         IF FALSE THEN                                                  06306000
FOUND:   IF BOOLEAN(INT[I+1].INTSEEN) THEN BEGIN XTA~INFB; FLAG(167)END;06307000
         IF TYPE<0 THEN TYPE~INFA.SUBCLASS&1[2:47:1] ;                  06308000
         PUT(SPLINK ~ FNEW, INFA & 1[TOTYPE] & TYPE[TOSUBCL]);          06309000
         PUT(FUNVAR, GET(FUNVAR) & VARID[TOCLASS] & 1[TOTYPE] &         06310000
              TYPE[TOSUBCL]);                                           06311000
END FUNCTION;                                                           06312000
                                                                        06313000
PROCEDURE STATEMENT; FORWARD;                                           06314000
PROCEDURE ASSIGN;                                                       06315000
BEGIN                                                                   06316000
         LABEL XIT;                                                     06317000
         EODS~TRUE ;                                                    06318000
         EXECUTABLE;                                                    06319000
         SCAN;                                                          06320000
         IF NEXT ! NUM THEN BEGIN FLOG(109); GO TO XIT END;             06321000
         IF XREF THEN ENTERX(FNEXT,0&LABELID[TOCLASS]);                 06322000
         EMITNUM(FNEXT);                                                06323000
         SCAN;                                                          06324000
         IF NEXT ! ID THEN BEGIN FLOG(105); GO TO XIT END;              06325000
         IF XREF THEN ENTERX(XTA,1&GET(FNEXT)[15:15:9]);                06326000
         EMITN(FNEXT);                                                  06327000
         EMITO(STD);                                                    06328000
         SCAN;                                                          06329000
    XIT:                                                                06330000
END ASSIGN;                                                             06331000
PROCEDURE BLOCKDATA;                                                    06332000
BEGIN                                                                   06333000
         IF SPLINK NEQ 0 THEN BEGIN FLAG(5); ENDS; SEGMENTSTART; END;   06334000
         LABL ~ BLANKS;                                                 06335000
         SCAN;                                                          06336000
         SPLINK ~ -1;                                                   06337000
END BLOCKDATA;                                                          06338000
PROCEDURE CALL;                                                         06339000
BEGIN                                                                   06340000
         EODS~TRUE ;                                                    06341000
         EXECUTABLE;                                                    06342000
         SCAN;                                                          06343000
         SUBREF;                                                        06344000
END CALL;                                                               06345000
PROCEDURE COMMON;                                                       06346000
COMMENT  THIS PROCEDURE MAKES THE COM ENTRY FOR COMMON ITEMS AND SETS   06347000
           THE CE BIT IN BOTH THE COM AND INFO TABLES AND LINKS         06348000
           THE HEADS OF CHAINS;                                         06349000
BEGIN                                                                   06350000
         LABEL LOOP, BLOCK;                                             06351000
         TYPE ~ -2;                                                     06352000
         SCAN;                                                          06353000
         IF NEXT = ID THEN                                              06354000
    BEGIN                                                               06355000
         Z ~ NEED(".BLNK.", BLOCKID);                                   06356000
         IF XREF THEN ENTERX("BLANK.",0&BLOCKID[TOCLASS]);              06357000
         GO TO BLOCK;                                                   06358000
    END;                                                                06359000
    LOOP:                                                               06360000
         IF NEXT ! SLASH THEN FLOG(110);                                06361000
         SCAN;                                                          06362000
         IF NEXT = SLASH THEN Z ~ NEED(".BLNK.", BLOCKID) ELSE          06363000
    BEGIN                                                               06364000
         IF NEXT ! ID THEN FLOG(105) ELSE                               06365000
%  FORCE UNIQUE NAME BY APPENDING 1 TO NAME (2ND CHAR OF WORD)          06366000
         BEGIN Z ~ NEED(NAME&"1"[6:42:6],BLOCKID);                      06367000
               IF XREF THEN ENTERX(NAME,0&BLOCKID[TOCLASS]);            06368000
               SCAN;                                                    06369000
         END;                                                           06370000
         IF NEXT ! SLASH THEN FLOG(110);                                06371000
    END;                                                                06372000
         SCAN;                                                          06373000
    BLOCK:                                                              06374000
         IF (T~GET(Z+2)).ADINFO = 0 THEN                                06375000
    BEGIN                                                               06376000
         IF NEXTCOM~NEXTCOM+1>SUPERMAXCOM THEN                          06377000
            BEGIN ROOT~0;  FATAL(124) END                               06378000
         ELSE ROOT~NEXTCOM ;                                            06379000
         PUTC(ROOT,0&HEADER[TOCLASS]&1[TOCE]&ROOT[TOADDR]) ;            06380000
         BAPC(Z);                                                       06381000
    END ELSE                                                            06382000
    BEGIN                                                               06383000
         ROOT ~ T.ADINFO;                                               06384000
         COM[(T~GETC(ROOT).LASTC).IR,T.IC].LINK~NEXTCOM+1 ;             06385000
         IF COM[PWROOT]<0 THEN FLAG(2) ;                                06386000
    END;                                                                06387000
         DIMENSION;                                                     06388000
         BAPC(0&ENDCOM[TOCLASS]) ;                                      06389000
         COM[PWROOT].LASTC~NEXTCOM ;                                    06390000
         PUT(T~GETC(ROOT+1)+2,GET(T)&ROOT[TOADINFO]) ;                  06391000
         IF NEXT ! SEMI THEN GO TO LOOP;                                06392000
END COMMON;                                                             06393000
PROCEDURE ENDS;                                                         06394000
BEGIN                                                                   06395000
       IF SPLINK=0 THEN FLAG(184) ELSE                             %112-06396000
       BEGIN                                                       %112-06397000
         EODS~FALSE ;                                                   06398000
         IF LOGIFTOG THEN FLAG(101);                                    06399000
         LABL ~ BLANKS;                                                 06400000
         IF SPLINK < 0 THEN EMITO(XIT) ELSE EMITPAIR(0, KOM);           06401000
         SEGMENT((ADR+4) DIV 4, NSEG, TRUE, EDOC);                      06402000
       END;                                                        %112-06403000
END ENDS;                                                               06404000
PROCEDURE ENTRY;                                                        06405000
BEGIN                                                                   06406000
         REAL SP;                                                       06407000
         IF SPLINK = 0 THEN FLAG(111) ELSE                              06408000
         IF SPLINK = 1 THEN BEGIN ELX ~ 0; FLAG(4) END;                 06409000
         LABL ~ BLANKS;                                                 06410000
         ADJUST ;                                                       06411000
         SP ~ GET(SPLINK);                                              06412000
         FORMALPP( (T~SP.CLASS) = FUNID, T);                            06413000
         GETALL(FNEW, INFA, INFB, INFC);                                06414000
         IF INFA.CLASS = FUNID THEN                                     06415000
              PUT(FNEW, INFA & 1[TOTYPE] & (SP.SUBCLASS)[TOSUBCL]);     06416000
         PUT(FNEW+2, INFC & (ADR+1)[TOBASE]);                           06417000
END ENTRY;                                                              06418000
PROCEDURE EQUIVALENCE;                                                  06419000
COMMENT  THIS PROCEDURE MAKES THE COM ENTRY FOR EQUIV ITEMS AND SETS    06420000
           THE EQ BIT IN BOTH THE COM AND INFO TABLES AND LINKS         06421000
           THE HEADS OF CHAINS;                                         06422000
BEGIN                                                                   06423000
         REAL P, Q, R, S;                                               06424000
         BOOLEAN FIRST,PCOMM;                                           06425000
         LABEL XIT;                                                     06426000
         IF LOGIFTOG THEN FLAG(101);                                    06427000
         LABL ~ BLANKS;                                                 06428000
         DO                                                             06429000
    BEGIN                                                               06430000
         FIRST ~ FALSE;                                                 06431000
         SCAN;                                                          06432000
         IF NEXT ! LPAREN THEN BEGIN FLOG(106); GO TO XIT END;          06433000
         IF NEXTCOM~NEXTCOM+1>SUPERMAXCOM THEN                          06434000
            BEGIN ROOT~0;  FATAL(124) END                               06435000
         ELSE ROOT~NEXTCOM ;                                            06436000
         PUTC(ROOT,0&HEADER[TOCLASS]&ROOT[TOADDR]) ;                    06437000
         BAPC(0); Q~0 ;                                                 06438000
         DO                                                             06439000
    BEGIN                                                               06440000
         SCAN;                                                          06441000
         IF NEXT ! ID THEN BEGIN FLOG(105); GO TO XIT END;              06442000
         IF XREF THEN ENTERX(NAME,0&GET(FNEXT)[15:15:9]);               06443000
         FX1 ~ FNEXT;                                                   06444000
         LENGTH ~ 0;                                                    06445000
         SCAN;                                                          06446000
         IF NEXT = LPAREN THEN                                          06447000
    BEGIN                                                               06448000
         IF GET(FX1).CLASS ! ARRAYID THEN                               06449000
         BEGIN XTA ~ GET(FX1+1); FLOG(112) END;                         06450000
         R ~ 0; P ~ 1;                                                  06451000
         S ~ GET(FX1+2).ADINFO;                                         06452000
         DO                                                             06453000
    BEGIN                                                               06454000
         SCAN;                                                          06455000
         IF NEXT ! NUM OR NUMTYPE ! INTYPE THEN FLAG(113);              06456000
         LENGTH ~ LENGTH + P|(FNEXT-1);                                 06457000
         P ~ P|EXTRAINFO[(S+R).IR,(S+R).IC] ;                           06458000
         R ~ R-1;                                                       06459000
         SCAN;                                                          06460000
    END  UNTIL NEXT ! COMMA;                                            06461000
         IF NEXT ! RPAREN THEN BEGIN FLOG(108); GO TO XIT END;          06462000
         IF R!-1 THEN IF R~R+GET(FX1+2).NEXTRA!0 THEN                   06463000
            BEGIN  XTA~GET(FX1+1);  FLAG(IF R>0 THEN 23 ELSE 24) END ;  06464000
         SCAN;                                                          06465000
    END;                                                                06466000
         IF (INFA~GET(FX1)) < 0 THEN                                     6467000
         BEGIN XTA ~ GET(FX1+1); FLAG(39) END ELSE                       6468000
    BEGIN                                                                6469000
         IF INFA.SUBCLASS > LOGTYPE THEN LENGTH ~ 2|LENGTH ;            06470000
         BAPC(INFA&FX1[TOLINK]&LENGTH[TORELADD]&1[TOEQ]&ROOT[TOLASTC]); 06471000
         IF(PCOMM~BOOLEAN(INFA.CE)) OR BOOLEAN(INFA.EQ) THEN            06472000
    BEGIN                                                               06473000
         IF FIRST AND PCOMM THEN BEGIN XTA~GET(FX1+1); FLAG(2) END      06474000
         ELSE IF NOT FIRST THEN FIRST ~ PCOMM;                          06475000
         PUT(FX1,INFA & 1[TOEQ]);                                       06476000
         COM[NEXTCOM.IR,NEXTCOM.IC].LASTC ~ A ~ INFA.ADDR;              06477000
         B~GETC(ROOT).ADDR ;                                            06478000
         SETLINK(A);                                                    06479000
         IF NOT RINGCHECK THEN                                          06480000
    BEGIN                                                               06481000
         COM[PWROOT].ADDR~GETC(A).ADDR ;                                06482000
         PUTC(A,GETC(A)&B[TOADDR]&7[TOSUBCL]) ;                         06483000
    END                                                                 06484000
    END  ELSE                                                           06485000
         PUT(FX1,INFA & 1[TOEQ] & ROOT[TOADDR]);                        06486000
         IF LENGTH > Q THEN Q ~ LENGTH;                                 06487000
         IF BOOLEAN(INFA.FORMAL) THEN                                   06488000
         BEGIN XTA ~ GET(FX1+1); FLAG(11) END;                          06489000
    END;                                                                06490000
    END  UNTIL NEXT ! COMMA;                                            06491000
         IF NEXT ! RPAREN THEN BEGIN FLOG(108); GO TO XIT END;          06492000
         SCAN;                                                          06493000
         PUTC(ROOT+1,Q);                                                06494000
         BAPC(0&ENDCOM[TOCLASS]) ;                                      06495000
         COM[PWROOT].LASTC~NEXTCOM ;                                    06496000
    END  UNTIL NEXT ! COMMA;                                            06497000
    XIT:                                                                06498000
END EQUIVALENCE;                                                        06499000
PROCEDURE EXTERNAL;                                                     06500000
BEGIN                                                                   06501000
         IF SPLINK < 0 THEN FLAG( 12);                                  06502000
         IF LOGIFTOG THEN FLAG(101);                                    06503000
         LABL ~ BLANKS;                                                 06504000
         DO                                                             06505000
    BEGIN                                                               06506000
         SCAN;                                                          06507000
         IF NEXT ! ID THEN FLOG(105) ELSE                               06508000
         BEGIN T ~ NEED(NAME,EXTID);                                    06509000
               IF XREF THEN ENTERX(NAME,0&GET(T)[15:15:9]);             06510000
               SCAN;                                                    06511000
         END;                                                           06512000
    END  UNTIL NEXT ! COMMA;                                            06513000
END EXTERNAL;                                                           06514000
PROCEDURE CHAIN;                                                        06515000
BEGIN                                                                   06516000
    LABEL  AGN, XIT;                                                    06517000
    REAL  T1;                                                           06518000
    DEFINE FLG(FLG1) = BEGIN FLOG(FLG1); GO TO XIT END#;                06519000
    EXECUTABLE;                                                         06520000
    SCAN;                                                               06521000
    T1 ~ 2;                                                             06522000
    IF FALSE THEN                                                       06523000
 AGN: IF GLOBALNEXT ! COMMA THEN FLG(28);                               06524000
    SCAN;                                                               06525000
    IF EXPR(TRUE)  >  REALTYPE THEN FLG(102);                           06526000
    IF (T1 ~ T1 - 1) ! 0 THEN GO TO AGN;                                06527000
    IF GLOBALNEXT ! RPAREN THEN FLG(3);                                 06528000
    EMITPAIR(37,KOM);                                                   06529000
    SCAN;                                                               06530000
    IF GLOBALNEXT ! SEMI THEN FLOG(117);                                06531000
 XIT: WHILE GLOBALNEXT ! SEMI DO SCAN;                                  06532000
END CHAIN;                                                              06533000
PROCEDURE GOTOS;                                                        06534000
BEGIN    LABEL XIT;                                                     06535000
         REAL ASSIGNEDID;                                               06536000
         EODS~TRUE ;                                                    06537000
         EXECUTABLE;                                                    06538000
         SCAN;                                                          06539000
         IF NEXT = NUM THEN                                             06540000
    BEGIN                                                               06541000
         LABELBRANCH(NAME, FALSE);                                      06542000
         SCAN;                                                          06543000
         GO TO XIT;                                                     06544000
    END;                                                                06545000
         IF NEXT = ID THEN                                              06546000
    BEGIN                                                               06547000
         ASSIGNEDID ~ FNEXT;                                            06548000
         IF XREF THEN ENTERX(XTA,0&GET(FNEXT)[15:15:9]);                06549000
         SCAN;                                                          06550000
         IF NEXT ! COMMA THEN FLOG(114);                                06551000
         SCAN;                                                          06552000
         IF NEXT ! LPAREN THEN FLOG(106);                               06553000
         DO                                                             06554000
    BEGIN                                                               06555000
         SCAN;                                                          06556000
         IF NEXT ! NUM THEN FLOG(109);                                  06557000
         EMITV(ASSIGNEDID);                                             06558000
         EMITNUM(FNEXT);                                                06559000
         EMITO(NEQL);                                                   06560000
         LABELBRANCH(NAME, TRUE);                                       06561000
         SCAN;                                                          06562000
    END  UNTIL NEXT ! COMMA;                                            06563000
         IF NEXT ! RPAREN THEN FLOG(108);                               06564000
         SCAN;                                                          06565000
         EMITPAIR(1, SSN);   % CAUSE INVALID INDEX TERMINATION          06566000
         EMITDESCLIT(10);                                               06567000
         GO TO XIT;                                                     06568000
    END;                                                                06569000
         IF NEXT ! LPAREN THEN FLOG(106);                               06570000
         P ~ 0;                                                         06571000
         DO                                                             06572000
    BEGIN                                                               06573000
         SCAN;                                                          06574000
         IF NEXT ! NUM THEN BEGIN FLOG(109); GO TO XIT END;             06575000
         LSTT[P~P+1] ~ NAME;                                            06576000
         SCAN;                                                          06577000
    END  UNTIL NEXT ! COMMA;                                            06578000
         IF NEXT ! RPAREN THEN BEGIN FLOG(108); GO TO XIT END;          06579000
         SCAN;                                                          06580000
         IF NEXT ! COMMA THEN BEGIN FLOG(114); GO TO XIT END;           06581000
         SCAN;                                                          06582000
         IT ~ P+1;           % DONT LET EXPR WIPE OUT LSTT              06583000
         IF EXPR(TRUE) > REALTYPE THEN FLOG(102);                       06584000
         EMITPAIR(JUNK, ISN);                                           06585000
         EMITPAIR(1,LESS);                                              06586000
         EMITOPDCLIT(JUNK);                                             06587000
         EMITO(LOR);                                                    06588000
         EMITOPDCLIT(JUNK);                                             06589000
         EMITL(3);                                                      06590000
         EMITO(MUL);                                                    06591000
    IF ADR+3|P > 4085 THEN BEGIN ADR~ADR+1; SEGOVF END;                 06592000
         EMITO(BFC);                                                    06593000
         EMITPAIR(1, SSN);                                              06594000
         EMITDESCLIT(10);                                               06595000
         FOR I ~ 1 STEP 1 UNTIL P DO                                    06596000
    BEGIN                                                               06597000
         J ~ ADR; LABELBRANCH(LSTT[I], FALSE);                          06598000
         IF ADR-J = 2 THEN EMITO(NOP);                                  06599000
    END;                                                                06600000
    XIT:                                                                06601000
         IT ~ 0;                                                        06602000
END GOTOS;                                                              06603000
PROCEDURE IFS;                                                          06604000
BEGIN    REAL TYPE, LOGIFADR, SAVELABL;                                 06605000
         EODS~TRUE;                                                     06606000
         EXECUTABLE;                                                    06607000
         SCAN;                                                          06608000
         IF NEXT ! LPAREN THEN FLOG(106);                               06609000
         SCAN;                                                          06610000
         IF TYPE ~ EXPR(TRUE) = COMPTYPE THEN FLAG(89);                 06611000
         IF NEXT ! RPAREN THEN FLOG(108);                               06612000
         IF TYPE = LOGTYPE THEN                                         06613000
    BEGIN                                                               06614000
         EMITB(-1, TRUE);                                               06615000
         LOGIFADR ~ LAX;                                                06616000
         LOGIFTOG ~ TRUE; EOSTOG ~ TRUE;                                06617000
         SAVELABL ~ LABL; LABL ~ BLANKS;                                06618000
         STATEMENT;                                                     06619000
         LABL ~ SAVELABL;                                               06620000
         LOGIFTOG ~ FALSE; EOSTOG ~ FALSE;                              06621000
         FIXB(LOGIFADR);                                                06622000
    END ELSE                                                            06623000
    BEGIN                                                               06624000
         IF TYPE = DOUBTYPE THEN                                        06625000
         BEGIN EMITO(XCH); EMITO(DEL) END;                              06626000
         SCAN;                                                          06627000
         IF NEXT ! NUM THEN FLOG(109);                                  06628000
         FX1 ~ FNEXT; NX1 ~ NAME;                                       06629000
         SCAN;                                                          06630000
         IF NEXT ! COMMA THEN FLOG(114);                                06631000
         SCAN;                                                          06632000
         IF NEXT ! NUM THEN FLOG(109);                                  06633000
         FX2 ~ FNEXT; NX2 ~ NAME;                                       06634000
         SCAN;                                                          06635000
         IF NEXT ! COMMA THEN FLOG(114);                                06636000
         SCAN;                                                          06637000
         IF NEXT ! NUM THEN FLOG(109);                                  06638000
         FX3 ~ FNEXT; NX3 ~ NAME;                                       06639000
         SCAN;                                                          06640000
         IF FX2 = FX3 THEN                                              06641000
    BEGIN                                                               06642000
         EMITPAIR(0,GEQL);                                              06643000
         LABELBRANCH(NX1, TRUE);                                        06644000
         LABELBRANCH(NX3, FALSE);                                       06645000
         IF XREF THEN ENTERX(NX2,0&LABELID[TOCLASS]);                   06646000
    END ELSE                                                            06647000
         IF FX1 = FX3 THEN                                              06648000
    BEGIN                                                               06649000
         EMITPAIR(0,NEQL);                                              06650000
         LABELBRANCH(NX2, TRUE);                                        06651000
         LABELBRANCH(NX1, FALSE);                                       06652000
         IF XREF THEN ENTERX(NX3,0&LABELID[TOCLASS]);                   06653000
    END ELSE                                                            06654000
         IF FX1 = FX2 THEN                                              06655000
    BEGIN                                                               06656000
         EMITPAIR(0,LEQL);                                              06657000
         LABELBRANCH(NX3, TRUE);                                        06658000
         LABELBRANCH(NX1, FALSE);                                       06659000
         IF XREF THEN ENTERX(NX2,0&LABELID[TOCLASS]);                   06660000
    END ELSE                                                            06661000
    BEGIN                                                               06662000
         EMITO(DUP);                                                    06663000
         EMITPAIR(0,NEQL);                                              06664000
         EMITB(-1,TRUE);                                                06665000
         EMITPAIR(0,LESS);                                              06666000
         LABELBRANCH(NX3, TRUE);                                        06667000
         LABELBRANCH(NX1, FALSE);                                       06668000
         FIXB(LAX);                                                     06669000
         EMITO(DEL);                                                    06670000
         LABELBRANCH(NX2, FALSE);                                       06671000
    END;                                                                06672000
    END;                                                                06673000
END IFS;                                                                06674000
PROCEDURE NAMEL;                                                        06675000
BEGIN LABEL NIM,XIT,ELMNT,WRAP;                                         06676000
         IF SPLINK < 0 THEN FLAG(12);                                   06677000
         IF LOGIFTOG THEN FLAG(101);                                    06678000
         LABL ~ BLANKS;                                                 06679000
      SCAN;  IF NEXT ! SLASH THEN FLOG(110);                            06680000
NIM:  SCAN;  IF NEXT ! ID THEN BEGIN FLOG(105);  GO TO XIT END;         06681000
      IF J ~ (INFA ~ GET(LADR2 ~ FNEXT)).CLASS = UNKNOWN THEN           06682000
      PUT(LADR2,INFA&NAMELIST[TOCLASS])                                 06683000
      ELSE IF J ! NAMELIST THEN                                         06684000
      BEGIN XTA ~ GET(LADR2 + 1);                                       06685000
            FLAG(20);                                                   06686000
      END;                                                              06687000
      LSTT[LSTS ~ LADR1 ~ 0] ~ NAME;                                    06688000
      IF XREF THEN ENTERX(NAME,0&NAMELIST[TOCLASS]);                    06689000
      SCAN;  IF NEXT ! SLASH THEN FLOG(110);                            06690000
ELMNT: SCAN; IF NEXT ! ID THEN BEGIN FLOG(105); GO TO XIT END;          06691000
      LADR1 ~ LADR1 + 1;                                                06692000
      IF (T ~ GET(FNEW ~ GETSPACE(FNEXT)).CLASS) > VARID THEN FLAG(48); 06693000
      GETALL(FNEW,INFA,INFB,INFC);                                      06694000
      IF XREF THEN ENTERX(INFB,0&INFA[15:15:9]);                        06695000
      IF LSTS ~ LSTS+1 = LSTMAX THEN BEGIN FLOG(78); GO TO XIT END ELSE 06696000
      LSTT[LSTS] ~ NAME&INFA.CLASNSUB[2:38:10]&0[8:47:1];               06697000
      IF T = ARRAYID THEN                                               06698000
      BEGIN J ~ INFC.ADINFO;                                            06699000
            I ~ INFC.NEXTRA;                                            06700000
            IF LSTS + I + 1 > LSTMAX THEN                               06701000
            BEGIN FLOG(78);  GO TO XIT END;                             06702000
            LSTT[LSTS ~ LSTS + 1] ~ 0&I[1:42:6]   %  # DIMENSIONS       06703000
                                     &INFA.ADDR[7:37:11]   %  REL ADR   06704000
                                     &INFC.BASE[18:33:15]   %  BASE     06705000
                                     &INFC.SIZE[33:33:15];   %  SIZE    06706000
            FOR T ~ J STEP -1 UNTIL J - I + 1 DO                        06707000
            LSTT[LSTS ~ LSTS + 1] ~ EXTRAINFO[T.IR,T.IC];               06708000
      END ELSE BEGIN LSTT[LSTS~LSTS+1]~0&(INFA.ADDR)[7:37:11];          06709000
      IF BOOLEAN(INFA.CE) THEN LSTT[LSTS]~LSTT[LSTS]&INFC.BASE[18:33:15]06710000
                                       &INFC.SIZE[33:33:15] END;        06711000
      SCAN;  IF NEXT = COMMA THEN GO TO ELMNT;                          06712000
      IF NEXT ! SEMI AND NEXT ! SLASH THEN FLOG(115);                   06713000
      LSTT[LSTS + 1] ~ 0;                                               06714000
      LSTT[0].[2:10] ~ LADR1;                                           06715000
      PRTSAVER(LADR2,LSTS + 2,LSTT);                                    06716000
      IF NEXT ! SEMI THEN GO TO NIM;                                    06717000
XIT:                                                                    06718000
END NAMEL;                                                              06719000
PROCEDURE PAUSE;                                                        06720000
IF DCINPUT THEN BEGIN XTA~"PAUSE ";   FLOG(151) END ELSE                06721000
BEGIN                                                                   06722000
         EODS~TRUE ;                                                    06723000
         IF TSSEDITOG THEN TSSED("PAUSE ",2) ;                          06724000
         EXECUTABLE;                                                    06725000
         SCAN;                                                          06726000
         IF NEXT = SEMI THEN EMITL(0) ELSE                              06727000
         IF NEXT = NUM THEN                                             06728000
    BEGIN                                                               06729000
         EMITNUM(NAME);                                                 06730000
         SCAN;                                                          06731000
    END;                                                                06732000
         EMITPAIR(33, KOM);                                             06733000
         EMITO(DEL);                                                    06734000
END PAUSE;                                                              06735000
PROCEDURE TYPIT(TYP,TMPNXT);  VALUE TYP;  REAL TYP,TMPNXT ;             06736000
    BEGIN                                                               06737000
    TYPE~TYP;  SCAN ;                                                   06738000
    IF NEXT=16 THEN BEGIN TMPNXT~16; FUNCTION END ELSE DIMENSION ;      06739000
    END OF TYPIT ;                                                      06740000
DEFINE COMPLEX             =TYPIT(COMPTYPE,TEMPNEXT) #,                 06741000
       LOGICAL             =TYPIT(LOGTYPE ,TEMPNEXT) #,                 06742000
       DOUBLEPRECISION     =TYPIT(DOUBTYPE,TEMPNEXT) #,                 06743000
       INTEGERS            =TYPIT(INTYPE  ,TEMPNEXT) #,                 06744000
       REALS               =TYPIT(REALTYPE,TEMPNEXT) #;                 06745000
PROCEDURE STOP;                                                         06746000
BEGIN                                                                   06747000
         RETURNFOUND ~ TRUE;                                            06748000
         EODS~TRUE;                                                     06749000
         EXECUTABLE;                                                    06750000
         COMMENT INITIAL SCAN ALREADY DONE;                             06751000
         EMITL(1);                                                      06752000
         EMITPAIR(16,STD);                                              06753000
         EMITPAIR(10, KOM);                                             06754000
         EMITPAIR(5, KOM);                                              06755000
         WHILE NEXT ! SEMI DO SCAN;                                     06756000
END STOP;                                                               06757000
PROCEDURE RETURN;                                                       06758000
BEGIN LABEL EXIT;                                                       06759000
         REAL T, XITCODE;                                               06760000
         RETURNFOUND ~ TRUE;                                            06761000
         EODS~TRUE ;                                                    06762000
         EXECUTABLE;                                                    06763000
         SCAN;                                                          06764000
         IF SPLINK=0 OR SPLINK=1 THEN                                   06765000
              BEGIN XTA~"RETURN"; FLOG(153); GO EXIT END ;              06766000
         IF NEXT = SEMI THEN                                            06767000
    BEGIN                                                               06768000
         IF (T ~ GET(SPLINK)).CLASS = FUNID THEN                        06769000
    BEGIN                                                               06770000
         EMITV(FUNVAR);                                                 06771000
         IF T.SUBCLASS > LOGTYPE THEN EMITPAIR(JUNK, STD);              06772000
         XITCODE ~ RTN;                                                 06773000
    END  ELSE XITCODE ~ XIT;                                            06774000
    IF ADR } 4077 THEN                                                  06775000
         BEGIN ADR ~ ADR+1; SEGOVF END;                                 06776000
         EMITOPDCLIT(1538);       % F+2                                 06777000
         EMITPAIR(3, BFC);                                              06778000
         EMITPAIR(10, KOM);                                             06779000
         EMITO(XITCODE);                                                06780000
         EMITOPDCLIT(16);                                               06781000
         EMITPAIR(1, SUB);                                              06782000
         EMITPAIR(16, STD);                                             06783000
         EMITO(XITCODE);                                                06784000
         GO TO EXIT;                                                    06785000
    END;                                                                06786000
         IF LABELMOM = 0 THEN FLOG(145);                                06787000
         IF EXPR(TRUE) > REALTYPE THEN FLAG(102);                       06788000
         IF EXPRESULT = NUMCLASS THEN                                   06789000
         BEGIN IF XREF THEN ENTERX(EXPVALUE,0&LABELID[TOCLASS]);        06790000
               ADR ~ ADR-1;EMITL(EXPVALUE-1)                            06791000
         END ELSE                                                       06792000
         EMITPAIR(1, SUB);                                              06793000
         EMITOPDCLIT(LABELMOM);                                         06794000
         EMITO(MKS);                                                    06795000
         EMITL(9);                                                      06796000
         EMITOPDCLIT(5);                                                06797000
    EXIT:                                                               06798000
END RETURN;                                                             06799000
PROCEDURE IMPLICIT ;                                                    06800000
    BEGIN                                                               06801000
    REAL R1,R2,R3,R4 ;                                                  06802000
    LABEL R,A,X,L ;                                                     06803000
  IF NOT(LASTNEXT=42 OR LASTNEXT=1000 OR LASTNEXT=30               %110-06804000
          OR LASTNEXT=16 OR LASTNEXT = 11)                         %110-06805000
    THEN BEGIN FLOG(181); FILETOG~TRUE; GO X END ;                      06806000
R:  EOSTOG~ERRORTOG~TRUE; FILETOG~FALSE ;                               06807000
    MOVEW(ACCUM[3],ACCUM[2],0,3); SCAN; ERRORTOG~FALSE; FILETOG~TRUE ;  06808000
    IF R1~IF R2~NEXT=18 THEN INTID ELSE IF R3=26 THEN REALID ELSE 0&    06809000
          (IF R3=10 THEN DOUBTYPE ELSE IF R3=19 THEN LOGTYPE ELSE IF R3=06810000
           6 THEN COMPTYPE ELSE 0)[TOSUBCL]=0 THEN                      06811000
                   BEGIN FLOG(182); GO X END ;                          06812000
    SCN~2;  SCAN ;                                                      06813000
    IF NEXT = STAR THEN IF R3!10 THEN                                   06814000
         BEGIN SCAN ;                                                   06815000
         IF NEXT=NUM AND NUMTYPE=INTYPE THEN                            06816000
              BEGIN                                                     06817000
              IF FNEXT=4 THEN BEGIN IF R3=6 THEN FLAG(176); GO L END ;  06818000
              IF FNEXT=8 THEN                                           06819000
                   BEGIN                                                06820000
                   IF R3=26 THEN R1~0&DOUBTYPE[TOSUBCL]                 06821000
                   ELSE IF R3!6 THEN FLAG(177) ;                        06822000
                   GO L;                                                06823000
                   END ;                                                06824000
              END ;                                                     06825000
         FLAG(IF R3=26 THEN 178 ELSE 177-REAL(R3=6)) ;                  06826000
L:       NCR~REAL(NCR.[30:3]!0)+3"677777"+NCR;  SCN~1;  SCAN ;          06827000
         END ;                                                          06828000
    IF NEXT!LPAREN THEN BEGIN FLOG(106); GO X END ;                     06829000
A:  SCAN;  R4~ERRORCT ;                                                 06830000
    IF R2~NAME.[12:6]<17 OR (R2>25 AND R2<33) OR (R2>41 AND R2<50)      06831000
       OR R2>57 OR NAME.[18:30]!"     " THEN FLAG(179) ;                06832000
    SCAN ;                                                              06833000
    IF NEXT!MINUS THEN                                                  06834000
         BEGIN IF ERRORCT=R4 THEN TIPE[IF R2!"0" THEN R2 ELSE 12]~R1 END06835000
    ELSE BEGIN                                                          06836000
         SCAN ;                                                         06837000
         IF R3~NAME.[12:6]<17 OR (R3>25 AND R3<33) OR (R3>41 AND R3<50) 06838000
            OR R3>57 OR NAME.[18:30]!"     " THEN FLAG(179) ;           06839000
         IF R3 LEQ R2 THEN FLAG(180) ;                                  06840000
         IF ERRORCT=R4 THEN FOR R2~R2 STEP 1 UNTIL R3 DO                06841000
              BEGIN                                                     06842000
              IF R2>25 AND R2<33 THEN R2~33 ELSE IF R2>41 AND R2<50     06843000
                                                 THEN R2~50 ;           06844000
              TIPE[IF R2!"0" THEN R2 ELSE 12]~R1 ;                      06845000
              END ;                                                     06846000
         SCAN ;                                                         06847000
         END ;                                                          06848000
    IF NEXT=COMMA THEN GO A ;                                           06849000
    IF NEXT!RPAREN THEN BEGIN FLOG(108); GO X END ;                     06850000
    SCAN; IF NEXT=COMMA THEN GO R ;                                     06851000
    IF NEXT!SEMI THEN BEGIN FLOG(117); GO X END ;                       06852000
    IF SPLINK > 1 THEN                                                  06853000
         BEGIN                                                          06854000
         IF BOOLEAN(TYPE.[2:1]) THEN IF GET(SPLINK).CLASS=FUNID THEN    06855000
               BEGIN                                                    06856000
               INFO[SPLINK.IR,SPLINK.IC].SUBCLASS~R3~TIPE[IF R3~GET(    06857000
                    SPLINK+1).[12:6]!"0" THEN R3 ELSE 12].SUBCLASS ;    06858000
               INFO[FUNVAR.IR,FUNVAR.IC].SUBCLASS~R3 ;                  06859000
               END ;                                                    06860000
         IF R1~GET(SPLINK+2)<0 THEN                                     06861000
              FOR R2~R1.NEXTRA-1+R1~R1.ADINFO STEP -1 UNTIL R1 DO       06862000
                   IF R3~PARMLINK[R2-R1+1]!0 THEN                       06863000
                        BEGIN                                           06864000
                        EXTRAINFO[R2.IR,R2.IC].SUBCLASS~R4~TIPE[IF R4~  06865000
                             GET(R3+1).[12:6]!"0" THEN R4 ELSE 12]      06866000
                             .SUBCLASS ;                                06867000
                        INFO[R3.IR,R3.IC].SUBCLASS~R4 ;                 06868000
                        END ;                                           06869000
         END ;                                                          06870000
X:  WHILE NEXT!SEMI DO SCAN; FILETOG~FALSE ;                            06871000
    END OF IMPLICIT ;                                                   06872000
                                                                        06873000
PROCEDURE SUBROUTINE;                                                   06874000
BEGIN                                                                   06875000
         IF SPLINK NEQ 0 THEN BEGIN FLAG(5); ENDS; SEGMENTSTART; END;   06876000
         LABL ~ BLANKS;                                                 06877000
         FORMALPP(FALSE, SUBRID);                                       06878000
         SPLINK ~ FNEW;                                                 06879000
END SUBROUTINE;                                                         06880000
PROCEDURE MEMHANDLER(N);  VALUE N;  REAL N ;                            06881000
    BEGIN                                                               06882000
    REAL A ;                                                            06883000
    LABEL L1,L2,L3,XIT ;                                                06884000
    IF DEBUGTOG THEN FLAGROUTINE(" MEMHA","NDLER ",TRUE) ;              06885000
    IF N LEQ 2 THEN                                                     06886000
         BEGIN % FIXED=1, VARYING=2.                                    06887000
         N~IF N=1 THEN 6 ELSE 0 ;                                       06888000
L1:      SCAN;                                                          06889000
         IF NEXT!ID THEN BEGIN FLOG(105); GO XIT END ;                  06890000
         IF (A~GET(GETSPACE(FNEXT))).CLASS!ARRAYID THEN                 06891000
              BEGIN FLOG(35); GO XIT END ;                              06892000
         IF XREF THEN ENTERX(XTA,0&A[15:15:9]) ;                        06893000
         IF BOOLEAN(A.EQ) OR BOOLEAN(A.FORMAL) THEN FLAG(169)           06894000
         ELSE BEGIN                                                     06895000
              EMITO(MKS);  EMITPAIR(A.ADDR,LOD);  EMITL(N) ;            06896000
              EMITV(NEED(".MEMHR",INTRFUNID)) ;                         06897000
              END ;                                                     06898000
         SCAN;  IF NEXT=COMMA THEN GO L1 ;                              06899000
         END                                                            06900000
    ELSE IF N=3 THEN                                                    06901000
              BEGIN % AUXMEMED FUNCTION OR SUBROUTINE.                  06902000
              SCAN ;                                                    06903000
              IF NEXT!ID THEN BEGIN FLOG(105); GO XIT END ;             06904000
              IF GET(FNEXT+1)!GET(SPLINK+1) THEN                        06905000
                   BEGIN FLOG(170); GO XIT END ;                        06906000
              PUT(SPLINK,GET(SPLINK)&1[TOADJ]) ;                        06907000
              IF XREF THEN ENTERX(XTA,0&GET(FNEXT)[15:15:9]);  SCAN ;   06908000
              END                                                       06909000
         ELSE BEGIN % RELEASE.                                          06910000
L2:           SCAN ;                                                    06911000
              IF NEXT!ID THEN BEGIN FLOG(105); GO XIT END ;             06912000
              IF (A~GET(GETSPACE(FNEXT))).CLASS=ARRAYID THEN            06913000
                   BEGIN                                                06914000
                   IF BOOLEAN(A.EQ) OR BOOLEAN(A.FORMAL) THEN FLAG(169) 06915000
                   ELSE BEGIN                                           06916000
                        EMITO(MKS);  EMITPAIR(A.ADDR,LOD) ;             06917000
                        EMITPAIR(1,SSN) ;                               06918000
                        EMITV(NEED(".MEMHR",INTRFUNID)) ;               06919000
                        END ;                                           06920000
L3:                IF XREF THEN ENTERX(XTA,0&A[15:15:9]) ;              06921000
                   END                                                  06922000
              ELSE IF A.CLASS}BLOCKID OR A.CLASS{LABELID THEN           06923000
                        BEGIN FLOG(171); GO XIT END                     06924000
                   ELSE BEGIN                                           06925000
                        EMITPAIR(A.ADDR,LOD);  EMITPAIR(38,KOM) ;       06926000
                        EMITO(DEL);  GO L3 ;                            06927000
                        END ;                                           06928000
              SCAN;  IF NEXT=COMMA THEN GO L2 ;                         06929000
              END ;                                                     06930000
XIT:IF DEBUGTOG THEN FLAGROUTINE(" MEMHA","NDLER ",FALSE) ;             06931000
    END OF MEMHANDLER ;                                                 06932000
PROCEDURE STATEMENT;                                                    06933000
BEGIN LABEL DOL1, XIT;                                                  06934000
      REAL TEMPNEXT ;                                                   06935000
      BOOLEAN ENDTOG;                                              %112-06936000
         DO SCAN UNTIL NEXT ! SEMI;                                     06937000
         IF NEXT=ID THEN ASSIGNMENT ELSE IF NEXT LEQ RSH1 THEN          06938000
         CASE(TEMPNEXT~NEXT) OF                                         06939000
    BEGIN                                                               06940000
         FLOG(16);                                                      06941000
         ASSIGN;                                                        06942000
         IOCOMMAND(4);      %BACKSPACE                                  06943000
         BLOCKDATA;                                                     06944000
         CALL;                                                          06945000
         COMMON;                                                        06946000
         COMPLEX;                                                       06947000
         BEGIN EXECUTABLE; SCAN END;      % CONTINUE                    06948000
         IOCOMMAND(7);   %  DATA                                        06949000
         BEGIN SCAN; TYPE ~ -1; DIMENSION END;                          06950000
         DOUBLEPRECISION;                                               06951000
         BEGIN ENDS; ENDTOG:=TRUE; SCAN END;                       %112-06952000
         FILECONTROL(1);   %ENDFILE                                     06953000
         ENTRY;                                                         06954000
         EQUIVALENCE;                                                   06955000
         EXTERNAL;                                                      06956000
         BEGIN TYPE ~ -1; FUNCTION END;                                 06957000
         GOTOS;                                                         06958000
         INTEGERS;                                                      06959000
         LOGICAL;                                                       06960000
         NAMEL;                                                         06961000
         PAUSE;                                                         06962000
         IOCOMMAND(2);     %PRINT                                       06963000
         ;                                                              06964000
         IOCOMMAND(3);     %PUNCH                                       06965000
         IOCOMMAND(0);     %READ                                        06966000
         REALS;                                                         06967000
         RETURN;                                                        06968000
         FILECONTROL(0);   %REWIND                                      06969000
         BEGIN SCAN; STOP END;                                          06970000
         SUBROUTINE;                                                    06971000
         IOCOMMAND(1);     %WRITE                                       06972000
         FILECONTROL(7);   %CLOSE                                       06973000
         FILECONTROL(6);   %LOCK                                        06974000
         FILECONTROL(4);   %PURGE                                       06975000
         IFS;                                                           06976000
         FORMATER;                                                      06977000
         CHAIN;                                                         06978000
         MEMHANDLER(1) ; %FIXED                                         06979000
         MEMHANDLER(2) ; %VARYING                                       06980000
         MEMHANDLER(3) ; %AUXMEM FOR SUBPROGRAMS                        06981000
         MEMHANDLER(4) ; %RELEASE                                       06982000
         IMPLICIT ;                                                     06983000
    END ELSE IF NEXT=EOF THEN GO XIT ELSE BEGIN NEXT~0; FLOG(16) END ;  06984000
         LASTNEXT.[33:15]~TEMPNEXT ;                                    06985000
         IF NOT ENDTOG THEN IF SPLINK=0 THEN SPLINK:=1;            %112-06986000
         ENDTOG:=FALSE;                                            %112-06987000
         IF LABL ! BLANKS THEN                                          06988000
    BEGIN                                                               06989000
         IF DT ! 0 THEN                                                 06990000
    BEGIN                                                               06991000
    DOL1: IF LABL = DOLAB[TEST ~ DT] THEN                               06992000
    BEGIN                                                               06993000
         EMITB(DOTEST[DT], FALSE);                                      06994000
         FIXB(DOTEST[DT].ADDR);                                         06995000
         IF DT ~ DT-1 > 0 THEN GO TO DOL1;                              06996000
    END ELSE                                                            06997000
         WHILE TEST ~ TEST-1 > 0 DO                                     06998000
         IF DOLAB[TEST] = LABL THEN FLAG(14);                           06999000
    END;                                                                07000000
         LABL ~ BLANKS;                                                 07001000
    END;                                                                07002000
         IF NEXT ! SEMI THEN                                            07003000
    BEGIN                                                               07004000
         FLAG(117);                                                     07005000
         DO SCAN UNTIL NEXT=SEMI OR NEXT=EOF ;                          07006000
    END;                                                                07007000
         ERRORTOG ~ FALSE;                                              07008000
         EOSTOG ~ TRUE;                                                 07009000
    XIT:                                                                07010000
END STATEMENT;                                                          07011000
                                                                        07012000
BOOLEAN STREAM PROCEDURE FLAGLAST(BUFF,ERR) ;                           07013000
   BEGIN                                                                07014000
   LOCAL A;   SI~ERR;  8(IF SC!" " THEN JUMP OUT;SI~SI+1;TALLY~TALLY+1);07015000
   A~TALLY;   SI~LOC A;   SI~SI+7 ;                                     07016000
   IF SC<"8" THEN                                                       07017000
      BEGIN   TALLY~1;   FLAGLAST~TALLY ;                               07018000
      DI~BUFF;DS~46 LIT"LAST SYNTAX ERROR OCCURRED AT SEQUENCE NUMBER ";07019000
      DS~LIT""";   SI~ERR;   DS~8 CHR;   DS~LIT""";                     07020000
       DS~32 LIT "                                ";               %510-07021000
       DS~32 LIT "                                ";               %510-07022000
      END                                                               07023000
   END FLAGLAST ;                                                       07024000
INTEGER PROCEDURE FEELD(X);   VALUE X;   INTEGER X;                     07025000
FEELD~IF X<10 THEN 1 ELSE IF X<100 THEN 2 ELSE IF X<1000 THEN 3 ELSE IF 07026000
X<10000 THEN 4 ELSE IF X<100000 THEN 5 ELSE IF X<1000000 THEN 6 ELSE 7; 07027000
FORMAT EOC1(/ "NUMBER OF SYNTAX ERRORS DETECTED = ",I*,".",X*,          07028000
            "NUMBER OF SEQUENCE ERRORS DETECTED = ",I*,"."),            07029000
       EOC2("PRT SIZE = ",I*,";   TOTAL SEGMENT SIZE = ",I*,            07030000
            " WORDS;  DISK SIZE = ",I*," SEGS;  NO. PRGM. SEGS = ",I*,  07031000
            "."),                                                       07032000
       EOC3("ESTIMATED CORE STORAGE REQUIREMENT = ",I*," WORDS;",       07033000
            "  COMPILATION TIME = ",I*," MIN, ",I*," SECS;",            07034000
            "  NO. CARDS = ",I*,"."),                                   07035000
       EOC4("ESTIMATED CORE STORAGE REQUIREMENT = ",I*," WORDS;"        07036000
            "  COMPILATION TIME = ",I*," SECS;  NO. CARDS = ",I*,"."),  07037000
       EOC5("NUMBER OF TSS WARNINGS DETECTED = ",I*,".") ;              07038000
COMMENT  MAIN DRIVER FOR FORTRAN COMPILER BEGINS HERE;                  07039000
RTI ~ TIME(1);                                                          07040000
INITIALIZATION;                                                         07041000
         DO STATEMENT UNTIL NEXT = EOF;                                 07042000
  IF NOT ENDSEGTOG THEN IF SPLINK NEQ 0                            %112-07043000
     THEN BEGIN XTA:=BLANKS; FLAG(5); ENDS END;                    %112-07044000
         WRAPUP;                                                        07045000
POSTWRAPUP:                                                             07046000
IF TIMETOG THEN IF FIRSTCALL THEN DATIME;                               07047000
IF NOT FIRSTCALL THEN                                                   07048000
   BEGIN                                                                07049000
   WRITE(RITE,EOC1,FEELD(ERRORCT),ERRORCT,IF SEQERRCT=0 THEN 99 ELSE    07050000
   5,FEELD(SEQERRCT-1),SEQERRCT-1) ;                                    07051000
   IF WARNED AND NOT DCINPUT THEN WRITE(RITE,EOC5,FEELD(WARNCOUNT),     07052000
   WARNCOUNT) ;                                                         07053000
   WRITE(RITE,EOC2,FEELD(PRTS),PRTS,FEELD(TSEGSZ),TSEGSZ,FEELD(DALOC-1),07054000
   DALOC-1,FEELD(NXAVIL),NXAVIL) ;                                      07055000
   IF C1~(TIME(1)-RTI)/60 > 59 THEN WRITE(RITE,EOC3,FEELD(64|ESTIMATE), 07056000
   64|ESTIMATE,FEELD(C1 DIV 60),C1 DIV 60,FEELD(C1 MOD 60),C1 MOD 60,   07057000
   FEELD(CARDCOUNT-1),CARDCOUNT-1) ELSE WRITE(RITE,EOC4,FEELD(ESTIMATE  07058000
   |64),ESTIMATE|64,FEELD(C1),C1,FEELD(CARDCOUNT-1),CARDCOUNT-1) ;      07059000
   IF ERRORCT>0 THEN IF FLAGLAST(ERRORBUFF,LASTERR) THEN WRITE(RITE,15, 07060000
   ERRORBUFF[*]) ;                                                      07061000
   END ;                                                                07062000
END INNER BLOCK;                                                        07063000
END.                                                                    07064000
                                                               